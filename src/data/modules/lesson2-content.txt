# Essential to know
- NEVER store plain text passwords
- bcrypt hashes with salt automatically
- Salt prevents rainbow table attacks
- Use high cost factor (10-12)

---

# Password Hashing with bcrypt

## Why Hash Passwords?

**❌ NEVER store passwords in plain text!**

If your database is compromised:
- Plain text: Attacker has all passwords immediately
- Hashed: Attacker must crack each password individually

### Real-World Consequences

When companies store plain text passwords:
- Users lose trust
- Legal liability (GDPR violations)
- Credential stuffing attacks (trying leaked passwords on other sites)
- Reputational damage

## What is Hashing?

Hashing is a **one-way function** that converts data into a fixed-length string. You cannot reverse it to get the original data.

```
Password: "mypassword123"
    ↓
Hash Function
    ↓
Hash: "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.VTtYA.qGZvKG6G"
```

**Key properties:**
- Same input always produces same output
- Different inputs produce very different outputs
- Impossible to reverse (get password from hash)
- Fast to compute, slow to crack

## Why bcrypt?

### Problems with Simple Hashing (MD5, SHA1)

1. **Rainbow Tables**: Pre-computed tables of common passwords and their hashes
   - Attackers look up hash → instant password recovery

2. **Fast Computation**: Modern GPUs can compute billions of hashes per second
   - Brute force attacks are feasible

### bcrypt Solutions

**1. Automatic Salting**

A salt is random data added to each password before hashing:

```
Password: "password123"
Salt: "random_salt_abc123"
Combined: "password123random_salt_abc123"
Hash: bcrypt(combined)
```

**Result:**
- Same password, different salt = different hash
- Rainbow tables become useless
- Must crack each password individually

**2. Adaptive Cost Factor**

bcrypt has a "work factor" (cost) that makes hashing slower:

```javascript
// Cost factor 10: ~100ms per hash
// Cost factor 12: ~300ms per hash
// Cost factor 14: ~1s per hash
```

As computers get faster, you increase the cost factor.

## Using bcrypt in Node.js

### Installation

```bash
npm install bcrypt
```

### Hashing Passwords

```javascript
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 12;  // 10-12 recommended

// Hash a password
async function hashPassword(password) {
  // bcrypt automatically:
  // 1. Generates random salt
  // 2. Hashes password with salt
  // 3. Returns combined hash
  const hash = await bcrypt.hash(password, SALT_ROUNDS);
  return hash;
}

// Example
const password = "mypassword123";
const hash = await hashPassword(password);
console.log(hash);
// $2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.VTtYA.qGZvKG6G
```

**Understanding the hash format:**
```
$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.VTtYA.qGZvKG6G
│   │  │
│   │  └── Salt (22 chars) + Hash (31 chars)
│   └───── Cost factor (2^12 iterations)
└───────── Algorithm (2b = bcrypt)
```

### Verifying Passwords

```javascript
// Verify a password against stored hash
async function verifyPassword(password, hash) {
  const isValid = await bcrypt.compare(password, hash);
  return isValid;  // true or false
}

// Usage in login route
app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Get user from database
  const user = await db.getUserByEmail(email);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Verify password
  const isValid = await bcrypt.compare(password, user.passwordHash);
  if (!isValid) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Success! Create session/token
  const token = createToken(user.id);
  res.json({ token });
});
```

## Complete Registration Example

```javascript
import bcrypt from 'bcrypt';
import { z } from 'zod';

const SALT_ROUNDS = 12;

// Validation schema
const registerSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)  // Enforce minimum length!
});

app.post('/register', async (req, res) => {
  try {
    // 1. Validate input
    const { email, password } = registerSchema.parse(req.body);
    
    // 2. Check if user exists
    const existing = await db.getUserByEmail(email);
    if (existing) {
      return res.status(400).json({ error: 'Email already registered' });
    }
    
    // 3. Hash password
    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
    
    // 4. Create user (store ONLY the hash!)
    const user = await db.createUser({
      email,
      passwordHash  // Never store password!
    });
    
    // 5. Return success (don't expose hash)
    res.status(201).json({
      message: 'User created',
      userId: user.id
    });
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: error.errors });
    }
    console.error(error);
    res.status(500).json({ error: 'Server error' });
  }
});
```

## Password Security Best Practices

### 1. Enforce Strong Passwords

```javascript
const passwordSchema = z.string()
  .min(12, 'Password must be at least 12 characters')
  .regex(/[A-Z]/, 'Must contain uppercase')
  .regex(/[a-z]/, 'Must contain lowercase')
  .regex(/[0-9]/, 'Must contain number')
  .regex(/[^A-Za-z0-9]/, 'Must contain special character');
```

### 2. Use Appropriate Cost Factor

```javascript
// Test timing on your server
const SALT_ROUNDS = 12;  // ~250-300ms is good

// Benchmark
console.time('hash');
await bcrypt.hash('test', 12);
console.timeEnd('hash');
```

### 3. Rate Limit Auth Endpoints

```javascript
import rateLimit from 'express-rate-limit';

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,  // 15 minutes
  max: 5,  // 5 attempts per window
  message: 'Too many attempts'
});

app.post('/login', authLimiter, async (req, res) => {
  // ...
});
```

### 4. Don't Reveal Which Field Failed

```javascript
// BAD - reveals user exists
if (!user) return res.status(401).json({ error: 'User not found' });
if (!valid) return res.status(401).json({ error: 'Wrong password' });

// GOOD - generic error
if (!user || !valid) {
  return res.status(401).json({ error: 'Invalid credentials' });
}
```

## Alternative: Argon2

Argon2 is the winner of the Password Hashing Competition (2015) and is considered more secure than bcrypt:

```bash
npm install argon2
```

```javascript
import argon2 from 'argon2';

// Hash
const hash = await argon2.hash(password);

// Verify
const isValid = await argon2.verify(hash, password);
```

**When to use Argon2:**
- New projects (recommended)
- High security requirements
- When you want memory-hard hashing

**When to stick with bcrypt:**
- Existing projects (migration effort)
- Need maximum compatibility
- Argon2 not available in your environment

## Quick Reference

```bash
# Installation
npm install bcrypt
```

```javascript
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 12;

// Hash password
const hash = await bcrypt.hash(password, SALT_ROUNDS);

// Verify password
const isValid = await bcrypt.compare(password, hash);
```

**Remember:**
- ✅ Always hash passwords before storing
- ✅ Use bcrypt or Argon2 (not MD5/SHA1)
- ✅ Salt is automatic with bcrypt
- ✅ Use cost factor 10-12
- ✅ Enforce strong password policies
- ✅ Rate limit auth attempts
- ❌ Never store plain text passwords
- ❌ Never log passwords
- ❌ Don't return hash to client