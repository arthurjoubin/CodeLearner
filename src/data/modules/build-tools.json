{
  "module": {
    "id": "build-tools",
    "title": "Build Tools: Vite and Bundlers",
    "description": "Understand bundling and use Vite for modern development",
    "icon": "Hammer",
    "requiredXp": 400,
    "color": "from-purple-500 to-violet-600",
    "courseId": "internet-tools"
  },
  "lessons": [
    {
      "id": "what-are-build-tools",
      "moduleId": "build-tools",
      "title": "What Are Build Tools?",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Build tools transform modern code into browser-compatible code\n- Bundling combines multiple files into optimized bundles\n- Transpiling converts TypeScript/JSX to JavaScript\n- Minification removes whitespace and shortens variable names\n- Browsers need this because they don't understand modern syntax natively\n\n---\n\n# What Are Build Tools?\n\n## The Problem: Modern JavaScript vs Browser Reality\n\nAs a developer, you write modern code:\n\n```typescript\n// TypeScript with JSX\nimport { useState } from 'react';\nimport { Button } from './components/Button';\nimport './styles.css';\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  return <Button onClick={() => setCount(c => c + 1)} />;\n};\n```\n\n**But browsers can't run this directly!** They don't understand:\n- TypeScript types\n- JSX syntax (`<Button />`)\n- ES modules imports (`import/export`)\n- Modern JavaScript features (optional chaining, nullish coalescing)\n\n## What Build Tools Do\n\nBuild tools bridge the gap between your code and what browsers can execute.\n\n### 1. Bundling\n\nCombine hundreds of separate files into one (or few) optimized files.\n\n```\nInput: 200+ files\n  - src/main.ts\n  - src/components/*.tsx\n  - src/utils/*.ts\n  - node_modules/react/...\n  - node_modules/lodash/...\n         ↓\nOutput: bundle.js (single optimized file)\n```\n\n**Why bundle?**\n- Reduce HTTP requests (faster loading)\n- Resolve module dependencies\n- Enable code splitting and lazy loading\n\n### 2. Transpiling\n\nConvert modern/modern-syntax code to browser-compatible JavaScript.\n\n```typescript\n// Your TypeScript code\nconst greeting: string = 'Hello';\nconst result = data?.value ?? 'default';\n```\n\n```javascript\n// After transpilation (ES5 compatible)\nvar greeting = 'Hello';\nvar result = data != null && data.value !== void 0 ? data.value : 'default';\n```\n\n### 3. Minification\n\nRemove unnecessary characters and optimize code size.\n\n```javascript\n// Before minification\nfunction calculateSum(a, b) {\n  const result = a + b;\n  return result;\n}\n\n// After minification\nfunction c(a,b){return a+b}\n```\n\nBenefits:\n- Smaller file sizes (often 60-80% smaller)\n- Faster downloads\n- Reduced bandwidth costs\n\n### 4. Tree Shaking\n\nRemove unused code automatically.\n\n```javascript\n// You import only what you need\nimport { debounce } from 'lodash-es';\n\n// Tree shaking removes everything else from lodash\n// Only debounce and its dependencies are included\n```\n\n## Why Browsers Need This\n\n| Feature | Your Code | Browser Support | Build Tool Solution |\n|---------|-----------|----------------|---------------------|\n| TypeScript | `const x: number` | ❌ No | Transpile to JS |\n| JSX | `<Component />` | ❌ No | Transform to `React.createElement` |\n| ES Modules | `import/export` | ⚠️ Partial | Bundle to single file |\n| CSS Imports | `import './style.css'` | ❌ No | Inject or extract CSS |\n| Modern JS | `??`, `?.` | ⚠️ Older browsers | Transpile to ES5 |\n| npm packages | `node_modules` | ❌ No | Resolve and bundle |\n\n## The Build Process Flow\n\n```\n┌─────────────────┐\n│  Source Code    │  TypeScript, JSX, modern JS\n│  (src/)         │\n└────────┬────────┘\n         │\n         ▼\n┌─────────────────┐\n│   Transpile     │  Remove types, transform JSX\n└────────┬────────┘\n         │\n         ▼\n┌─────────────────┐\n│    Bundle       │  Resolve imports, combine files\n└────────┬────────┘\n         │\n         ▼\n┌─────────────────┐\n│  Tree Shake     │  Remove unused code\n└────────┬────────┘\n         │\n         ▼\n┌─────────────────┐\n│   Minify        │  Compress code\n└────────┬────────┘\n         │\n         ▼\n┌─────────────────┐\n│   Output        │  Production-ready files\n│   (dist/)       │\n└─────────────────┘\n```\n\n## Common Build Tools\n\n| Tool | Type | Best For | Learning Curve |\n|------|------|----------|----------------|\n| Vite | Bundler | Modern web apps | ⭐ Easy |\n| Webpack | Bundler | Complex configurations | ⭐⭐⭐ Hard |\n| Rollup | Bundler | Libraries | ⭐⭐ Medium |\n| Parcel | Bundler | Zero-config projects | ⭐ Easy |\n| TypeScript | Transpiler | Type checking | ⭐⭐ Medium |\n| Babel | Transpiler | Custom transformations | ⭐⭐ Medium |\n| esbuild | Transpiler/Bundler | Speed | ⭐ Easy |\n\n## Summary\n\nBuild tools are essential because:\n1. They translate modern code into browser-compatible code\n2. They optimize performance through bundling and minification\n3. They enable use of modern development features\n4. They manage complex dependency trees\n\nWithout build tools, you'd need to write raw ES5 JavaScript, manage all dependencies manually, and deliver unoptimized code to users.",
      "codeExample": "// Example of code that NEEDS build tools\n// This won't work in a browser without transformation\n\n// TypeScript - types must be removed\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n\n// JSX - must be transformed to JavaScript\nconst Button = ({ onClick, children }) => (\n  <button onClick={onClick} className=\"btn\">\n    {children}\n  </button>\n);\n\n// ES Modules - must be bundled\nimport { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport './styles.css';\n\n// Modern syntax - may need transpilation\nconst data = response?.data ?? [];\nconst userName = user?.profile?.name ?? 'Anonymous';"
    },
    {
      "id": "vite-fundamentals",
      "moduleId": "build-tools",
      "title": "Vite Fundamentals",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Vite is a modern build tool with instant dev server startup\n- Configuration is done in vite.config.ts (or .js/.mjs)\n- HMR (Hot Module Replacement) updates code without page refresh\n- Plugins extend Vite's functionality (React, Vue, etc.)\n- Vite uses esbuild for dev and Rollup for production builds\n\n---\n\n# Vite Fundamentals\n\n## Why Vite?\n\nVite (French for \"fast\") was created by Evan You (creator of Vue.js) to solve the slowness of traditional bundlers.\n\n**Traditional bundlers (Webpack, etc.):**\n- Bundle everything on startup\n- Slow dev server launch (30+ seconds on large projects)\n- Slower HMR as project grows\n\n**Vite's approach:**\n- No bundling in development (uses native ES modules)\n- Instant server start (regardless of project size)\n- Lightning-fast HMR\n- Optimized production builds with Rollup\n\n## Getting Started with Vite\n\n```bash\n# Create a new Vite project\nnpm create vite@latest my-app\n\n# Choose your framework\n# - Vanilla\n# - Vue\n# - React\n# - Preact\n# - Lit\n# - Svelte\n# - Solid\n# - Qwik\n\ncd my-app\nnpm install\nnpm run dev\n```\n\n## Project Structure\n\n```\nmy-app/\n├── index.html          # Entry point (Vite-specific!)\n├── vite.config.ts      # Vite configuration\n├── package.json\n├── public/             # Static assets (copied as-is)\n│   └── favicon.ico\n└── src/\n    ├── main.tsx       # Application entry\n    ├── App.tsx\n    └── assets/        # Processed assets (imported in code)\n        └── logo.svg\n```\n\n**Important:** Vite uses `index.html` as the entry point, not a JS file!\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <!-- Vite handles this import -->\n    <script type=\"module\" src=\"/src/main.tsx\"></script>\n  </body>\n</html>\n```\n\n## vite.config.ts - Configuration File\n\nThe configuration file is where you customize Vite's behavior.\n\n### Basic Configuration\n\n```typescript\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  // Your configuration here\n});\n```\n\n### Common Configuration Options\n\n```typescript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  // Plugins\n  plugins: [react()],\n  \n  // Development server options\n  server: {\n    port: 3000,          // Dev server port (default: 5173)\n    open: true,          // Auto-open browser\n    host: true,          // Allow external access\n    strictPort: true,    // Exit if port is in use\n    proxy: {             // Proxy API requests\n      '/api': {\n        target: 'http://localhost:8080',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, '')\n      }\n    }\n  },\n  \n  // Build options\n  build: {\n    outDir: 'dist',           // Output directory\n    sourcemap: true,          // Generate source maps\n    minify: 'terser',         // Minifier (terser/esbuild)\n    target: 'es2015',         // JavaScript target\n    assetsInlineLimit: 4096,  // Inline assets < 4kb\n    rollupOptions: {          // Rollup-specific options\n      output: {\n        manualChunks: {       // Code splitting\n          vendor: ['react', 'react-dom']\n        }\n      }\n    }\n  },\n  \n  // Path resolution\n  resolve: {\n    alias: {\n      '@': '/src',           // Import alias\n      '@components': '/src/components',\n      '@utils': '/src/utils'\n    }\n  },\n  \n  // CSS options\n  css: {\n    devSourcemap: true,\n    preprocessorOptions: {\n      scss: {\n        additionalData: `@import \"./src/styles/variables.scss\";`\n      }\n    }\n  },\n  \n  // Environment variables\n  envPrefix: 'VITE_',       // Only expose env vars starting with VITE_\n  \n  // Preview server (for testing production build)\n  preview: {\n    port: 4173\n  }\n});\n```\n\n## The Dev Server\n\n### Starting the Dev Server\n\n```bash\nnpm run dev\n# or\nnpx vite\n```\n\nThis starts a development server with:\n- Instant cold start\n- On-demand compilation\n- Hot Module Replacement\n- Source maps for debugging\n\n### Dev Server Features\n\n**Import Handling:**\n```typescript\n// Vite handles these automatically\nimport './style.css';           // CSS injection\nimport logo from './logo.svg'; // Asset handling\nimport json from './data.json'; // JSON import\n```\n\n**Environment Variables:**\n```typescript\n// .env file\nVITE_API_URL=https://api.example.com\nSECRET_KEY=hidden  // Not exposed!\n\n// In code\nconsole.log(import.meta.env.VITE_API_URL);  // ✅ Works\nconsole.log(import.meta.env.SECRET_KEY);    // ❌ Undefined\n```\n\n## Hot Module Replacement (HMR)\n\nHMR allows you to update code without losing application state or refreshing the page.\n\n### How HMR Works\n\n```\n┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n│   Update    │────▶│   Server    │────▶│   Browser   │\n│   File      │     │   detects   │     │   updates   │\n│             │     │   change    │     │   module    │\n└─────────────┘     └─────────────┘     └─────────────┘\n                                              │\n                                              ▼\n                                       ┌─────────────┐\n                                       │   App       │\n                                       │   keeps     │\n                                       │   state!    │\n                                       └─────────────┘\n```\n\n### Example: React with HMR\n\n```typescript\n// App.tsx\nimport { useState } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(c => c + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n**Without HMR:** Change code → Page refreshes → Count resets to 0\n\n**With HMR:** Change code → Component updates → Count stays the same!\n\n### HMR API (Advanced)\n\n```typescript\n// For custom HMR handling\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    // Handle module update\n    console.log('Module updated');\n  });\n  \n  import.meta.hot.dispose(() => {\n    // Cleanup before module is replaced\n    console.log('Cleaning up...');\n  });\n}\n```\n\n## Vite Plugins\n\nPlugins extend Vite's functionality. They hook into the build process.\n\n### Official Plugins\n\n```typescript\n// React\nimport react from '@vitejs/plugin-react';\n\n// Vue\nimport vue from '@vitejs/plugin-vue';\n\n// Vue with JSX\nimport vueJsx from '@vitejs/plugin-vue-jsx';\n\n// Svelte\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\n```\n\n### Popular Community Plugins\n\n```typescript\n// TypeScript path resolution\nimport tsconfigPaths from 'vite-tsconfig-paths';\n\n// PWA support\nimport { VitePWA } from 'vite-plugin-pwa';\n\n// SVG as React components\nimport svgr from 'vite-plugin-svgr';\n\n// Visualize bundle size\nimport { visualizer } from 'rollup-plugin-visualizer';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    tsconfigPaths(),\n    svgr(),\n    visualizer({\n      open: true,  // Open stats in browser after build\n    })\n  ]\n});\n```\n\n### Creating a Simple Plugin\n\n```typescript\n// vite.config.ts\nconst myPlugin = () => ({\n  name: 'my-plugin',\n  \n  // Transform code\n  transform(code, id) {\n    if (id.endsWith('.txt')) {\n      return `export default ${JSON.stringify(code)}`;\n    }\n  },\n  \n  // Configure server\n  configureServer(server) {\n    server.middlewares.use((req, res, next) => {\n      // Custom middleware\n      next();\n    });\n  }\n});\n\nexport default defineConfig({\n  plugins: [react(), myPlugin()]\n});\n```\n\n## Vite vs Other Tools\n\n| Feature | Vite | Webpack | Create React App |\n|---------|------|---------|------------------|\n| Dev server start | Instant | Slow (bundle first) | Slow |\n| HMR speed | Fast | Slower | Slower |\n| Config required | Minimal | Extensive | None (limited) |\n| Build speed | Fast | Slow | Slow |\n| Modern features | Native | Via plugins | Via eject |\n| Learning curve | Low | High | Low |\n\n## Best Practices\n\n1. **Use TypeScript config**: `vite.config.ts` for type safety\n2. **Set up path aliases**: Use `@/` for cleaner imports\n3. **Configure proxy**: For API requests during development\n4. **Use environment variables**: Prefix with `VITE_` for client access\n5. **Enable source maps**: For easier debugging\n6. **Optimize images**: Place large assets in `public/`, small ones in `src/`\n7. **Use plugins**: Leverage official and community plugins\n\n## Common Commands\n\n```bash\n# Development\nnpm run dev          # Start dev server\n\n# Building\nnpm run build        # Build for production\nnpm run preview      # Preview production build locally\n\n# Other\nnpx vite --host      # Allow external connections\nnpx vite --port 8080 # Use specific port\n```\n\n## Summary\n\nVite provides:\n- **Instant dev server**: No bundling overhead in development\n- **HMR**: Fast updates without losing state\n- **Simple config**: Works out of the box, easy to customize\n- **Optimized builds**: Production-ready with Rollup\n- **Rich ecosystem**: Official and community plugins\n\nIt's the recommended choice for modern web development.",
      "codeExample": "// vite.config.ts - Complete example configuration\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [\n    react({\n      // Fast Refresh is enabled by default\n      include: '**/*.{jsx,tsx}'\n    })\n  ],\n  \n  // Development server configuration\n  server: {\n    port: 3000,\n    open: true,\n    // Proxy API requests to backend\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8080',\n        changeOrigin: true\n      }\n    }\n  },\n  \n  // Build configuration\n  build: {\n    outDir: 'dist',\n    sourcemap: true,\n    // Optimize dependencies\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          'react-vendor': ['react', 'react-dom']\n        }\n      }\n    }\n  },\n  \n  // Path aliases\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src')\n    }\n  },\n  \n  // CSS configuration\n  css: {\n    devSourcemap: true\n  }\n});"
    },
    {
      "id": "dev-vs-production",
      "moduleId": "build-tools",
      "title": "Dev vs Production Builds",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- `npm run dev` starts a development server with HMR and no optimization\n- `npm run build` creates optimized production files\n- Environment modes (development/production) affect behavior\n- Source maps map minified code back to original source for debugging\n- Production builds include minification, tree-shaking, and code splitting\n\n---\n\n# Dev vs Production Builds\n\n## Understanding the Two Modes\n\nModern build tools operate in two distinct modes with very different goals:\n\n| Aspect | Development | Production |\n|--------|-------------|------------|\n| **Goal** | Fast iteration, debugging | Performance, optimization |\n| **Speed** | Instant start | Slower (one-time) |\n| **Bundle** | Unbundled (ES modules) | Optimized bundle |\n| **Code** | Readable, with comments | Minified, compressed |\n| **Source Maps** | Full source maps | May be separate files |\n| **HMR** | ✅ Enabled | ❌ N/A |\n| **Errors** | Detailed, helpful | Minimal, stripped |\n| **Assets** | Unoptimized | Optimized, hashed |\n\n## npm run dev (Development)\n\n### What It Does\n\n```bash\nnpm run dev\n```\n\nStarts a development server that:\n- Serves files on-demand using native ES modules\n- Compiles files only when requested\n- Provides Hot Module Replacement (HMR)\n- Shows detailed error overlays\n- Preserves source code structure for debugging\n\n### Behind the Scenes\n\n```\nBrowser requests: /src/main.tsx\n                    ↓\nVite intercepts request\n                    ↓\nOn-the-fly transforms:\n  - TypeScript → JavaScript\n  - JSX → React.createElement calls\n  - CSS imports → Injected styles\n                    ↓\nBrowser receives ES module\n```\n\n### Development-Specific Features\n\n**1. Hot Module Replacement (HMR)**\n\nUpdates modules without page refresh:\n```\n┌──────────┐     ┌──────────┐     ┌──────────┐\n│ Edit     │────▶│ Vite     │────▶│ Browser  │\n│ file     │     │ detects  │     │ updates  │\n│          │     │ change   │     │ module   │\n└──────────┘     └──────────┘     └────┬─────┘\n                                       │\n                              ┌────────▼────────┐\n                              │ App state       │\n                              │ PRESERVED!      │\n                              └─────────────────┘\n```\n\n**2. Source Maps (Inline)**\n\n```typescript\n// Your code\nfunction calculateTotal(price: number, quantity: number): number {\n  return price * quantity;\n}\n\n// Browser sees (via source map)\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjoz...\n\n// DevTools displays original code with types\n```\n\n**3. Error Overlays**\n\nWhen errors occur, you see:\n- Full stack traces\n- Source code context\n- File names and line numbers\n- Suggested fixes\n\n### Development Limitations\n\n❌ Not optimized (large file sizes)\n❌ No tree-shaking (includes unused code)\n❌ No minification (human-readable but large)\n❌ No code splitting (all code loaded upfront)\n\n## npm run build (Production)\n\n### What It Does\n\n```bash\nnpm run build\n```\n\nCreates an optimized production build:\n```\nsrc/                    dist/\n├── main.tsx           ├── index.html\n├── App.tsx            ├── assets/\n├── components/        │   ├── index-abc123.js    (hashed filename)\n│   └── Button.tsx     │   ├── vendor-def456.js   (code-split chunk)\n├── utils/             │   └── index-xyz789.css   (minified + hashed)\n│   └── helpers.ts     └── ...\n└── styles.css\n```\n\n### Production Optimizations\n\n**1. Minification**\n\n```javascript\n// Development\nfunction calculateTotal(price, quantity) {\n  // Calculate the total price\n  const total = price * quantity;\n  return total;\n}\n\n// Production (minified)\nfunction c(n,r){return n*r}\n```\n\nBenefits:\n- Smaller file sizes (often 60-80% reduction)\n- Faster downloads\n- Reduced bandwidth costs\n\n**2. Tree Shaking**\n\nRemoves unused code:\n```typescript\n// utils.ts\nexport const helper1 = () => { ... };  // Used in App.tsx\nexport const helper2 = () => { ... };  // Not used anywhere\nexport const helper3 = () => { ... };  // Used in Button.tsx\n\n// Production bundle includes only helper1 and helper3\n```\n\n**3. Code Splitting**\n\nSplits code into chunks loaded on demand:\n```\nInitial load: index.js (100KB)\n              ├── Core app code\n              └── React, ReactDOM\n                    \nOn route change: Load dashboard.js (50KB)\nOn user action:  Load chart-library.js (150KB)\n```\n\n**4. Asset Optimization**\n\n- CSS: Minified and extracted to separate files\n- Images: Optimized and converted to modern formats (WebP)\n- Fonts: Subsetted and preloaded\n- Filename hashing: `main.abc123.js` (for cache busting)\n\n**5. Dead Code Elimination**\n\n```typescript\n// Environment-specific code\nif (process.env.NODE_ENV === 'development') {\n  console.log('Debug info:', data);\n  enableDevTools();\n}\n\n// In production build, this entire block is removed!\n```\n\n## Environment Modes\n\n### Mode-Based Configuration\n\nVite provides different modes: `development`, `production`, and custom modes.\n\n```typescript\n// vite.config.ts\nimport { defineConfig } from 'vite';\n\nexport default defineConfig(({ mode }) => {\n  // mode is 'development' or 'production'\n  console.log('Building for mode:', mode);\n  \n  return {\n    plugins: [...],\n    \n    // Conditional configuration\n    build: {\n      sourcemap: mode === 'production' ? 'hidden' : true,\n      minify: mode === 'production',\n    },\n    \n    define: {\n      __APP_VERSION__: JSON.stringify(process.env.npm_package_version),\n      __DEV__: mode === 'development'\n    }\n  };\n});\n```\n\n### Using Modes in Code\n\n```typescript\n// Check current mode\nif (import.meta.env.DEV) {\n  console.log('Development mode');\n  // Enable dev tools, verbose logging\n}\n\nif (import.meta.env.PROD) {\n  console.log('Production mode');\n  // Analytics, error tracking\n}\n\n// Mode-specific imports (advanced)\nconst config = import.meta.env.PROD\n  ? await import('./config.prod.ts')\n  : await import('./config.dev.ts');\n```\n\n### Environment Variables\n\n```\n.env                # Loaded in all modes\n.env.local          # Loaded in all modes (gitignored)\n.env.[mode]         # Loaded only in specific mode\n.env.[mode].local   # Loaded only in specific mode (gitignored)\n```\n\nExample files:\n```bash\n# .env\nVITE_APP_NAME=MyApp\nVITE_API_URL=/api\n\n# .env.development\nVITE_API_URL=http://localhost:8080\nVITE_DEBUG=true\n\n# .env.production\nVITE_API_URL=https://api.myapp.com\nVITE_DEBUG=false\n```\n\n```typescript\n// In your code\nconst apiUrl = import.meta.env.VITE_API_URL;\nconst isDebug = import.meta.env.VITE_DEBUG === 'true';\n```\n\n## Source Maps\n\n### What Are Source Maps?\n\nSource maps bridge the gap between minified production code and original source code.\n\n```\n┌─────────────────┐              ┌─────────────────┐\n│  Minified Code  │◄─────────────│  Original Code  │\n│  (production)   │  Source Map  │  (TypeScript)   │\n└─────────────────┘              └─────────────────┘\n        │                                │\n        │     Errors point here          │\n        └────────────────────────────────┘\n```\n\n### Source Map Types\n\n| Type | Description | Use Case |\n|------|-------------|----------|\n| `true` | Separate .js.map file | Production with debugging |\n| `inline` | Base64-encoded in file | Development |\n| `hidden` | Separate file, no comment | Production (debug only) |\n| `false` | No source maps | Maximum security |\n\n### Configuring Source Maps\n\n```typescript\n// vite.config.ts\nexport default defineConfig({\n  build: {\n    // Development\n    sourcemap: true,        // Separate .map files\n    \n    // Or for production with debugging\n    sourcemap: 'hidden',    // Separate files, no comment in JS\n    \n    // Or disable completely\n    sourcemap: false,       // Smallest files, no debugging\n  }\n});\n```\n\n### Using Source Maps\n\n**In Development:**\n```\n1. Open DevTools\n2. Sources tab shows original TypeScript files\n3. Set breakpoints in .ts/.tsx files\n4. Errors show original file:line\n```\n\n**In Production:**\n```\n1. Deploy .map files alongside JS files\n2. Error tracking services (Sentry, etc.) use maps\n3. DevTools can load maps if available\n4. Users never download maps unless DevTools is open\n```\n\n## Build Output Analysis\n\n### Viewing Bundle Size\n\n```bash\n# Install visualizer\nnpm install -D rollup-plugin-visualizer\n\n# vite.config.ts\nimport { visualizer } from 'rollup-plugin-visualizer';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    visualizer({\n      open: true,        // Auto-open in browser\n      gzipSize: true,    // Show gzipped sizes\n      brotliSize: true,  // Show brotli sizes\n    })\n  ]\n});\n```\n\nThis generates an interactive visualization showing:\n- Which dependencies take the most space\n- How code is split across chunks\n- Opportunities for optimization\n\n### Previewing Production Build\n\n```bash\nnpm run build      # Create production build\nnpm run preview    # Serve dist/ folder locally\n```\n\nThis lets you test the production build before deploying.\n\n## Comparing File Sizes\n\n| File Type | Development | Production | Savings |\n|-----------|-------------|------------|---------|\n| JavaScript | 500 KB | 120 KB | 76% |\n| CSS | 50 KB | 8 KB | 84% |\n| Total | 550 KB | 128 KB | 77% |\n\n*Note: With gzip compression, production files are even smaller (~40 KB)*\n\n## Best Practices\n\n1. **Always test production build before deploying**\n   ```bash\n   npm run build && npm run preview\n   ```\n\n2. **Use environment variables for configuration**\n   - API endpoints\n   - Feature flags\n   - Analytics IDs\n\n3. **Configure source maps appropriately**\n   - Development: `true` (inline or separate)\n   - Production: `'hidden'` or `false`\n\n4. **Analyze bundle size regularly**\n   - Identify large dependencies\n   - Consider code splitting\n   - Remove unused code\n\n5. **Enable gzip/brotli compression on your server**\n   - Reduces transfer size by 60-80%\n\n6. **Use filename hashing for cache busting**\n   - Vite does this automatically in production\n   - `main.a3f2b1c.js` → changes when content changes\n\n## Troubleshooting Build Issues\n\n**Build fails with memory error:**\n```bash\n# Increase Node.js memory\nnode --max-old-space-size=4096 node_modules/.bin/vite build\n```\n\n**Build is too slow:**\n- Check for circular dependencies\n- Reduce large static imports\n- Use dynamic imports for heavy components\n\n**Output is too large:**\n- Enable tree shaking\n- Analyze with visualizer\n- Check for duplicate dependencies\n\n## Summary\n\n| Command | Use When | Key Features |\n|---------|----------|--------------|\n| `npm run dev` | Developing | Fast HMR, source maps, debugging |\n| `npm run build` | Deploying | Optimized, minified, tree-shaken |\n| `npm run preview` | Testing production | Verify before deploy |\n\nUnderstanding these modes is crucial for efficient development and optimal production performance.",
      "codeExample": "// Example: Mode-specific code in vite.config.ts\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig(({ mode }) => ({\n  plugins: [react()],\n  \n  build: {\n    // Production: hidden source maps for debugging\n    // Development: inline source maps\n    sourcemap: mode === 'production' ? 'hidden' : true,\n    \n    // Production: enable minification\n    // Development: skip for faster builds\n    minify: mode === 'production' ? 'terser' : false,\n    \n    // Production: optimize chunks\n    rollupOptions: mode === 'production' ? {\n      output: {\n        manualChunks: {\n          vendor: ['react', 'react-dom'],\n          ui: ['@radix-ui/react-dialog', '@radix-ui/react-dropdown-menu']\n        }\n      }\n    } : undefined\n  },\n  \n  // Environment variables available in app\n  define: {\n    __APP_VERSION__: JSON.stringify(process.env.npm_package_version),\n    __BUILD_TIME__: JSON.stringify(new Date().toISOString()),\n    __DEV__: mode === 'development'\n  }\n}));\n\n// Using in your code\nif (import.meta.env.DEV) {\n  console.log('Development build');\n  console.log('Build time:', __BUILD_TIME__);\n}\n\nif (import.meta.env.PROD) {\n  console.log('Production build v' + __APP_VERSION__);\n}"
    },
    {
      "id": "common-build-errors",
      "moduleId": "build-tools",
      "title": "Common Build Errors",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- \"Cannot resolve module\" means the import path is incorrect or package is missing\n- TypeScript errors block builds unless configured otherwise\n- Environment variables must start with `VITE_` to be accessible in browser code\n- Understanding error messages helps debug build issues quickly\n- Most errors have straightforward solutions once you know the pattern\n\n---\n\n# Common Build Errors\n\nBuild errors can be frustrating, but they follow predictable patterns. Learning to read and fix these errors will save you hours of debugging.\n\n## Error Categories\n\nBuild errors typically fall into these categories:\n\n1. **Module Resolution Errors** - Can't find imported files/packages\n2. **TypeScript Errors** - Type checking failures\n3. **Environment Variable Errors** - Missing or inaccessible env vars\n4. **Syntax/Compilation Errors** - Invalid JavaScript/TypeScript\n5. **Configuration Errors** - Wrong vite.config.ts setup\n\n## 1. \"Cannot Resolve Module\" Errors\n\n### The Error\n\n```\n[vite]: Rollup failed to resolve import \"@/components/Button\" from \"/src/App.tsx\".\nDoes the file exist?\n\nError: Cannot find module '@components/utils'\n```\n\n### Causes and Solutions\n\n**A. Missing Package Installation**\n\n```\nError: Cannot find module 'axios'\n```\n\n```bash\n# Solution\nnpm install axios\n# or\nyarn add axios\n```\n\n**B. Incorrect Import Path**\n\n```typescript\n// ❌ Wrong path\nimport Button from './components/Button';\nimport { helper } from '../utils';\n\n// ✅ Correct path\nimport Button from '@/components/Button';  // If using alias\nimport { helper } from '@/utils/helpers'; // Full path\n```\n\n**C. Missing File Extension**\n\n```typescript\n// ❌ Missing extension (sometimes required)\nimport Component from './Component';\n\n// ✅ With extension\nimport Component from './Component.tsx';\n```\n\n**D. Path Alias Not Configured**\n\n```typescript\n// You want to use:\nimport Button from '@/components/Button';\n\n// But get: Cannot find module '@/components/Button'\n```\n\n```typescript\n// vite.config.ts - Fix this\nimport { defineConfig } from 'vite';\nimport path from 'path';\n\nexport default defineConfig({\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n      '@components': path.resolve(__dirname, './src/components'),\n      '@utils': path.resolve(__dirname, './src/utils')\n    }\n  }\n});\n```\n\n**E. Case Sensitivity Issues**\n\n```typescript\n// ❌ Wrong case (works on Windows/Mac, fails on Linux)\nimport Button from './button';  // file is Button.tsx\n\n// ✅ Correct case\nimport Button from './Button';\n```\n\n**F. Circular Dependencies**\n\n```typescript\n// File A.ts\nimport { b } from './B';\nexport const a = () => b();\n\n// File B.ts\nimport { a } from './A';  // Circular!\nexport const b = () => a();\n```\n\n```\nError: Cannot access 'a' before initialization\n```\n\n```typescript\n// Solution: Break the circle\n// Move shared code to C.ts\n// File C.ts\nexport const shared = () => { ... };\n\n// File A.ts\nimport { shared } from './C';\nexport const a = () => shared();\n\n// File B.ts\nimport { shared } from './C';\nexport const b = () => shared();\n```\n\n## 2. TypeScript Errors\n\n### Type Checking Failures\n\n```\nsrc/App.tsx:15:23 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.\n\n15   calculateTotal('100', 5);\n                         ~~~\n```\n\n### Common TypeScript Build Errors\n\n**A. Type Mismatch**\n\n```typescript\n// ❌ Type error\nfunction greet(name: string): string {\n  return `Hello ${name}`;\n}\n\ngreet(123);  // Error: Argument of type 'number' not assignable to 'string'\n\n// ✅ Fix\ngreet('Alice');\n```\n\n**B. Missing Properties**\n\n```typescript\ninterface User {\n  name: string;\n  email: string;\n}\n\n// ❌ Missing required property\nconst user: User = { name: 'John' };\n\n// ✅ All required properties\nconst user: User = { name: 'John', email: 'john@example.com' };\n\n// Or make it optional\ninterface User {\n  name: string;\n  email?: string;  // Optional\n}\n```\n\n**C. Cannot Find Module/Type**\n\n```\nerror TS2307: Cannot find module './types' or its corresponding type declarations.\n```\n\n```bash\n# Install missing types\nnpm install -D @types/node @types/react\n```\n\n**D. Implicit Any**\n\n```\nerror TS7006: Parameter 'x' implicitly has an 'any' type.\n```\n\n```typescript\n// ❌ Implicit any\nfunction process(x) {  // Error: x has implicit any\n  return x * 2;\n}\n\n// ✅ Explicit type\nfunction process(x: number): number {\n  return x * 2;\n}\n\n// Or add types in tsconfig.json for migration\n// \"noImplicitAny\": false  // Not recommended long-term\n```\n\n**E. Null/Undefined Checks**\n\n```\nerror TS2532: Object is possibly 'undefined'.\n```\n\n```typescript\nconst user = users.find(u => u.id === 1);\n\n// ❌ Unsafe access\nconsole.log(user.name);  // Error: user might be undefined\n\n// ✅ Safe access\nconsole.log(user?.name);  // Optional chaining\n\n// Or check first\nif (user) {\n  console.log(user.name);\n}\n```\n\n### Allowing Builds with Type Errors\n\n```typescript\n// vite.config.ts\nexport default defineConfig({\n  build: {\n    // Allow production builds with type errors\n    // ⚠️ Use with caution!\n  }\n});\n\n// Better: configure tsconfig.json\n{\n  \"compilerOptions\": {\n    \"noEmitOnError\": false,  // Don't block emit on errors\n    \"skipLibCheck\": true     // Skip type checking of declaration files\n  }\n}\n```\n\n## 3. Environment Variable Errors\n\n### Variables Not Loading\n\n**A. Missing VITE_ Prefix**\n\n```bash\n# ❌ Won't work in browser\nAPI_URL=https://api.example.com\nSECRET_KEY=abc123\n\n# ✅ Correct\nVITE_API_URL=https://api.example.com\n# SECRET_KEY is still available in Node.js, not browser\n```\n\n```typescript\n// ❌ Returns undefined\nconst url = import.meta.env.API_URL;\n\n// ✅ Works!\nconst url = import.meta.env.VITE_API_URL;\n```\n\n**B. Using process.env Instead of import.meta.env**\n\n```typescript\n// ❌ Old Create React App syntax\nconst apiUrl = process.env.REACT_APP_API_URL;\n\n// ✅ Vite syntax\nconst apiUrl = import.meta.env.VITE_API_URL;\n```\n\n**C. Environment File Not Loaded**\n\n```\n.env file exists but variables are undefined\n```\n\n```bash\n# Check file location\n# Must be in project root, not src/\n\n# Wrong:\nsrc/.env\n\n# Correct:\n.env\n.env.local\n.env.development\n```\n\n**D. TypeScript Doesn't Recognize Env Vars**\n\n```typescript\n// Error: Property 'VITE_API_URL' does not exist on type...\nconst url = import.meta.env.VITE_API_URL;\n```\n\n```typescript\n// src/vite-env.d.ts\n/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_API_URL: string\n  readonly VITE_APP_NAME: string\n  // more env variables...\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n```\n\n## 4. Syntax and Compilation Errors\n\n**A. JSX Not Transformed**\n\n```\n[vite] Internal server error: Unexpected token\n```\n\n```typescript\n// ❌ File not recognized as JSX\n// Component.ts\nconst App = () => <div>Hello</div>;\n\n// ✅ Correct extension\n// Component.tsx\nconst App = () => <div>Hello</div>;\n```\n\n**B. Top-Level await**\n\n```typescript\n// ❌ Syntax error in older targets\nconst data = await fetch('/api/data');\n\n// ✅ Configure target in vite.config.ts\nexport default defineConfig({\n  build: {\n    target: 'esnext'  // or 'es2022'\n  }\n});\n```\n\n**C. Importing Non-JS Files Incorrectly**\n\n```typescript\n// ❌ Won't work\nimport './styles.scss';  // Without preprocessor\n\n// ✅ Install preprocessor first\nnpm install -D sass\n\n// Now it works!\n```\n\n## 5. Configuration Errors\n\n**A. Invalid vite.config.ts**\n\n```\nfailed to load config from /project/vite.config.ts\nError: Cannot find module '@vitejs/plugin-react'\n```\n\n```bash\n# Solution\nnpm install -D @vitejs/plugin-react\n```\n\n**B. Plugin Configuration Error**\n\n```typescript\n// ❌ Wrong\nexport default defineConfig({\n  plugins: react  // Missing function call\n});\n\n// ✅ Correct\nexport default defineConfig({\n  plugins: [react()]  // Call the function\n});\n```\n\n**C. Proxy Configuration Issues**\n\n```typescript\n// ❌ Proxy not working\nexport default defineConfig({\n  server: {\n    proxy: {\n      '/api': 'http://localhost:3000'  // Too simple\n    }\n  }\n});\n\n// ✅ Full configuration\nexport default defineConfig({\n  server: {\n    proxy: {\n      '/api': {\n        target: 'http://localhost:3000',\n        changeOrigin: true,  // Required for virtual hosted sites\n        rewrite: (path) => path.replace(/^\\/api/, '')\n      }\n    }\n  }\n});\n```\n\n## 6. Build Output Errors\n\n**A. Blank Page After Build**\n\n```\nBuild succeeds but deployed site shows blank page\n```\n\n```typescript\n// Check vite.config.ts\nexport default defineConfig({\n  build: {\n    outDir: 'dist'\n  },\n  base: './',  // Use relative paths\n  // Or for specific domain:\n  // base: '/my-app/',\n});\n```\n\n**B. Assets Not Loading**\n\n```\n404 errors for images, fonts, or other assets\n```\n\n```typescript\n// ❌ Wrong path in production\n<img src=\"./src/assets/logo.png\" />\n\n// ✅ Import asset\nimport logoUrl from './assets/logo.png';\n<img src={logoUrl} />\n\n// ✅ Or use / for public folder\n<img src=\"/logo.png\" />  // file in public/logo.png\n```\n\n## Debugging Strategies\n\n### 1. Read Error Messages Carefully\n\n```\n[vite] Internal server error: Cannot read properties of undefined (reading 'map')\n  at /src/utils/helpers.ts:42:15\n```\n\nKey info:\n- File: `helpers.ts`\n- Line: `42`\n- Column: `15`\n- Operation: `.map()` on undefined\n\n### 2. Check File Paths and Names\n\n```bash\n# Case sensitivity matters\nls -la src/components/\n# Button.tsx (not button.tsx)\n```\n\n### 3. Clear Cache and Restart\n\n```bash\nrm -rf node_modules/.vite\nnpm run dev\n```\n\n### 4. Update Dependencies\n\n```bash\nnpm update\n# Or specific package\nnpm install vite@latest\n```\n\n### 5. Check TypeScript Strictness\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,        // Enable all strict checks\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true\n  }\n}\n```\n\n### 6. Use IDE IntelliSense\n\n- Hover over imports to see resolved paths\n- Check for red squiggly lines\n- Use \"Go to Definition\" (F12) to verify imports\n\n## Quick Reference: Error Patterns\n\n| Error Message | Likely Cause | Solution |\n|---------------|--------------|----------|\n| `Cannot resolve module` | Wrong path/missing package | Check import, install package |\n| `Cannot find module '@/...'` | Alias not configured | Update vite.config.ts |\n| `Type 'X' is not assignable` | Type mismatch | Fix types or use `any` (temp) |\n| `Object is possibly 'undefined'` | Missing null check | Use optional chaining `?.` |\n| `env.X is undefined` | Missing `VITE_` prefix | Rename env variable |\n| `Unexpected token '<'` | JSX in .ts file | Rename to .tsx |\n| `Cannot find name 'X'` | Missing import or types | Import or install @types |\n| `Circular dependency` | Files import each other | Refactor shared code |\n\n## Prevention Tips\n\n1. **Use TypeScript strict mode** - Catch errors early\n2. **Configure path aliases** - Consistent imports\n3. **Install types for all packages** - `npm install -D @types/package`\n4. **Use consistent naming** - Case-sensitive file systems\n5. **Check env vars** - Always use `VITE_` prefix\n6. **Test builds locally** - `npm run build && npm run preview`\n7. **Use linting** - ESLint catches many errors\n8. **Version control** - Check what changed when errors appear\n\n## Summary\n\nMost build errors fall into predictable patterns:\n- **Imports**: Wrong paths, missing files, circular dependencies\n- **Types**: Mismatches, missing properties, implicit any\n- **Config**: Missing plugins, incorrect settings\n- **Env vars**: Wrong prefix, wrong syntax\n\nLearning to recognize these patterns will make you a faster debugger and more productive developer.",
      "codeExample": "// Example: Common patterns that cause build errors\n\n// ❌ ERROR 1: Missing VITE_ prefix\n// .env file\nAPI_URL=https://api.example.com  // Won't work!\n\n// Your code\nconst url = import.meta.env.API_URL;  // undefined\n\n// ✅ FIX:\n// .env file\nVITE_API_URL=https://api.example.com\n\n// Your code\nconst url = import.meta.env.VITE_API_URL;  // Works!\n\n// ❌ ERROR 2: Wrong file extension for JSX\n// App.ts\nconst Component = () => <div>Hello</div>;  // Syntax error!\n\n// ✅ FIX:\n// Rename to App.tsx\n\n// ❌ ERROR 3: Missing type declaration\n// Using a library without types\nimport moment from 'moment';  // Error: Could not find declaration\n\n// ✅ FIX:\n// npm install -D @types/moment\n// Or create src/types/moment.d.ts\ndeclare module 'moment';\n\n// ❌ ERROR 4: Import path case sensitivity\n// Windows/Mac works, Linux fails\nimport Button from './button';  // Actual file: Button.tsx\n\n// ✅ FIX:\nimport Button from './Button';  // Match exact case\n\n// ❌ ERROR 5: Circular dependency\n// A.ts\nimport { b } from './B';\nexport const a = () => b();\n\n// B.ts\nimport { a } from './A';  // Circular!\nexport const b = () => a();\n\n// ✅ FIX: Extract shared code to C.ts"
    }
  ],
  "exercises": []
}