{
  "module": {
    "id": "fullstack-frameworks",
    "title": "Fullstack Frameworks",
    "description": "Master Next.js, Remix, SvelteKit and rendering strategies",
    "icon": "Zap",
    "requiredXp": 600,
    "color": "from-indigo-400 to-indigo-600",
    "courseId": "advanced-topics"
  },
  "lessons": [
    {
      "id": "rendering-strategies",
      "moduleId": "fullstack-frameworks",
      "title": "SSR vs CSR vs SSG Explained",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- CSR = Client-Side Rendering (React SPA)\n- SSR = Server-Side Rendering (HTML generated per request)\n- SSG = Static Site Generation (HTML generated at build time)\n- Each has trade-offs for performance, SEO, and complexity\n\n---\n\n# Rendering Strategies: How Pages Get Built\n\n## The Three Main Strategies\n\n### 1. CSR (Client-Side Rendering)\n\n**How it works:**\n```\nBrowser ‚Üí Server ‚Üí Empty HTML + JavaScript bundle\n         ‚Üì\n    JavaScript runs ‚Üí Fetches data ‚Üí Renders page\n```\n\n**Example (Traditional React):**\n```html\n<!-- Server sends this -->\n<html>\n  <body>\n    <div id=\"root\"></div>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n\n<!-- JavaScript renders everything -->\n```\n\n**Pros:**\n- ‚úÖ Fast navigation after initial load\n- ‚úÖ Rich interactivity\n- ‚úÖ Less server load\n- ‚úÖ Works offline (with service worker)\n\n**Cons:**\n- ‚ùå Slow initial load (large JS bundle)\n- ‚ùå Poor SEO (content not in HTML)\n- ‚ùå Blank screen while loading\n- ‚ùå JavaScript required\n\n**Best for:**\n- Dashboards\n- Admin panels\n- Apps behind login\n- Tools (calculators, editors)\n\n### 2. SSR (Server-Side Rendering)\n\n**How it works:**\n```\nBrowser ‚Üí Server ‚Üí Generates HTML (with data)\n         ‚Üì\n    Returns full HTML ‚Üí Browser displays ‚Üí JavaScript hydrates\n```\n\n**Example (Next.js):**\n```jsx\n// This runs on the server for each request\nexport async function getServerSideProps() {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n  \n  return { props: { data } };\n}\n\nfunction Page({ data }) {\n  return <div>{data.title}</div>;\n}\n```\n\n**Server returns:**\n```html\n<html>\n  <body>\n    <div>Actual Content Here</div>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n```\n\n**Pros:**\n- ‚úÖ Great SEO (content in HTML)\n- ‚úÖ Fast initial render\n- ‚úÖ Works without JavaScript\n- ‚úÖ Fresh data on every request\n\n**Cons:**\n- ‚ùå Slower than SSG (generates on each request)\n- ‚ùå Higher server load\n- ‚ùå More complex hosting\n- ‚ùå TTFB (Time To First Byte) can be slow\n\n**Best for:**\n- E-commerce product pages\n- Social media feeds\n- Personalized content\n- Frequently changing data\n\n### 3. SSG (Static Site Generation)\n\n**How it works:**\n```\nBuild time ‚Üí Generate all HTML pages ‚Üí Deploy to CDN\n            ‚Üì\nBrowser ‚Üí CDN ‚Üí Pre-built HTML (instant!)\n```\n\n**Example (Next.js):**\n```jsx\n// This runs at BUILD time\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/posts');\n  const posts = await res.json();\n  \n  return { props: { posts } };\n}\n\nfunction BlogPage({ posts }) {\n  return (\n    <div>\n      {posts.map(post => <Article key={post.id} {...post} />)}\n    </div>\n  );\n}\n```\n\n**Pros:**\n- ‚úÖ Blazing fast (just HTML files)\n- ‚úÖ Great SEO\n- ‚úÖ Cheap hosting (CDN)\n- ‚úÖ Highly scalable\n- ‚úÖ Works without JavaScript\n\n**Cons:**\n- ‚ùå Need to rebuild for updates\n- ‚ùå Build time grows with pages\n- ‚ùå Not suitable for dynamic data\n- ‚ùå Personalization is harder\n\n**Best for:**\n- Blogs\n- Documentation\n- Marketing sites\n- Portfolio sites\n- Landing pages\n\n## Hybrid Approaches\n\n**Modern frameworks mix strategies!**\n\n### ISR (Incremental Static Regeneration)\n\n**Next.js feature:**\n```jsx\nexport async function getStaticProps() {\n  const data = await fetchData();\n  \n  return {\n    props: { data },\n    revalidate: 60 // Regenerate every 60 seconds\n  };\n}\n```\n\n**Benefits:**\n- ‚úÖ SSG speed\n- ‚úÖ Fresh data (eventually)\n- ‚úÖ Best of both worlds\n\n### Per-Page Strategy\n\n```\nYour app:\n  /blog ‚Üí SSG (static)\n  /blog/[slug] ‚Üí ISR (revalidate hourly)\n  /dashboard ‚Üí CSR (client-side)\n  /products/[id] ‚Üí SSR (server-side)\n```\n\nDifferent pages, different strategies!\n\n## Comparison Table\n\n| Feature | CSR | SSR | SSG |\n|---------|-----|-----|-----|\n| **Initial Load** | Slow | Fast | Fastest |\n| **SEO** | Poor | Great | Great |\n| **Server Cost** | Low | High | Minimal |\n| **Fresh Data** | Yes | Yes | No* |\n| **Complexity** | Low | Medium | Low |\n| **Hosting** | Simple | Complex | Simple |\n\n*Unless using ISR\n\n## When to Use What?\n\n**Choose CSR if:**\n- App behind login\n- SEO doesn't matter\n- Highly interactive\n- Real-time updates\n\n**Choose SSR if:**\n- SEO critical\n- Personalized content\n- Frequently changing data\n- Can handle server load\n\n**Choose SSG if:**\n- Content rarely changes\n- SEO critical\n- Want maximum performance\n- Limited budget\n\n## The Modern Approach\n\n**Use a meta-framework that supports all three:**\n\n- **Next.js** (React)\n- **Remix** (React)\n- **SvelteKit** (Svelte)\n- **Nuxt** (Vue)\n\nThese let you choose per page!\n\n## Code Flow Comparison\n\n**CSR:**\n```\n1. Browser requests /page\n2. Server sends empty HTML + JS\n3. JS loads and runs\n4. JS fetches data from API\n5. JS renders content\n6. User sees content (slow!)\n```\n\n**SSR:**\n```\n1. Browser requests /page\n2. Server fetches data\n3. Server renders HTML with data\n4. Server sends HTML to browser\n5. User sees content (fast!)\n6. JS hydrates (makes interactive)\n```\n\n**SSG:**\n```\nBuild time:\n1. Build script fetches data\n2. Generates HTML files\n\nRequest time:\n1. Browser requests /page\n2. CDN serves pre-built HTML\n3. User sees content (instant!)\n```",
      "codeExample": "// Example: Same page with different rendering strategies\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// CSR (Client-Side Rendering)\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nimport { useState, useEffect } from 'react';\n\nfunction ProductPage() {\n  const [product, setProduct] = useState(null);\n  \n  useEffect(() => {\n    // Fetch happens in browser\n    fetch('/api/products/123')\n      .then(r => r.json())\n      .then(setProduct);\n  }, []);\n  \n  if (!product) return <div>Loading...</div>;\n  \n  return <div>\n    <h1>{product.name}</h1>\n    <p>{product.description}</p>\n  </div>;\n}\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// SSR (Server-Side Rendering)\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// Next.js example\n\nexport async function getServerSideProps({ params }) {\n  // Fetch happens on server for EACH request\n  const res = await fetch(`https://api.example.com/products/${params.id}`);\n  const product = await res.json();\n  \n  return { props: { product } };\n}\n\nfunction ProductPage({ product }) {\n  // HTML is already rendered with data!\n  return <div>\n    <h1>{product.name}</h1>\n    <p>{product.description}</p>\n  </div>;\n}\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// SSG (Static Site Generation)\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// Next.js example\n\nexport async function getStaticPaths() {\n  // Generate all product pages at build time\n  const products = await fetch('https://api.example.com/products').then(r => r.json());\n  \n  return {\n    paths: products.map(p => ({ params: { id: p.id.toString() } })),\n    fallback: false\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  // Fetch happens at BUILD time (once)\n  const product = await fetch(`https://api.example.com/products/${params.id}`).then(r => r.json());\n  \n  return { props: { product } };\n}\n\nfunction ProductPage({ product }) {\n  // Pre-rendered HTML served from CDN!\n  return <div>\n    <h1>{product.name}</h1>\n    <p>{product.description}</p>\n  </div>;\n}\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// ISR (Incremental Static Regeneration)\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nexport async function getStaticProps({ params }) {\n  const product = await fetch(`https://api.example.com/products/${params.id}`).then(r => r.json());\n  \n  return {\n    props: { product },\n    revalidate: 3600 // Regenerate every hour\n  };\n}\n\nfunction ProductPage({ product }) {\n  // Static at first, regenerates in background!\n  return <div>\n    <h1>{product.name}</h1>\n    <p>{product.description}</p>\n  </div>;\n}"
    },
    {
      "id": "nextjs-overview",
      "moduleId": "fullstack-frameworks",
      "title": "Next.js Overview",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Next.js is a React meta-framework by Vercel\n- File-based routing (no react-router needed)\n- Supports SSR, SSG, ISR, and CSR\n- Built-in API routes, image optimization, and more\n\n---\n\n# Next.js: The React Production Framework\n\n## What is Next.js?\n\n**Next.js** is a framework built on top of React that adds:\n- Server-side rendering\n- Static site generation\n- File-based routing\n- API routes\n- Image optimization\n- And much more!\n\n**React alone:**\n```\nReact (UI library)\n+ React Router (routing)\n+ Your own build setup\n+ Manual optimization\n= Lots of setup\n```\n\n**Next.js:**\n```\nNext.js\n= React + Routing + SSR/SSG + Optimization + More\n= Production ready, out of the box!\n```\n\n## File-Based Routing\n\n**No need for react-router!**\n\n```\npages/\n‚îú‚îÄ‚îÄ index.js        ‚Üí /\n‚îú‚îÄ‚îÄ about.js        ‚Üí /about\n‚îú‚îÄ‚îÄ blog/\n‚îÇ   ‚îú‚îÄ‚îÄ index.js    ‚Üí /blog\n‚îÇ   ‚îî‚îÄ‚îÄ [slug].js   ‚Üí /blog/anything\n‚îî‚îÄ‚îÄ api/\n    ‚îî‚îÄ‚îÄ users.js    ‚Üí /api/users\n```\n\n**Example:**\n```jsx\n// pages/about.js\nexport default function About() {\n  return <h1>About Page</h1>;\n}\n\n// Automatically available at /about!\n```\n\n**Dynamic routes:**\n```jsx\n// pages/blog/[slug].js\nimport { useRouter } from 'next/router';\n\nexport default function BlogPost() {\n  const router = useRouter();\n  const { slug } = router.query;\n  \n  return <h1>Post: {slug}</h1>;\n}\n\n// /blog/hello-world ‚Üí slug = \"hello-world\"\n```\n\n## Data Fetching Methods\n\n### 1. getStaticProps (SSG)\n\n```jsx\n// Runs at BUILD time\nexport async function getStaticProps() {\n  const posts = await fetch('https://api.example.com/posts').then(r => r.json());\n  \n  return {\n    props: { posts }\n  };\n}\n\nfunction Blog({ posts }) {\n  return (\n    <div>\n      {posts.map(post => <Article key={post.id} {...post} />)}\n    </div>\n  );\n}\n```\n\n### 2. getServerSideProps (SSR)\n\n```jsx\n// Runs on EVERY request\nexport async function getServerSideProps(context) {\n  const { params, req, res } = context;\n  \n  const user = await fetch(`https://api.example.com/users/${params.id}`).then(r => r.json());\n  \n  return {\n    props: { user }\n  };\n}\n\nfunction UserProfile({ user }) {\n  return <h1>{user.name}</h1>;\n}\n```\n\n### 3. getStaticPaths (SSG with dynamic routes)\n\n```jsx\n// Generate all paths at build time\nexport async function getStaticPaths() {\n  const posts = await fetch('https://api.example.com/posts').then(r => r.json());\n  \n  const paths = posts.map(post => ({\n    params: { slug: post.slug }\n  }));\n  \n  return {\n    paths,\n    fallback: false // 404 for other paths\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  const post = await fetch(`https://api.example.com/posts/${params.slug}`).then(r => r.json());\n  \n  return { props: { post } };\n}\n\nfunction Post({ post }) {\n  return <article>{post.content}</article>;\n}\n```\n\n## API Routes\n\n**Build APIs in the same project!**\n\n```javascript\n// pages/api/users.js\nexport default function handler(req, res) {\n  if (req.method === 'GET') {\n    res.status(200).json({ users: ['Alice', 'Bob'] });\n  } else if (req.method === 'POST') {\n    const newUser = req.body;\n    // Save to database...\n    res.status(201).json(newUser);\n  }\n}\n\n// Available at /api/users\n```\n\n**Fetch from frontend:**\n```jsx\nconst users = await fetch('/api/users').then(r => r.json());\n```\n\n## Image Optimization\n\n**Automatic optimization!**\n\n```jsx\nimport Image from 'next/image';\n\nfunction Profile() {\n  return (\n    <Image\n      src=\"/profile.jpg\"\n      alt=\"Profile\"\n      width={500}\n      height={500}\n      // Automatically:\n      // - Lazy loads\n      // - Optimizes format (WebP)\n      // - Responsive sizes\n    />\n  );\n}\n```\n\n## App Router (Next.js 13+)\n\n**New paradigm with React Server Components:**\n\n```\napp/\n‚îú‚îÄ‚îÄ layout.js       ‚Üí Root layout\n‚îú‚îÄ‚îÄ page.js         ‚Üí Home (/)\n‚îú‚îÄ‚îÄ about/\n‚îÇ   ‚îî‚îÄ‚îÄ page.js     ‚Üí /about\n‚îî‚îÄ‚îÄ blog/\n    ‚îú‚îÄ‚îÄ layout.js   ‚Üí Blog layout\n    ‚îî‚îÄ‚îÄ [slug]/\n        ‚îî‚îÄ‚îÄ page.js ‚Üí /blog/[slug]\n```\n\n**Example:**\n```jsx\n// app/blog/[slug]/page.js\n\n// Server Component (default)\nasync function BlogPost({ params }) {\n  // Can fetch directly in component!\n  const post = await fetch(`https://api.example.com/posts/${params.slug}`).then(r => r.json());\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </article>\n  );\n}\n\nexport default BlogPost;\n```\n\n## Next.js Features\n\n**Built-in:**\n- ‚úÖ TypeScript support\n- ‚úÖ CSS/Sass support\n- ‚úÖ Environment variables\n- ‚úÖ Fast Refresh (instant updates)\n- ‚úÖ Code splitting (automatic)\n- ‚úÖ Middleware\n- ‚úÖ Internationalization\n\n## Deployment\n\n**Vercel (creators of Next.js):**\n```bash\nnpm install -g vercel\nvercel\n```\n\nDone! Auto-deployed with:\n- CDN\n- Serverless functions\n- Edge functions\n- Analytics\n\n**Other platforms:**\n- Netlify\n- AWS Amplify\n- DigitalOcean\n- Self-hosted Node.js\n\n## When to Use Next.js\n\n**Perfect for:**\n- ‚úÖ Production React apps\n- ‚úÖ SEO-critical sites\n- ‚úÖ E-commerce\n- ‚úÖ Blogs\n- ‚úÖ Marketing sites\n- ‚úÖ SaaS applications\n\n**Maybe not for:**\n- ‚ùå Simple static sites (use Astro)\n- ‚ùå Apps that don't need SSR\n- ‚ùå When you want minimal abstraction\n\n## Pros & Cons\n\n**‚úÖ Pros:**\n- Production-ready\n- Great DX\n- Amazing performance\n- Huge ecosystem\n- Active development\n- Backed by Vercel\n- Great documentation\n\n**‚ùå Cons:**\n- Opinionated\n- Can be complex\n- Vendor lock-in (Vercel features)\n- Learning curve\n- Sometimes over-engineered for simple sites",
      "codeExample": "// Complete Next.js example: Blog with ISR\n\n// pages/index.js - Home page (SSG)\nexport async function getStaticProps() {\n  const posts = await fetch('https://api.example.com/posts').then(r => r.json());\n  \n  return {\n    props: { posts },\n    revalidate: 60 // ISR: Regenerate every 60 seconds\n  };\n}\n\nexport default function Home({ posts }) {\n  return (\n    <div>\n      <h1>Blog Posts</h1>\n      {posts.map(post => (\n        <Link key={post.id} href={`/blog/${post.slug}`}>\n          <a className=\"post-card\">\n            <h2>{post.title}</h2>\n            <p>{post.excerpt}</p>\n          </a>\n        </Link>\n      ))}\n    </div>\n  );\n}\n\n// pages/blog/[slug].js - Individual post (ISR)\nexport async function getStaticPaths() {\n  const posts = await fetch('https://api.example.com/posts').then(r => r.json());\n  \n  return {\n    paths: posts.map(post => ({ params: { slug: post.slug } })),\n    fallback: 'blocking' // Generate new pages on demand\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  const post = await fetch(`https://api.example.com/posts/${params.slug}`).then(r => r.json());\n  \n  if (!post) {\n    return { notFound: true };\n  }\n  \n  return {\n    props: { post },\n    revalidate: 60\n  };\n}\n\nexport default function BlogPost({ post }) {\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p className=\"date\">{post.publishedAt}</p>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n    </article>\n  );\n}\n\n// pages/api/newsletter.js - API route\nexport default async function handler(req, res) {\n  if (req.method === 'POST') {\n    const { email } = req.body;\n    \n    // Add to newsletter\n    await fetch('https://api.newsletter.com/subscribe', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ email })\n    });\n    \n    res.status(200).json({ success: true });\n  } else {\n    res.status(405).json({ error: 'Method not allowed' });\n  }\n}\n\n// pages/_app.js - Global layout\nimport '../styles/globals.css';\n\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <>\n      <header>\n        <nav>\n          <Link href=\"/\">Home</Link>\n          <Link href=\"/about\">About</Link>\n        </nav>\n      </header>\n      <main>\n        <Component {...pageProps} />\n      </main>\n      <footer>\n        <p>&copy; 2024 My Blog</p>\n      </footer>\n    </>\n  );\n}\n\nexport default MyApp;"
    },
    {
      "id": "remix-web-standards",
      "moduleId": "fullstack-frameworks",
      "title": "Remix: Web Standards First",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Remix is a fullstack React framework focusing on web standards\n- Uses standard Web APIs (Request, Response, FormData)\n- Server-side by default, progressively enhanced\n- Nested routing with data loading\n\n---\n\n# Remix: Embracing Web Standards\n\n## What is Remix?\n\n**Remix** is a fullstack React framework that prioritizes:\n- Web standards (native browser APIs)\n- Progressive enhancement\n- Server-side rendering\n- Fast user experiences\n\n**Created by:** React Router team\n\n## Philosophy: Web Standards First\n\n**Remix uses native Web APIs:**\n\n```javascript\n// Standard Web APIs, not framework abstractions!\nimport { Request, Response, Headers, FormData } from 'web-standards';\n\n// This works in browsers, workers, Node.js, Deno, anywhere!\n```\n\n**Why?**\n- ‚úÖ No vendor lock-in\n- ‚úÖ Skills transfer to any platform\n- ‚úÖ Future-proof\n- ‚úÖ Works everywhere (browsers, edge, Node.js)\n\n## File-Based Routing\n\n```\napp/routes/\n‚îú‚îÄ‚îÄ _index.tsx          ‚Üí /\n‚îú‚îÄ‚îÄ about.tsx           ‚Üí /about\n‚îú‚îÄ‚îÄ blog._index.tsx     ‚Üí /blog\n‚îú‚îÄ‚îÄ blog.$slug.tsx      ‚Üí /blog/:slug\n‚îî‚îÄ‚îÄ blog.new.tsx        ‚Üí /blog/new\n```\n\n**Example route:**\n```tsx\n// app/routes/blog.$slug.tsx\n\nexport default function BlogPost() {\n  return <article>Post content</article>;\n}\n```\n\n## Loaders (Server-Side Data)\n\n**Fetch data on the server:**\n\n```tsx\nimport { json } from '@remix-run/node';\nimport { useLoaderData } from '@remix-run/react';\n\n// Runs on SERVER\nexport async function loader({ params }) {\n  const post = await fetch(`https://api.example.com/posts/${params.slug}`).then(r => r.json());\n  \n  return json({ post });\n}\n\n// Runs on CLIENT (with server data)\nexport default function BlogPost() {\n  const { post } = useLoaderData();\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </article>\n  );\n}\n```\n\n**Automatically:**\n- Server-side renders\n- Sends HTML to browser\n- Hydrates for interactivity\n\n## Actions (Server-Side Mutations)\n\n**Handle form submissions on the server:**\n\n```tsx\nimport { redirect } from '@remix-run/node';\nimport { Form } from '@remix-run/react';\n\n// Runs on SERVER when form submits\nexport async function action({ request }) {\n  const formData = await request.formData();\n  const email = formData.get('email');\n  \n  await fetch('https://api.newsletter.com/subscribe', {\n    method: 'POST',\n    body: JSON.stringify({ email })\n  });\n  \n  return redirect('/thank-you');\n}\n\nexport default function Newsletter() {\n  return (\n    <Form method=\"post\">\n      <input type=\"email\" name=\"email\" required />\n      <button type=\"submit\">Subscribe</button>\n    </Form>\n  );\n}\n```\n\n**Works without JavaScript!** (Progressive enhancement)\n\n## Nested Routes\n\n**Powerful nested routing:**\n\n```\napp/routes/\n‚îú‚îÄ‚îÄ dashboard.tsx           ‚Üí Layout\n‚îú‚îÄ‚îÄ dashboard._index.tsx    ‚Üí /dashboard\n‚îú‚îÄ‚îÄ dashboard.settings.tsx  ‚Üí /dashboard/settings\n‚îî‚îÄ‚îÄ dashboard.projects.tsx  ‚Üí /dashboard/projects\n```\n\n**dashboard.tsx (parent):**\n```tsx\nimport { Outlet } from '@remix-run/react';\n\nexport default function Dashboard() {\n  return (\n    <div>\n      <aside>\n        <nav>\n          <Link to=\"/dashboard\">Home</Link>\n          <Link to=\"/dashboard/settings\">Settings</Link>\n        </nav>\n      </aside>\n      <main>\n        <Outlet /> {/* Child routes render here */}\n      </main>\n    </div>\n  );\n}\n```\n\n**Each route loads its own data!**\n\n```tsx\n// dashboard.tsx\nexport async function loader() {\n  return json({ user: await getUser() });\n}\n\n// dashboard.projects.tsx\nexport async function loader() {\n  return json({ projects: await getProjects() });\n}\n\n// Both load in parallel!\n```\n\n## Error Handling\n\n**Built-in error boundaries:**\n\n```tsx\nexport function ErrorBoundary() {\n  const error = useRouteError();\n  \n  return (\n    <div>\n      <h1>Oops!</h1>\n      <p>{error.message}</p>\n    </div>\n  );\n}\n\nexport default function Route() {\n  // If this throws, ErrorBoundary catches it\n  throw new Error('Something went wrong!');\n}\n```\n\n## Forms Without JavaScript\n\n**Progressive enhancement:**\n\n```tsx\nimport { Form, useNavigation } from '@remix-run/react';\n\nexport async function action({ request }) {\n  const formData = await request.formData();\n  const title = formData.get('title');\n  \n  await createPost({ title });\n  return redirect('/blog');\n}\n\nexport default function NewPost() {\n  const navigation = useNavigation();\n  const isSubmitting = navigation.state === 'submitting';\n  \n  return (\n    <Form method=\"post\">\n      <input type=\"text\" name=\"title\" required />\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Creating...' : 'Create Post'}\n      </button>\n    </Form>\n  );\n}\n```\n\n**Without JS:** Form posts, page redirects\n**With JS:** Form posts via fetch, smooth transition\n\n## Optimistic UI\n\n```tsx\nimport { useFetcher } from '@remix-run/react';\n\nfunction TodoItem({ todo }) {\n  const fetcher = useFetcher();\n  \n  // Optimistically show as complete\n  const isComplete = fetcher.formData \n    ? fetcher.formData.get('complete') === 'true'\n    : todo.complete;\n  \n  return (\n    <fetcher.Form method=\"post\">\n      <input \n        type=\"checkbox\"\n        name=\"complete\"\n        value=\"true\"\n        checked={isComplete}\n        onChange={(e) => fetcher.submit(e.target.form)}\n      />\n      <span style={{ textDecoration: isComplete ? 'line-through' : 'none' }}>\n        {todo.title}\n      </span>\n    </fetcher.Form>\n  );\n}\n```\n\n## Remix vs Next.js\n\n**Remix:**\n- ‚úÖ Web standards focus\n- ‚úÖ Server-side by default\n- ‚úÖ Better data mutations\n- ‚úÖ Progressive enhancement\n- ‚ùå Smaller ecosystem\n- ‚ùå No SSG (server required)\n\n**Next.js:**\n- ‚úÖ Larger ecosystem\n- ‚úÖ SSG support\n- ‚úÖ More mature\n- ‚úÖ Vercel integration\n- ‚ùå More complex APIs\n- ‚ùå Less web standards\n\n## When to Choose Remix\n\n**Great for:**\n- ‚úÖ Server-rendered apps\n- ‚úÖ Form-heavy applications\n- ‚úÖ When you want web standards\n- ‚úÖ Progressive enhancement\n- ‚úÖ Edge deployment\n\n**Maybe not for:**\n- ‚ùå Static sites (no SSG)\n- ‚ùå Client-heavy SPAs\n- ‚ùå When you need massive ecosystem",
      "codeExample": "// Complete Remix example: Todo app\n\n// app/routes/_index.tsx\nimport { json, redirect } from '@remix-run/node';\nimport { useLoaderData, Form, useFetcher } from '@remix-run/react';\n\n// Load todos from database\nexport async function loader() {\n  const todos = await db.todo.findMany();\n  return json({ todos });\n}\n\n// Handle todo creation and updates\nexport async function action({ request }) {\n  const formData = await request.formData();\n  const intent = formData.get('intent');\n  \n  if (intent === 'create') {\n    const title = formData.get('title');\n    await db.todo.create({ data: { title, complete: false } });\n  }\n  \n  if (intent === 'toggle') {\n    const id = formData.get('id');\n    const complete = formData.get('complete') === 'true';\n    await db.todo.update({ where: { id }, data: { complete } });\n  }\n  \n  if (intent === 'delete') {\n    const id = formData.get('id');\n    await db.todo.delete({ where: { id } });\n  }\n  \n  return redirect('/');\n}\n\nfunction TodoItem({ todo }) {\n  const fetcher = useFetcher();\n  \n  // Optimistic UI\n  const isComplete = fetcher.formData\n    ? fetcher.formData.get('complete') === 'true'\n    : todo.complete;\n  \n  return (\n    <li>\n      <fetcher.Form method=\"post\" style={{ display: 'inline' }}>\n        <input type=\"hidden\" name=\"intent\" value=\"toggle\" />\n        <input type=\"hidden\" name=\"id\" value={todo.id} />\n        <input type=\"hidden\" name=\"complete\" value={!isComplete} />\n        <button type=\"submit\">\n          {isComplete ? '‚úì' : '‚óã'}\n        </button>\n      </fetcher.Form>\n      \n      <span style={{ textDecoration: isComplete ? 'line-through' : 'none' }}>\n        {todo.title}\n      </span>\n      \n      <Form method=\"post\" style={{ display: 'inline' }}>\n        <input type=\"hidden\" name=\"intent\" value=\"delete\" />\n        <input type=\"hidden\" name=\"id\" value={todo.id} />\n        <button type=\"submit\">Delete</button>\n      </Form>\n    </li>\n  );\n}\n\nexport default function Index() {\n  const { todos } = useLoaderData();\n  \n  return (\n    <div>\n      <h1>Todos</h1>\n      \n      <Form method=\"post\">\n        <input type=\"hidden\" name=\"intent\" value=\"create\" />\n        <input \n          type=\"text\" \n          name=\"title\" \n          placeholder=\"New todo...\"\n          required \n        />\n        <button type=\"submit\">Add</button>\n      </Form>\n      \n      <ul>\n        {todos.map(todo => <TodoItem key={todo.id} todo={todo} />)}\n      </ul>\n    </div>\n  );\n}\n\n// Works without JavaScript!\n// With JavaScript: Optimistic UI, no full page reloads"
    },
    {
      "id": "sveltekit",
      "moduleId": "fullstack-frameworks",
      "title": "SvelteKit",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- SvelteKit is the official fullstack framework for Svelte\n- File-based routing with +page.svelte\n- Supports SSR, SSG, CSR per page\n- Built on Vite (extremely fast)\n\n---\n\n# SvelteKit: Svelte Goes Fullstack\n\n## What is SvelteKit?\n\n**SvelteKit** is to Svelte what Next.js is to React:\n- Fullstack framework\n- Server-side rendering\n- Static site generation\n- API routes\n- File-based routing\n\n**But with Svelte's simplicity!**\n\n## File-Based Routing\n\n```\nsrc/routes/\n‚îú‚îÄ‚îÄ +page.svelte        ‚Üí /\n‚îú‚îÄ‚îÄ about/\n‚îÇ   ‚îî‚îÄ‚îÄ +page.svelte    ‚Üí /about\n‚îú‚îÄ‚îÄ blog/\n‚îÇ   ‚îú‚îÄ‚îÄ +page.svelte    ‚Üí /blog\n‚îÇ   ‚îî‚îÄ‚îÄ [slug]/\n‚îÇ       ‚îî‚îÄ‚îÄ +page.svelte ‚Üí /blog/:slug\n‚îî‚îÄ‚îÄ api/\n    ‚îî‚îÄ‚îÄ users/\n        ‚îî‚îÄ‚îÄ +server.js  ‚Üí /api/users\n```\n\n**Simple route:**\n```svelte\n<!-- src/routes/about/+page.svelte -->\n<h1>About Us</h1>\n<p>Welcome to our site!</p>\n```\n\nThat's it! Route created.\n\n## Loading Data\n\n**+page.js for data loading:**\n\n```javascript\n// src/routes/blog/+page.js\n\nexport async function load({ fetch }) {\n  const response = await fetch('https://api.example.com/posts');\n  const posts = await response.json();\n  \n  return {\n    posts\n  };\n}\n```\n\n**Use in component:**\n```svelte\n<!-- src/routes/blog/+page.svelte -->\n<script>\n  export let data; // From load function\n</script>\n\n<h1>Blog Posts</h1>\n{#each data.posts as post}\n  <article>\n    <h2>{post.title}</h2>\n    <p>{post.excerpt}</p>\n  </article>\n{/each}\n```\n\n## Dynamic Routes\n\n```svelte\n<!-- src/routes/blog/[slug]/+page.svelte -->\n<script>\n  export let data;\n</script>\n\n<article>\n  <h1>{data.post.title}</h1>\n  <div>{@html data.post.content}</div>\n</article>\n```\n\n```javascript\n// src/routes/blog/[slug]/+page.js\n\nexport async function load({ params, fetch }) {\n  const response = await fetch(`https://api.example.com/posts/${params.slug}`);\n  const post = await response.json();\n  \n  return { post };\n}\n```\n\n## Server-Only Code\n\n**+page.server.js runs ONLY on server:**\n\n```javascript\n// src/routes/dashboard/+page.server.js\n\nimport { db } from '$lib/database';\n\nexport async function load({ cookies }) {\n  const sessionId = cookies.get('session');\n  \n  // Database code never sent to browser!\n  const user = await db.user.findUnique({\n    where: { sessionId }\n  });\n  \n  return { user };\n}\n```\n\n## Form Actions\n\n**Handle form submissions:**\n\n```javascript\n// src/routes/login/+page.server.js\n\nimport { fail, redirect } from '@sveltejs/kit';\n\nexport const actions = {\n  default: async ({ request, cookies }) => {\n    const data = await request.formData();\n    const email = data.get('email');\n    const password = data.get('password');\n    \n    const user = await authenticateUser(email, password);\n    \n    if (!user) {\n      return fail(400, { error: 'Invalid credentials' });\n    }\n    \n    cookies.set('session', user.sessionId);\n    throw redirect(303, '/dashboard');\n  }\n};\n```\n\n```svelte\n<!-- src/routes/login/+page.svelte -->\n<script>\n  import { enhance } from '$app/forms';\n  export let form; // Contains errors from action\n</script>\n\n<form method=\"POST\" use:enhance>\n  {#if form?.error}\n    <p class=\"error\">{form.error}</p>\n  {/if}\n  \n  <input type=\"email\" name=\"email\" required />\n  <input type=\"password\" name=\"password\" required />\n  <button type=\"submit\">Login</button>\n</form>\n```\n\n**Works without JavaScript!**\n\n## API Routes\n\n```javascript\n// src/routes/api/users/+server.js\n\nimport { json } from '@sveltejs/kit';\nimport { db } from '$lib/database';\n\nexport async function GET() {\n  const users = await db.user.findMany();\n  return json(users);\n}\n\nexport async function POST({ request }) {\n  const data = await request.json();\n  const user = await db.user.create({ data });\n  return json(user, { status: 201 });\n}\n```\n\n**Call from frontend:**\n```javascript\nconst users = await fetch('/api/users').then(r => r.json());\n```\n\n## Layouts\n\n**+layout.svelte wraps pages:**\n\n```svelte\n<!-- src/routes/+layout.svelte -->\n<script>\n  import Header from '$lib/Header.svelte';\n  import Footer from '$lib/Footer.svelte';\n</script>\n\n<Header />\n\n<main>\n  <slot /> <!-- Pages render here -->\n</main>\n\n<Footer />\n```\n\n**Nested layouts:**\n```\nsrc/routes/\n‚îú‚îÄ‚îÄ +layout.svelte         ‚Üí Wraps everything\n‚îî‚îÄ‚îÄ dashboard/\n    ‚îú‚îÄ‚îÄ +layout.svelte     ‚Üí Wraps dashboard pages\n    ‚îú‚îÄ‚îÄ +page.svelte       ‚Üí /dashboard\n    ‚îî‚îÄ‚îÄ settings/\n        ‚îî‚îÄ‚îÄ +page.svelte   ‚Üí /dashboard/settings\n```\n\n## Prerendering (SSG)\n\n**Generate static pages:**\n\n```javascript\n// src/routes/blog/+page.js\n\nexport const prerender = true; // Static at build time!\n\nexport async function load({ fetch }) {\n  const posts = await fetch('https://api.example.com/posts').then(r => r.json());\n  return { posts };\n}\n```\n\n## Per-Page Rendering\n\n```javascript\n// SSG\nexport const prerender = true;\n\n// SSR\nexport const prerender = false;\n\n// CSR (no server-side rendering)\nexport const ssr = false;\n```\n\nChoose per page!\n\n## Hooks\n\n**Global server logic:**\n\n```javascript\n// src/hooks.server.js\n\nexport async function handle({ event, resolve }) {\n  // Runs on every request\n  const sessionId = event.cookies.get('session');\n  \n  if (sessionId) {\n    event.locals.user = await getUser(sessionId);\n  }\n  \n  return await resolve(event);\n}\n```\n\n**Use in routes:**\n```javascript\nexport async function load({ locals }) {\n  return {\n    user: locals.user\n  };\n}\n```\n\n## Built on Vite\n\n**Benefits:**\n- ‚ö° Instant server start\n- ‚ö° Lightning-fast HMR\n- üîß Rich plugin ecosystem\n- üì¶ Optimized builds\n\n## Adapters\n\n**Deploy anywhere:**\n\n```javascript\n// svelte.config.js\nimport adapter from '@sveltejs/adapter-vercel';\n// Or: adapter-netlify, adapter-cloudflare, adapter-node, etc.\n\nexport default {\n  kit: {\n    adapter: adapter()\n  }\n};\n```\n\n## SvelteKit vs Next.js\n\n**SvelteKit:**\n- ‚úÖ Simpler syntax\n- ‚úÖ Smaller bundles\n- ‚úÖ Faster dev server (Vite)\n- ‚úÖ Less code to write\n- ‚ùå Smaller ecosystem\n- ‚ùå Newer (less mature)\n\n**Next.js:**\n- ‚úÖ Larger ecosystem\n- ‚úÖ More mature\n- ‚úÖ More jobs\n- ‚ùå More complex\n- ‚ùå Larger bundles\n\n## When to Choose SvelteKit\n\n**Great for:**\n- ‚úÖ New projects\n- ‚úÖ When you love Svelte\n- ‚úÖ Performance matters\n- ‚úÖ You want simplicity\n- ‚úÖ Modern development\n\n**Maybe not for:**\n- ‚ùå When you need React ecosystem\n- ‚ùå Large enterprise (smaller community)",
      "codeExample": "// Complete SvelteKit example: Blog with auth\n\n// src/routes/+layout.svelte - Root layout\n<script>\n  export let data;\n</script>\n\n<nav>\n  <a href=\"/\">Home</a>\n  <a href=\"/blog\">Blog</a>\n  {#if data.user}\n    <a href=\"/dashboard\">Dashboard</a>\n    <form method=\"POST\" action=\"/logout\">\n      <button>Logout</button>\n    </form>\n  {:else}\n    <a href=\"/login\">Login</a>\n  {/if}\n</nav>\n\n<main>\n  <slot />\n</main>\n\n// src/routes/+layout.server.js - Load user\nexport async function load({ locals }) {\n  return {\n    user: locals.user || null\n  };\n}\n\n// src/routes/blog/+page.js - Load posts\nexport const prerender = true; // Static generation!\n\nexport async function load({ fetch }) {\n  const posts = await fetch('/api/posts').then(r => r.json());\n  return { posts };\n}\n\n// src/routes/blog/+page.svelte - Display posts\n<script>\n  export let data;\n</script>\n\n<h1>Blog</h1>\n\n{#each data.posts as post}\n  <article>\n    <h2><a href=\"/blog/{post.slug}\">{post.title}</a></h2>\n    <p>{post.excerpt}</p>\n  </article>\n{/each}\n\n// src/routes/blog/[slug]/+page.js - Load single post\nexport async function load({ params, fetch }) {\n  const post = await fetch(`/api/posts/${params.slug}`).then(r => r.json());\n  \n  if (!post) {\n    throw error(404, 'Post not found');\n  }\n  \n  return { post };\n}\n\n// src/routes/api/posts/+server.js - API endpoint\nimport { json } from '@sveltejs/kit';\nimport { db } from '$lib/database';\n\nexport async function GET() {\n  const posts = await db.post.findMany({\n    where: { published: true },\n    orderBy: { createdAt: 'desc' }\n  });\n  \n  return json(posts);\n}\n\nexport async function POST({ request, locals }) {\n  if (!locals.user) {\n    throw error(401, 'Unauthorized');\n  }\n  \n  const data = await request.json();\n  const post = await db.post.create({\n    data: {\n      ...data,\n      authorId: locals.user.id\n    }\n  });\n  \n  return json(post, { status: 201 });\n}\n\n// src/hooks.server.js - Auth middleware\nexport async function handle({ event, resolve }) {\n  const sessionId = event.cookies.get('session');\n  \n  if (sessionId) {\n    const user = await db.user.findUnique({\n      where: { sessionId }\n    });\n    event.locals.user = user;\n  }\n  \n  return await resolve(event);\n}"
    },
    {
      "id": "why-metaframeworks",
      "moduleId": "fullstack-frameworks",
      "title": "Why Meta-Frameworks Exist",
      "order": 5,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Meta-frameworks solve problems that UI libraries don't address\n- They provide structure, routing, data fetching, and optimization\n- Trade-off: Simplicity vs Power vs Flexibility\n- Not always needed, but valuable for production apps\n\n---\n\n# Why Meta-Frameworks Exist\n\n## The Problem with Just React/Vue/Svelte\n\n**UI libraries only handle the UI:**\n\n```jsx\n// React component\nfunction MyApp() {\n  return <div>Hello World</div>;\n}\n\n// But you still need to figure out:\n// - How to route between pages?\n// - How to fetch data?\n// - How to optimize performance?\n// - How to handle SEO?\n// - How to deploy?\n```\n\n**You end up building or choosing:**\n- Routing solution\n- Data fetching strategy\n- Build configuration\n- Code splitting\n- Image optimization\n- SEO strategy\n- Deployment setup\n\n**Meta-frameworks solve all of this!**\n\n## What Meta-Frameworks Provide\n\n### 1. Routing\n\n**Without meta-framework:**\n```bash\nnpm install react-router-dom\n```\n```jsx\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/blog/:slug\" element={<BlogPost />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\nManual setup, configuration needed.\n\n**With meta-framework (Next.js):**\n```\npages/\n‚îú‚îÄ‚îÄ index.js    ‚Üí /\n‚îú‚îÄ‚îÄ about.js    ‚Üí /about\n‚îî‚îÄ‚îÄ blog/\n    ‚îî‚îÄ‚îÄ [slug].js ‚Üí /blog/:slug\n```\n\nJust create files!\n\n### 2. Data Fetching\n\n**Without meta-framework:**\n```jsx\nfunction BlogPost() {\n  const [post, setPost] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    fetch('/api/post')\n      .then(r => r.json())\n      .then(data => {\n        setPost(data);\n        setLoading(false);\n      });\n  }, []);\n  \n  if (loading) return <div>Loading...</div>;\n  return <div>{post.title}</div>;\n}\n```\n\nClient-side fetching, no SEO!\n\n**With meta-framework (Next.js):**\n```jsx\nexport async function getServerSideProps() {\n  const post = await fetch('/api/post').then(r => r.json());\n  return { props: { post } };\n}\n\nfunction BlogPost({ post }) {\n  return <div>{post.title}</div>;\n}\n```\n\nServer-side fetching, SEO-friendly!\n\n### 3. Performance Optimization\n\n**Automatic optimizations:**\n- ‚úÖ Code splitting (per route)\n- ‚úÖ Image optimization\n- ‚úÖ Font optimization\n- ‚úÖ Script optimization\n- ‚úÖ CSS optimization\n- ‚úÖ Lazy loading\n\n**Without meta-framework:** Configure manually\n**With meta-framework:** Works out of the box\n\n### 4. SEO\n\n**CSR (Client-Side Rendering):**\n```html\n<!-- What Google sees -->\n<html>\n  <body>\n    <div id=\"root\"></div>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n```\n\nNo content for SEO!\n\n**SSR (with meta-framework):**\n```html\n<!-- What Google sees -->\n<html>\n  <body>\n    <h1>Blog Post Title</h1>\n    <p>Content here...</p>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n```\n\nFull content for SEO!\n\n### 5. Developer Experience\n\n**Built-in:**\n- Fast Refresh (instant updates)\n- TypeScript support\n- Environment variables\n- API routes\n- Middleware\n- Error handling\n- Testing setup\n\n## The Evolution\n\n**Stage 1: Just HTML**\n```html\n<html>\n  <body>\n    <h1>My Site</h1>\n  </body>\n</html>\n```\nStatic, no interactivity\n\n**Stage 2: jQuery**\n```javascript\n$('#button').click(function() {\n  $('#content').text('Clicked!');\n});\n```\nInteractive, but messy\n\n**Stage 3: UI Libraries (React)**\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(count + 1)}>{count}</button>;\n}\n```\nComponent-based, but missing features\n\n**Stage 4: Meta-Frameworks (Next.js)**\n```jsx\n// pages/index.js\nexport async function getStaticProps() {\n  const data = await fetch('...');\n  return { props: { data } };\n}\n\nfunction Home({ data }) {\n  return <div>{data}</div>;\n}\n```\nFull-featured, production-ready!\n\n## Do You Always Need One?\n\n**No! Use meta-frameworks when:**\n\n‚úÖ **Building production apps**\n‚úÖ **SEO matters**\n‚úÖ **Want server-side rendering**\n‚úÖ **Team project**\n‚úÖ **Long-term maintenance**\n\n**Skip meta-frameworks when:**\n\n‚ùå **Learning basics** (too much magic)\n‚ùå **Simple prototypes**\n‚ùå **Embedded widgets**\n‚ùå **No SEO needed**\n‚ùå **Client-side only app**\n\n## The Cost\n\n**What you gain:**\n- üöÄ Performance\n- üîç SEO\n- üõ†Ô∏è DX (Developer Experience)\n- üì¶ Optimization\n- üèóÔ∏è Structure\n\n**What you give up:**\n- üéì Learning curve\n- üîí Vendor lock-in (sometimes)\n- üéØ Less flexibility\n- üìö More concepts to learn\n\n## Popular Meta-Frameworks\n\n**For React:**\n- Next.js (most popular)\n- Remix (web standards)\n- Gatsby (static sites)\n\n**For Vue:**\n- Nuxt (Next.js for Vue)\n- Quasar (full framework)\n\n**For Svelte:**\n- SvelteKit (official)\n\n**For Angular:**\n- Angular (already fullstack!)\n\n## The Bottom Line\n\n**Meta-frameworks exist because:**\n\n1. **UI libraries are intentionally minimal**\n   - They focus on the view layer\n   - You choose everything else\n\n2. **Production apps need more**\n   - Routing\n   - Data fetching\n   - SEO\n   - Performance\n   - Deploy strategy\n\n3. **Don't repeat yourself**\n   - Every project needs same solutions\n   - Meta-frameworks standardize them\n\n4. **Better together**\n   - Integrated solutions work better\n   - Optimized as a whole\n\n**Think of it this way:**\n\n```\nUI Library = Engine\nMeta-Framework = Complete Car\n\nYou could build a car around an engine...\nOr just buy the complete car!\n```",
      "codeExample": "// Evolution of a blog: From React to Next.js\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// LEVEL 1: Just React (Client-Side)\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nimport { useState, useEffect } from 'react';\nimport { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\n\nfunction BlogList() {\n  const [posts, setPosts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    fetch('/api/posts')\n      .then(r => r.json())\n      .then(data => {\n        setPosts(data);\n        setLoading(false);\n      });\n  }, []);\n  \n  if (loading) return <div>Loading...</div>;\n  \n  return (\n    <div>\n      <h1>Blog</h1>\n      {posts.map(post => (\n        <Link key={post.id} to={`/blog/${post.slug}`}>\n          <h2>{post.title}</h2>\n        </Link>\n      ))}\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<BlogList />} />\n        <Route path=\"/blog/:slug\" element={<BlogPost />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\n// Problems:\n// ‚ùå No SEO (content loaded client-side)\n// ‚ùå Slow initial load (fetch after JS loads)\n// ‚ùå Manual routing setup\n// ‚ùå No optimization\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// LEVEL 2: Next.js (Meta-Framework)\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n// pages/index.js\nexport async function getStaticProps() {\n  const posts = await fetch('https://api.example.com/posts').then(r => r.json());\n  \n  return {\n    props: { posts },\n    revalidate: 60 // ISR: Regenerate every minute\n  };\n}\n\nexport default function Home({ posts }) {\n  return (\n    <div>\n      <h1>Blog</h1>\n      {posts.map(post => (\n        <Link key={post.id} href={`/blog/${post.slug}`}>\n          <a>\n            <h2>{post.title}</h2>\n          </a>\n        </Link>\n      ))}\n    </div>\n  );\n}\n\n// pages/blog/[slug].js\nexport async function getStaticPaths() {\n  const posts = await fetch('https://api.example.com/posts').then(r => r.json());\n  \n  return {\n    paths: posts.map(p => ({ params: { slug: p.slug } })),\n    fallback: 'blocking'\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  const post = await fetch(`https://api.example.com/posts/${params.slug}`).then(r => r.json());\n  \n  return {\n    props: { post },\n    revalidate: 60\n  };\n}\n\nexport default function BlogPost({ post }) {\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n    </article>\n  );\n}\n\n// Benefits:\n// ‚úÖ Great SEO (pre-rendered HTML)\n// ‚úÖ Fast initial load (static HTML)\n// ‚úÖ File-based routing (no setup)\n// ‚úÖ Automatic optimization\n// ‚úÖ ISR (fresh data without rebuilds)\n// ‚úÖ Image optimization built-in\n// ‚úÖ API routes included\n\n// This is why meta-frameworks exist!"
    }
  ],
  "exercises": [
    {
      "id": "fullstack-ex-1",
      "lessonId": "rendering-strategies",
      "moduleId": "fullstack-frameworks",
      "title": "Rendering Strategies Quiz",
      "difficulty": "medium",
      "description": "Test your understanding of CSR, SSR, and SSG.",
      "type": "quiz",
      "questions": [
        {
          "question": "Which rendering strategy is best for SEO?",
          "options": ["CSR", "SSR or SSG", "Only SSR", "Only SSG"],
          "correctAnswer": 1,
          "explanation": "Both SSR and SSG generate HTML with content, making them great for SEO. CSR sends empty HTML."
        },
        {
          "question": "When does SSG generate pages?",
          "options": ["On each request", "At build time", "When user visits", "Never"],
          "correctAnswer": 1,
          "explanation": "SSG (Static Site Generation) generates all HTML pages at build time, making them super fast to serve."
        },
        {
          "question": "Main drawback of CSR (Client-Side Rendering)?",
          "options": ["Too fast", "Poor SEO and slow initial load", "Expensive servers", "Can't be interactive"],
          "correctAnswer": 1,
          "explanation": "CSR shows a blank page until JavaScript loads and fetches data, hurting SEO and initial load time."
        },
        {
          "question": "What is ISR (Incremental Static Regeneration)?",
          "options": ["A new framework", "SSG with automatic regeneration", "Server-side routing", "Image optimization"],
          "correctAnswer": 1,
          "explanation": "ISR combines SSG's speed with the ability to regenerate pages in the background for fresh data."
        },
        {
          "question": "Which strategy for a frequently updated news site?",
          "options": ["CSR", "SSG", "SSR", "None"],
          "correctAnswer": 2,
          "explanation": "SSR generates fresh HTML on each request, perfect for frequently changing content like news."
        }
      ]
    },
    {
      "id": "fullstack-ex-2",
      "lessonId": "nextjs-overview",
      "moduleId": "fullstack-frameworks",
      "title": "Next.js Features",
      "difficulty": "medium",
      "description": "Understanding Next.js capabilities.",
      "type": "quiz",
      "questions": [
        {
          "question": "How does routing work in Next.js?",
          "options": ["React Router", "File-based (pages folder)", "Manual configuration", "No routing"],
          "correctAnswer": 1,
          "explanation": "Next.js uses file-based routing - create a file in pages/ and it becomes a route automatically."
        },
        {
          "question": "What does getStaticProps do?",
          "options": ["Fetches data on client", "Fetches data at build time (SSG)", "Creates API routes", "Handles forms"],
          "correctAnswer": 1,
          "explanation": "getStaticProps runs at build time to fetch data for static site generation."
        },
        {
          "question": "Can you build APIs in Next.js?",
          "options": ["No", "Yes, with API routes in pages/api/", "Only with external service", "Only in production"],
          "correctAnswer": 1,
          "explanation": "Next.js includes API routes - files in pages/api/ become serverless functions."
        },
        {
          "question": "What's the difference between getStaticProps and getServerSideProps?",
          "options": ["No difference", "One is faster", "getStaticProps runs at build, getServerSideProps per request", "One is deprecated"],
          "correctAnswer": 2,
          "explanation": "getStaticProps (SSG) runs at build time, getServerSideProps (SSR) runs on every request."
        }
      ]
    },
    {
      "id": "fullstack-ex-3",
      "lessonId": "remix-web-standards",
      "moduleId": "fullstack-frameworks",
      "title": "Remix Philosophy",
      "difficulty": "medium",
      "description": "Understanding Remix's approach.",
      "type": "quiz",
      "questions": [
        {
          "question": "What is Remix's main philosophy?",
          "options": ["React first", "Web standards first", "GraphQL first", "TypeScript first"],
          "correctAnswer": 1,
          "explanation": "Remix prioritizes web standards (Request, Response, FormData) over framework-specific abstractions."
        },
        {
          "question": "Do Remix forms work without JavaScript?",
          "options": ["No", "Yes, progressive enhancement", "Only in production", "Only simple forms"],
          "correctAnswer": 1,
          "explanation": "Remix forms use native HTML forms that work without JS, then enhance with JavaScript if available."
        },
        {
          "question": "What are Remix actions?",
          "options": ["Redux actions", "Server-side mutation handlers", "Client animations", "Route transitions"],
          "correctAnswer": 1,
          "explanation": "Actions are server-side functions that handle form submissions and mutations."
        },
        {
          "question": "Main difference between Remix and Next.js?",
          "options": ["Remix is faster", "Remix focuses on web standards, Next.js has more features", "Remix doesn't support SSR", "Remix only works with TypeScript"],
          "correctAnswer": 1,
          "explanation": "Remix prioritizes web standards and server-side, while Next.js offers more features like SSG."
        }
      ]
    },
    {
      "id": "fullstack-ex-4",
      "lessonId": "sveltekit",
      "moduleId": "fullstack-frameworks",
      "title": "SvelteKit Basics",
      "difficulty": "medium",
      "description": "Test SvelteKit knowledge.",
      "type": "quiz",
      "questions": [
        {
          "question": "What file defines a route in SvelteKit?",
          "options": ["route.svelte", "+page.svelte", "index.svelte", "page.svelte"],
          "correctAnswer": 1,
          "explanation": "+page.svelte files in src/routes/ define routes in SvelteKit."
        },
        {
          "question": "What is +page.server.js used for?",
          "options": ["Client code", "Server-only code (database, secrets)", "Styling", "Testing"],
          "correctAnswer": 1,
          "explanation": "+page.server.js runs only on the server, safe for database queries and secrets."
        },
        {
          "question": "What build tool does SvelteKit use?",
          "options": ["Webpack", "Rollup", "Vite", "esbuild"],
          "correctAnswer": 2,
          "explanation": "SvelteKit uses Vite for lightning-fast development and optimized builds."
        },
        {
          "question": "Can SvelteKit do SSG?",
          "options": ["No, only SSR", "Yes, with prerender option", "Only on Vercel", "Requires plugin"],
          "correctAnswer": 1,
          "explanation": "Set export const prerender = true to statically generate pages at build time."
        }
      ]
    },
    {
      "id": "fullstack-ex-5",
      "lessonId": "why-metaframeworks",
      "moduleId": "fullstack-frameworks",
      "title": "Choosing Your Stack",
      "difficulty": "hard",
      "description": "Decide when to use meta-frameworks vs UI libraries.",
      "type": "quiz",
      "questions": [
        {
          "question": "You're building a simple todo app to learn React. Should you use Next.js?",
          "options": ["Yes, always use Next.js", "No, start with just React", "Only if you need SEO", "Only for production"],
          "correctAnswer": 1,
          "explanation": "For learning, start with just React to understand the fundamentals before adding meta-framework complexity."
        },
        {
          "question": "You're building an e-commerce site that needs SEO. Which approach?",
          "options": ["React SPA (CSR)", "Next.js or Remix (SSR/SSG)", "Static HTML", "jQuery"],
          "correctAnswer": 1,
          "explanation": "E-commerce needs SEO for products, making SSR/SSG meta-frameworks like Next.js ideal."
        },
        {
          "question": "What's the main problem meta-frameworks solve?",
          "options": ["React is too slow", "UI libraries don't handle routing/data/SEO", "JavaScript is hard", "Styling is complex"],
          "correctAnswer": 1,
          "explanation": "UI libraries focus on views. Meta-frameworks add routing, data fetching, SEO, and optimization."
        },
        {
          "question": "You're building a dashboard behind login (no SEO needed). Best choice?",
          "options": ["Must use Next.js", "React SPA (CSR) is fine", "Static HTML", "Need SSR"],
          "correctAnswer": 1,
          "explanation": "Dashboards behind login don't need SEO, so a React SPA (CSR) is simpler and sufficient."
        },
        {
          "question": "What do you trade when using a meta-framework?",
          "options": ["Performance", "Features", "Some flexibility for structure and optimization", "Nothing, only benefits"],
          "correctAnswer": 2,
          "explanation": "Meta-frameworks are opinionated - you trade some flexibility for built-in structure and optimization."
        }
      ]
    }
  ]
}
