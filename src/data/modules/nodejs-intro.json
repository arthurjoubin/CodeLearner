{
  "module": {
    "id": "nodejs-intro",
    "title": "Node.js: Introduction and Installation",
    "description": "Understand what Node.js is, why it revolutionizes backend development, and how to install it",
    "icon": "Server",
    "requiredXp": 0,
    "color": "from-green-500 to-green-700",
    "courseId": "node-express"
  },
  "lessons": [
    {
      "id": "nodejs-what-is",
      "moduleId": "nodejs-intro",
      "title": "What is Node.js?",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Node.js is a JavaScript runtime environment for server-side execution\n- Created in 2009 by Ryan Dahl, based on Chrome's V8 engine\n- Allows running JavaScript outside the browser\n- Uses a single-threaded model with non-blocking event loop\n\n---\n\n# The Node.js Revolution\n\n## Historical Context\nBefore Node.js, JavaScript was strictly limited to web browsers. If you wanted to create a web server, you had to learn Python, Java, PHP, Ruby, or another backend language. Node.js changed everything by allowing you to use JavaScript everywhere: frontend AND backend.\n\n## Why This Matters for a Modern Developer?\nAs a modern web developer, you can:\n- Use the same language (JavaScript) from browser to server\n- Share code between frontend and backend (validation, utilities)\n- Access a massive ecosystem (npm with 2+ million packages)\n- Build real-time applications easily (chat, notifications)\n\n## How It Works\n\n### The V8 Engine\nNode.js uses V8, the same ultra-optimized JavaScript engine as Google Chrome. V8 compiles JavaScript into native machine code, making it extremely fast.\n\n### The Event Loop: The Heart of Node.js\nUnlike traditional servers (Apache PHP, Java Spring) that create a thread per request, Node.js uses a single thread with an event loop:\n\n```\n1. A request arrives\n2. Node.js processes it immediately or delegates it\n3. While the I/O operation (DB, file, API) executes...\n4. ...Node.js moves to the next request (non-blocking)\n5. When the I/O operation completes, a callback executes\n```\n\nThis model is perfect for I/O-bound applications (APIs, streaming, chat) but less suited for CPU-intensive tasks.\n\n## Typical Use Cases\n- **REST/GraphQL APIs**: The most common use case\n- **Real-time applications**: Chat, multiplayer games, collaboration\n- **Streaming**: Video/audio processing\n- **Microservices**: Lightweight, fast services\n- **Command-line tools**: Build scripts, automation\n\n## Architecture Overview\n```\n┌─────────────────────────────────────┐\n│           Your JavaScript Code      │\n├─────────────────────────────────────┤\n│  Node.js Core Modules (fs, http...) │\n├─────────────────────────────────────┤\n│  C++ Bindings (libuv, V8, etc.)    │\n├─────────────────────────────────────┤\n│  Operating System                   │\n└─────────────────────────────────────┘\n```\n\n## Key Characteristics\n\n### Non-blocking I/O\nTraditional blocking code:\n```javascript\n// Blocking: waits for file to be read\nconst data = fs.readFileSync('file.txt');\nconsole.log(data); // Executes after file is read\nconsole.log('Done'); // Executes after above\n```\n\nNode.js non-blocking code:\n```javascript\n// Non-blocking: continues immediately\nfs.readFile('file.txt', (err, data) => {\n  console.log(data); // Executes later when file is ready\n});\nconsole.log('Done'); // Executes immediately, before file is read\n```\n\n### Single-threaded with Event Loop\n- One thread handles all requests\n- I/O operations are offloaded and resumed via callbacks\n- Perfect for high-concurrency, I/O-bound workloads\n- Can handle thousands of concurrent connections\n\n## When to Use Node.js?\n\n### Great for:\n- APIs and microservices\n- Real-time applications (WebSockets)\n- Streaming applications\n- Serverless functions\n- Build tools and CLIs\n\n### Not ideal for:\n- CPU-intensive tasks (image processing, ML)\n- Heavy computational workloads\n- Applications requiring multi-threading\n\n## The JavaScript Ecosystem\nWith Node.js, you can use:\n- **Frontend**: React, Vue, Angular\n- **Backend**: Express, Fastify, NestJS\n- **Full-stack**: Next.js, Nuxt, SvelteKit\n- **Mobile**: React Native\n- **Desktop**: Electron\n\nAll with the same language!"
    },
    {
      "id": "nodejs-install",
      "moduleId": "nodejs-intro",
      "title": "Installation with NVM",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Use NVM (Node Version Manager) to manage versions\n- Never download Node.js directly from the website\n- NVM allows easy switching between versions\n- Projects often require specific versions\n\n---\n\n# Why NVM is Essential\n\n## The Version Problem\nImagine: you're working on a legacy project that requires Node.js 16, but a new project needs Node.js 20. Without NVM, you'd be stuck!\n\n## Installing NVM\n\n### On macOS/Linux:\n```bash\n# Install NVM via the official script\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash\n\n# Restart your terminal or run:\nsource ~/.bashrc  # or ~/.zshrc depending on your shell\n```\n\n### On Windows:\nUse **nvm-windows**: https://github.com/coreybutler/nvm-windows\n\n## Essential NVM Commands\n\n```bash\n# See available versions\nnvm ls-remote\n\n# Install a specific version\nnvm install 20\nnvm install 18.17.0\n\n# Use a version\nnvm use 20\n\n# Set default version\nnvm alias default 20\n\n# See installed versions\nnvm ls\n\n# Uninstall a version\nnvm uninstall 16\n```\n\n## Verify Installation\n\n```bash\n# Node.js version\nnode --version\n# v20.10.0\n\n# npm version (included with Node.js)\nnpm --version\n# 10.2.3\n\n# Launch REPL (Read-Eval-Print Loop)\nnode\n> console.log('Hello World')\nHello World\nundefined\n> .exit\n```\n\n## Node.js Project Structure\n\n```\nmy-project/\n├── node_modules/          # Installed dependencies (don't commit)\n├── package.json          # Project configuration\n├── package-lock.json     # Locked versions (commit this)\n└── src/                  # Source code\n    └── index.js\n```\n\n## Best Practices\n- Create a `.nvmrc` file at the root of each project with the required version:\n  ```bash\n  echo \"20\" > .nvmrc\n  ```\n- Use `nvm use` in the project folder to automatically switch versions\n- Commit `.nvmrc` so your team uses the same version\n- Use LTS (Long Term Support) versions for production (even numbers like 18, 20, 22)\n\n## LTS vs Current Versions\n\n| Type | Version | Use Case |\n|------|---------|----------|\n| LTS | Even numbers (18, 20, 22) | Production, stability |\n| Current | Odd numbers (19, 21, 23) | Testing new features |\n\n**Always use LTS for production applications!**\n\n## Troubleshooting\n\n### Command not found after installation\n```bash\n# Add to your shell config (~/.bashrc, ~/.zshrc, etc.)\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"\n```\n\n### Permission errors on macOS/Linux\nNever use `sudo` with npm/nvm. If you have permission issues, fix npm's default directory:\n```bash\nmkdir ~/.npm-global\nnpm config set prefix '~/.npm-global'\nexport PATH=~/.npm-global/bin:$PATH\n```\n\n## Next Steps\nOnce Node.js is installed, you're ready to create your first project and write your first server!"
    },
    {
      "id": "nodejs-first-script",
      "moduleId": "nodejs-intro",
      "title": "Your First Node.js Script",
      "order": 3,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Create a .js file and run it with `node file.js`\n- `console.log()` works just like in the browser\n- `process` gives access to system info\n- `__dirname` and `__filename` for paths\n\n---\n\n# Creating and Running a Script\n\n## Hello World\n\nCreate a file `app.js`:\n```javascript\nconsole.log('Hello, Node.js!');\nconsole.log('Version:', process.version);\nconsole.log('Platform:', process.platform);\n```\n\nRun it:\n```bash\nnode app.js\n```\n\n## The Global `process` Object\n\nNode.js provides the `process` object that gives access to the current process:\n\n```javascript\n// Environment information\nconsole.log('Node version:', process.version);\nconsole.log('PID:', process.pid);\nconsole.log('Platform:', process.platform);\nconsole.log('Architecture:', process.arch);\n\n// Command line arguments\nconsole.log('Arguments:', process.argv);\n// process.argv[0] = path to node\n// process.argv[1] = path to script\n// process.argv[2+] = arguments passed\n```\n\n## Basic Error Handling\n\n```javascript\n// try-catch just like browser JavaScript\ntry {\n  // Risky code\n  const result = JSON.parse('{invalid json}');\n} catch (error) {\n  console.error('Error:', error.message);\n}\n\n// Handle uncaught errors\nprocess.on('uncaughtException', (err) => {\n  console.error('Uncaught error:', err);\n  process.exit(1);\n});\n```\n\n## The Interactive REPL\n\nThe REPL (Read-Eval-Print Loop) is useful for quickly testing code:\n\n```bash\n$ node\n> const sum = (a, b) => a + b\nundefined\n> sum(5, 3)\n8\n> const fs = require('fs')\nundefined\n> fs.readdirSync('.')\n['app.js', 'node_modules', 'package.json']\n> .exit\n```\n\n## npm Scripts\n\nIn `package.json`, define scripts:\n```json\n{\n  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"dev\": \"node --watch src/index.js\",\n    \"test\": \"node --test\"\n  }\n}\n```\n\nRun them:\n```bash\nnpm start      # Runs: node src/index.js\nnpm run dev    # Runs: node --watch src/index.js\nnpm test       # Runs: node --test\n```\n\n## Environment Variables\n\n```javascript\n// Access environment variables\nconsole.log(process.env.NODE_ENV);\nconsole.log(process.env.PORT);\n\n// Set before running\nNODE_ENV=production node app.js\n\n// Or use .env files with dotenv package\nrequire('dotenv').config();\nconsole.log(process.env.DATABASE_URL);\n```\n\n## Common Patterns\n\n### Entry Point Pattern\n```javascript\n// src/index.js\nconst { startServer } = require('./server');\n\nconst PORT = process.env.PORT || 3000;\n\nstartServer(PORT);\n```\n\n### Graceful Shutdown\n```javascript\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing gracefully...');\n  server.close(() => {\n    console.log('Server closed');\n    process.exit(0);\n  });\n});\n```\n\n## Debugging Node.js\n\n```bash\n# Debug with Chrome DevTools\nnode --inspect app.js\n\n# Debug with breakpoints\nnode --inspect-brk app.js\n\n# Then open chrome://inspect in Chrome\n```\n\n## Exercise Ideas\n- Create a script that prints system information\n- Build a simple CLI tool that accepts command-line arguments\n- Write a script that reads a file and counts words"
    },
    {
      "id": "nodejs-package-json",
      "moduleId": "nodejs-intro",
      "title": "The package.json File",
      "order": 4,
      "difficulty": "beginner",
      "content": "# Essential to know\n- `npm init` creates a new project\n- `package.json` = project manifest\n- `dependencies` = packages needed in production\n- `devDependencies` = packages for development only\n\n---\n\n# Creating a Node.js Project\n\n## Initialization\n\n```bash\nmkdir my-project\ncd my-project\nnpm init -y  # -y = answer yes to everything with default values\n```\n\nThis creates a basic `package.json`:\n```json\n{\n  \"name\": \"my-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\n## Important Fields\n\n### name and version\n- `name`: must be unique if published to npm (lowercase, hyphens)\n- `version`: follows semver (Semantic Versioning) MAJOR.MINOR.PATCH\n\n### type: module vs CommonJS\n```json\n{\n  \"type\": \"module\"  // Enables ES Modules (import/export)\n}\n```\nWithout this field, Node.js uses CommonJS (require/module.exports) by default.\n\n### engines\nSpecifies required Node.js/npm versions:\n```json\n{\n  \"engines\": {\n    \"node\": \">=18.0.0\",\n    \"npm\": \">=9.0.0\"\n  }\n}\n```\n\n## Installing Dependencies\n\n```bash\n# Production (needed at runtime)\nnpm install express\nnpm install lodash\n\n# Development (build, tests, linting)\nnpm install --save-dev nodemon\nnpm install --save-dev jest\n\n# Global (CLI tools used everywhere)\nnpm install -g @angular/cli\n```\n\n## Dependencies vs devDependencies\n\n```json\n{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",      // Web server\n    \"lodash\": \"^4.17.21\"       // Utilities\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.0\",        // Auto-reload (dev only)\n    \"jest\": \"^29.0.0\",          // Testing\n    \"eslint\": \"^8.0.0\"          // Linting\n  }\n}\n```\n\nIn production (`npm install --production`), only dependencies are installed.\n\n## Semantic Versioning (semver)\n\n| Symbol | Meaning | Example |\n|--------|---------|---------|\n| `1.2.3` | Exact version | Only 1.2.3 |\n| `^1.2.3` | Compatible | 1.x.x (>=1.2.3 <2.0.0) |\n| `~1.2.3` | Approximately | 1.2.x (>=1.2.3 <1.3.0) |\n| `>=1.2.0` | Greater than | 1.2.0 or higher |\n| `*` | Any version | Latest |\n\n## Scripts Deep Dive\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"dev\": \"nodemon src/index.js\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"lint\": \"eslint src/\",\n    \"build\": \"webpack --mode=production\",\n    \"prebuild\": \"npm run lint\",  // Runs before build\n    \"postbuild\": \"echo 'Build complete!'\"  // Runs after build\n  }\n}\n```\n\nRun with:\n```bash\nnpm start          // Special: doesn't need 'run'\nnpm run dev        // Custom scripts need 'run'\nnpm test           // Special shortcut\nnpm run lint       // Custom script\n```\n\n## package-lock.json\n\n**Always commit this file!** It locks exact versions of all dependencies (and their dependencies) ensuring everyone installs the same versions.\n\n```bash\n# Regenerate if needed\nrm package-lock.json\nnpm install\n```\n\n## Private Projects\n\nPrevent accidental publishing to npm:\n```json\n{\n  \"private\": true\n}\n```\n\n## File Structure Best Practices\n\n```\nmy-project/\n├── package.json\n├── package-lock.json\n├── .gitignore\n├── .nvmrc\n├── src/\n│   ├── index.js\n│   ├── config/\n│   ├── routes/\n│   └── utils/\n├── tests/\n└── docs/\n```\n\n## .gitignore Essentials\n\n```gitignore\n# Dependencies\nnode_modules/\n\n# Logs\n*.log\nnpm-debug.log*\n\n# Environment\n.env\n.env.local\n\n# Build output\ndist/\nbuild/\n\n# OS files\n.DS_Store\nThumbs.db\n\n# IDE\n.vscode/\n.idea/\n```\n\n## Best Practices Summary\n\n1. **Always use `npm init -y`** to start projects\n2. **Commit package-lock.json** for reproducible builds\n3. **Use exact versions** for critical dependencies\n4. **Separate dev and prod** dependencies\n5. **Use npm scripts** instead of global tools\n6. **Add .gitignore** before first commit\n7. **Specify engines** for team consistency\n8. **Use `private: true`** for applications\n\n## Next Steps\nNow that you understand package.json, you're ready to build real applications with Node.js!"
    }
  ],
  "exercises": []
}
