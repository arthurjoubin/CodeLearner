{
  "module": {
    "id": "backend-testing",
    "title": "Backend: Testing and Quality",
    "description": "Testing backend applications: unit tests, integration tests, mocking and best practices",
    "icon": "TestTube",
    "requiredXp": 1500,
    "color": "from-emerald-500 to-teal-600",
    "courseId": "node-express"
  },
  "lessons": [
    {
      "id": "testing-fundamentals",
      "moduleId": "backend-testing",
      "title": "Testing Fundamentals",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Test pyramid: Unit (70%) → Integration (20%) → E2E (10%)\n- Vitest is the modern alternative to Jest for Node.js\n- Tests must be fast, isolated, and deterministic\n- Each test should focus on a single behavior\n\n---\n\n# Testing Fundamentals\n\n## The Test Pyramid\n\nThe test pyramid guides how to distribute your testing efforts:\n\n```\n        /\\\n       /  \\  E2E Tests (10%) - Slow, expensive, high confidence\n      /____\\\n     /      \\  Integration Tests (20%) - Medium speed, component interactions\n    /________\\\n   /          \\  Unit Tests (70%) - Fast, cheap, focused\n  /____________\\\n```\n\n### 1. Unit Tests (70%)\nTest isolated functions in memory without external dependencies.\n\n**Characteristics:**\n- Fast execution (milliseconds)\n- No network calls, no database\n- Test one function/module at a time\n- High number of tests\n\n```javascript\n// utils/validation.js\nexport function validateEmail(email) {\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return regex.test(email);\n}\n\nexport function validatePassword(password) {\n  return password.length >= 8 && /[A-Z]/.test(password);\n}\n```\n\n```javascript\n// utils/validation.test.js\nimport { describe, it, expect } from 'vitest';\nimport { validateEmail, validatePassword } from './validation';\n\ndescribe('validateEmail', () => {\n  it('should return true for valid email', () => {\n    expect(validateEmail('user@example.com')).toBe(true);\n    expect(validateEmail('test+tag@domain.co.uk')).toBe(true);\n  });\n  \n  it('should return false for invalid email', () => {\n    expect(validateEmail('not-an-email')).toBe(false);\n    expect(validateEmail('')).toBe(false);\n    expect(validateEmail('@example.com')).toBe(false);\n    expect(validateEmail('user@')).toBe(false);\n  });\n});\n\ndescribe('validatePassword', () => {\n  it('should require minimum 8 characters', () => {\n    expect(validatePassword('Short1')).toBe(false);\n    expect(validatePassword('LongEnough1')).toBe(true);\n  });\n  \n  it('should require at least one uppercase letter', () => {\n    expect(validatePassword('lowercase1')).toBe(false);\n    expect(validatePassword('Uppercase1')).toBe(true);\n  });\n});\n```\n\n### 2. Integration Tests (20%)\nTest how multiple components work together.\n\n**Characteristics:**\n- Test database queries, API endpoints\n- Verify component interactions\n- Slower than unit tests\n- Test real dependencies (test database)\n\n```javascript\n// services/userService.test.js\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport { createUser, getUserById } from './userService';\nimport { db } from '../database/connection';\n\ndescribe('UserService Integration', () => {\n  beforeAll(async () => {\n    await db.migrate.latest();\n  });\n  \n  afterAll(async () => {\n    await db.destroy();\n  });\n  \n  it('should create and retrieve a user', async () => {\n    const userData = { name: 'John', email: 'john@example.com' };\n    const created = await createUser(userData);\n    \n    expect(created.id).toBeDefined();\n    expect(created.name).toBe(userData.name);\n    \n    const retrieved = await getUserById(created.id);\n    expect(retrieved.email).toBe(userData.email);\n  });\n});\n```\n\n### 3. E2E Tests (10%)\nTest the complete application flow like a real user.\n\n**Characteristics:**\n- Test through the UI or API like a real client\n- Cover critical user journeys\n- Slowest and most expensive\n- Highest confidence\n\n```javascript\n// e2e/auth.flow.test.js\nimport { describe, it, expect } from 'vitest';\nimport request from 'supertest';\nimport app from '../app';\n\ndescribe('Authentication Flow', () => {\n  it('should complete full registration and login flow', async () => {\n    // Register\n    const registerRes = await request(app)\n      .post('/api/auth/register')\n      .send({\n        name: 'Test User',\n        email: 'test@example.com',\n        password: 'SecurePass123'\n      })\n      .expect(201);\n    \n    expect(registerRes.body.user.email).toBe('test@example.com');\n    \n    // Login\n    const loginRes = await request(app)\n      .post('/api/auth/login')\n      .send({\n        email: 'test@example.com',\n        password: 'SecurePass123'\n      })\n      .expect(200);\n    \n    expect(loginRes.body.token).toBeDefined();\n    \n    // Access protected route\n    await request(app)\n      .get('/api/user/profile')\n      .set('Authorization', `Bearer ${loginRes.body.token}`)\n      .expect(200);\n  });\n});\n```\n\n## Test Runners: Jest vs Vitest\n\n### Jest (The Classic)\n\n```bash\nnpm install --save-dev jest supertest @types/jest\n```\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\"\n  }\n}\n```\n\n**Pros:**\n- Most popular, extensive community\n- Built-in mocking, coverage, snapshots\n- Well-documented\n\n**Cons:**\n- Slower than Vitest\n- ESM support can be tricky\n\n### Vitest (The Modern Choice)\n\n```bash\nnpm install --save-dev vitest supertest\n```\n\n```javascript\n// vitest.config.js\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    coverage: {\n      reporter: ['text', 'json', 'html']\n    }\n  }\n});\n```\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"test:run\": \"vitest run\",\n    \"test:coverage\": \"vitest run --coverage\"\n  }\n}\n```\n\n**Pros:**\n- Fast (uses Vite's bundler)\n- Native ESM support\n- Compatible with Jest API\n- Better TypeScript support\n- Watch mode is instant\n\n**Cons:**\n- Newer ecosystem\n- Some Jest plugins don't work\n\n## Writing Good Tests\n\n### AAA Pattern (Arrange, Act, Assert)\n\n```javascript\nit('should calculate total price with tax', () => {\n  // Arrange\n  const items = [{ price: 100 }, { price: 50 }];\n  const taxRate = 0.2;\n  \n  // Act\n  const total = calculateTotal(items, taxRate);\n  \n  // Assert\n  expect(total).toBe(180); // (100 + 50) * 1.2\n});\n```\n\n### Test Naming\n\n```javascript\n// Bad - describes implementation\nit('should call the calculate function', () => { });\n\n// Good - describes behavior\nit('should return discounted price for premium members', () => { });\nit('should throw error when email is invalid', () => { });\n```\n\n### One Assertion Per Test (Usually)\n\n```javascript\n// Avoid - testing too much\nit('should handle user creation', async () => {\n  const user = await createUser(data);\n  expect(user.id).toBeDefined();\n  expect(user.name).toBe(data.name);\n  expect(user.createdAt).toBeInstanceOf(Date);\n  expect(await getUserCount()).toBe(1);\n});\n\n// Better - split into focused tests\ndescribe('createUser', () => {\n  it('should assign an ID to new user', async () => {\n    const user = await createUser(data);\n    expect(user.id).toBeDefined();\n  });\n  \n  it('should save user with correct data', async () => {\n    const user = await createUser(data);\n    expect(user.name).toBe(data.name);\n  });\n});\n```",
      "codeExample": "// vitest.config.js\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    setupFiles: ['./tests/setup.js'],\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      exclude: ['node_modules/', 'tests/']\n    }\n  }\n});"
    },
    {
      "id": "testing-express-routes",
      "moduleId": "backend-testing",
      "title": "Testing Express Routes",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Supertest tests HTTP endpoints without starting a server\n- Test status codes, response body, and headers\n- Mock middleware (auth) to test routes in isolation\n- Test both success and error cases\n\n---\n\n# Testing Express Routes with Supertest\n\nSupertest allows you to test Express routes by making HTTP requests without actually starting a server on a port.\n\n## Setup\n\n```bash\nnpm install --save-dev supertest @types/supertest\n```\n\n```javascript\n// app.js - Your Express app\nimport express from 'express';\nconst app = express();\n\napp.use(express.json());\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok', timestamp: new Date().toISOString() });\n});\n\nexport default app;\n```\n\n```javascript\n// server.js - Start the server separately\nimport app from './app.js';\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```\n\n## Basic Route Testing\n\n```javascript\n// routes/health.test.js\nimport { describe, it, expect } from 'vitest';\nimport request from 'supertest';\nimport app from '../app';\n\ndescribe('GET /health', () => {\n  it('should return health status', async () => {\n    const res = await request(app)\n      .get('/health')\n      .expect('Content-Type', /json/)\n      .expect(200);\n    \n    expect(res.body.status).toBe('ok');\n    expect(res.body.timestamp).toBeDefined();\n  });\n});\n```\n\n## Testing CRUD Operations\n\n```javascript\n// routes/users.js\nimport { Router } from 'express';\n\nconst router = Router();\nconst users = [];\n\nrouter.get('/', (req, res) => {\n  res.json({ data: users });\n});\n\nrouter.get('/:id', (req, res) => {\n  const user = users.find(u => u.id === req.params.id);\n  if (!user) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  res.json({ data: user });\n});\n\nrouter.post('/', (req, res) => {\n  const { name, email } = req.body;\n  \n  if (!name || !email) {\n    return res.status(400).json({ error: 'Name and email required' });\n  }\n  \n  const user = {\n    id: String(users.length + 1),\n    name,\n    email\n  };\n  \n  users.push(user);\n  res.status(201).json({ data: user });\n});\n\nrouter.put('/:id', (req, res) => {\n  const user = users.find(u => u.id === req.params.id);\n  if (!user) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  \n  Object.assign(user, req.body);\n  res.json({ data: user });\n});\n\nrouter.delete('/:id', (req, res) => {\n  const index = users.findIndex(u => u.id === req.params.id);\n  if (index === -1) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  \n  users.splice(index, 1);\n  res.status(204).send();\n});\n\nexport default router;\n```\n\n```javascript\n// routes/users.test.js\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport request from 'supertest';\nimport app from '../app';\n\ndescribe('Users API', () => {\n  // Reset users before each test\n  beforeEach(() => {\n    // Clear users array or reset database\n  });\n  \n  describe('GET /api/users', () => {\n    it('should return empty array when no users', async () => {\n      const res = await request(app)\n        .get('/api/users')\n        .expect(200);\n      \n      expect(res.body.data).toEqual([]);\n    });\n  });\n  \n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      const userData = { name: 'John', email: 'john@example.com' };\n      \n      const res = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(201);\n      \n      expect(res.body.data).toMatchObject(userData);\n      expect(res.body.data.id).toBeDefined();\n    });\n    \n    it('should return 400 when name is missing', async () => {\n      const res = await request(app)\n        .post('/api/users')\n        .send({ email: 'john@example.com' })\n        .expect(400);\n      \n      expect(res.body.error).toBe('Name and email required');\n    });\n    \n    it('should return 400 when email is missing', async () => {\n      const res = await request(app)\n        .post('/api/users')\n        .send({ name: 'John' })\n        .expect(400);\n      \n      expect(res.body.error).toBe('Name and email required');\n    });\n  });\n  \n  describe('GET /api/users/:id', () => {\n    it('should return user by id', async () => {\n      // First create a user\n      const createRes = await request(app)\n        .post('/api/users')\n        .send({ name: 'Jane', email: 'jane@example.com' });\n      \n      const userId = createRes.body.data.id;\n      \n      // Then get it\n      const res = await request(app)\n        .get(`/api/users/${userId}`)\n        .expect(200);\n      \n      expect(res.body.data.name).toBe('Jane');\n    });\n    \n    it('should return 404 for non-existent user', async () => {\n      const res = await request(app)\n        .get('/api/users/999')\n        .expect(404);\n      \n      expect(res.body.error).toBe('User not found');\n    });\n  });\n  \n  describe('PUT /api/users/:id', () => {\n    it('should update user', async () => {\n      const createRes = await request(app)\n        .post('/api/users')\n        .send({ name: 'Old Name', email: 'old@example.com' });\n      \n      const userId = createRes.body.data.id;\n      \n      const res = await request(app)\n        .put(`/api/users/${userId}`)\n        .send({ name: 'New Name' })\n        .expect(200);\n      \n      expect(res.body.data.name).toBe('New Name');\n      expect(res.body.data.email).toBe('old@example.com');\n    });\n  });\n  \n  describe('DELETE /api/users/:id', () => {\n    it('should delete user and return 204', async () => {\n      const createRes = await request(app)\n        .post('/api/users')\n        .send({ name: 'To Delete', email: 'delete@example.com' });\n      \n      const userId = createRes.body.data.id;\n      \n      await request(app)\n        .delete(`/api/users/${userId}`)\n        .expect(204);\n      \n      // Verify deletion\n      await request(app)\n        .get(`/api/users/${userId}`)\n        .expect(404);\n    });\n  });\n});\n```\n\n## Testing with Query Parameters\n\n```javascript\n// routes/products.js\nrouter.get('/', (req, res) => {\n  const { category, minPrice, maxPrice, sort = 'name' } = req.query;\n  \n  let products = getAllProducts();\n  \n  if (category) {\n    products = products.filter(p => p.category === category);\n  }\n  \n  if (minPrice) {\n    products = products.filter(p => p.price >= parseFloat(minPrice));\n  }\n  \n  if (maxPrice) {\n    products = products.filter(p => p.price <= parseFloat(maxPrice));\n  }\n  \n  products.sort((a, b) => a[sort].localeCompare(b[sort]));\n  \n  res.json({ data: products, count: products.length });\n});\n```\n\n```javascript\n// routes/products.test.js\ndescribe('GET /api/products', () => {\n  it('should filter by category', async () => {\n    const res = await request(app)\n      .get('/api/products')\n      .query({ category: 'electronics' })\n      .expect(200);\n    \n    expect(res.body.data.every(p => p.category === 'electronics')).toBe(true);\n  });\n  \n  it('should filter by price range', async () => {\n    const res = await request(app)\n      .get('/api/products')\n      .query({ minPrice: '10', maxPrice: '50' })\n      .expect(200);\n    \n    res.body.data.forEach(product => {\n      expect(product.price).toBeGreaterThanOrEqual(10);\n      expect(product.price).toBeLessThanOrEqual(50);\n    });\n  });\n  \n  it('should sort by specified field', async () => {\n    const res = await request(app)\n      .get('/api/products')\n      .query({ sort: 'price' })\n      .expect(200);\n    \n    const prices = res.body.data.map(p => p.price);\n    expect(prices).toEqual([...prices].sort((a, b) => a - b));\n  });\n});\n```\n\n## Testing Error Handling\n\n```javascript\n// middleware/errorHandler.js\nexport const errorHandler = (err, req, res, next) => {\n  console.error(err.stack);\n  \n  if (err.name === 'ValidationError') {\n    return res.status(400).json({\n      error: 'Validation Error',\n      details: err.message\n    });\n  }\n  \n  if (err.name === 'UnauthorizedError') {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  res.status(500).json({ error: 'Internal Server Error' });\n};\n```\n\n```javascript\n// routes/error.test.js\ndescribe('Error Handling', () => {\n  it('should handle validation errors with 400', async () => {\n    const res = await request(app)\n      .post('/api/users')\n      .send({ invalid: 'data' })\n      .expect(400);\n    \n    expect(res.body.error).toBe('Validation Error');\n  });\n  \n  it('should handle unauthorized with 401', async () => {\n    const res = await request(app)\n      .get('/api/admin/users')\n      .expect(401);\n    \n    expect(res.body.error).toBe('Unauthorized');\n  });\n  \n  it('should handle not found with 404', async () => {\n    const res = await request(app)\n      .get('/api/nonexistent')\n      .expect(404);\n    \n    expect(res.body.error).toBe('Not Found');\n  });\n});\n```",
      "codeExample": "// Example: Testing with Supertest\nimport { describe, it, expect } from 'vitest';\nimport request from 'supertest';\nimport app from '../app';\n\ndescribe('API Routes', () => {\n  it('GET /api/users returns list', async () => {\n    const res = await request(app)\n      .get('/api/users')\n      .expect(200)\n      .expect('Content-Type', /json/);\n    \n    expect(res.body.data).toBeInstanceOf(Array);\n  });\n  \n  it('POST /api/users creates user', async () => {\n    const res = await request(app)\n      .post('/api/users')\n      .send({ name: 'John', email: 'john@example.com' })\n      .expect(201);\n    \n    expect(res.body.data.name).toBe('John');\n  });\n});"
    },
    {
      "id": "testing-mocking-spies",
      "moduleId": "backend-testing",
      "title": "Mocking & Spies",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Mock external dependencies to isolate the code under test\n- Use spies to verify function calls without changing behavior\n- Mock databases, HTTP clients, and external APIs\n- Reset mocks between tests to avoid interference\n\n---\n\n# Mocking and Spies\n\nMocking allows you to replace real dependencies with fake implementations, making tests faster and more reliable.\n\n## Why Mock?\n\n```\nReal Dependencies          Mocked Dependencies\n─────────────────          ───────────────────\nSlow (network calls)       Fast (in-memory)\nFlaky (external services)  Reliable (controlled)\nHard to set up             Easy to configure\nNon-deterministic          Predictable\n```\n\n## Vitest Mocking Basics\n\n### Mocking Functions\n\n```javascript\n// utils/mocks.test.js\nimport { describe, it, expect, vi } from 'vitest';\n\ndescribe('Mocking Functions', () => {\n  it('should create a mock function', () => {\n    const mockFn = vi.fn();\n    \n    mockFn('arg1', 'arg2');\n    mockFn('arg3');\n    \n    // Check calls\n    expect(mockFn).toHaveBeenCalled();\n    expect(mockFn).toHaveBeenCalledTimes(2);\n    expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');\n    expect(mockFn).toHaveBeenNthCalledWith(2, 'arg3');\n  });\n  \n  it('should return mock values', () => {\n    const mockFn = vi.fn()\n      .mockReturnValue('default')\n      .mockReturnValueOnce('first')\n      .mockReturnValueOnce('second');\n    \n    expect(mockFn()).toBe('first');\n    expect(mockFn()).toBe('second');\n    expect(mockFn()).toBe('default');\n  });\n  \n  it('should mock async functions', async () => {\n    const mockAsync = vi.fn().mockResolvedValue({ id: 1, name: 'John' });\n    \n    const result = await mockAsync();\n    expect(result).toEqual({ id: 1, name: 'John' });\n  });\n  \n  it('should mock rejections', async () => {\n    const mockAsync = vi.fn().mockRejectedValue(new Error('Network error'));\n    \n    await expect(mockAsync()).rejects.toThrow('Network error');\n  });\n});\n```\n\n### Mocking Modules\n\n```javascript\n// services/email.js\nimport nodemailer from 'nodemailer';\n\nexport async function sendEmail(to, subject, body) {\n  const transporter = nodemailer.createTransporter({\n    host: 'smtp.example.com',\n    auth: { user: process.env.EMAIL_USER, pass: process.env.EMAIL_PASS }\n  });\n  \n  return transporter.sendMail({\n    from: process.env.EMAIL_FROM,\n    to,\n    subject,\n    html: body\n  });\n}\n```\n\n```javascript\n// services/email.test.js\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\n\n// Mock the entire nodemailer module\nvi.mock('nodemailer', () => ({\n  default: {\n    createTransporter: vi.fn().mockReturnValue({\n      sendMail: vi.fn().mockResolvedValue({ messageId: '123' })\n    })\n  }\n}));\n\nimport nodemailer from 'nodemailer';\nimport { sendEmail } from './email';\n\ndescribe('sendEmail', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n  \n  it('should send email with correct parameters', async () => {\n    const mockSendMail = nodemailer.createTransporter().sendMail;\n    \n    await sendEmail('user@example.com', 'Welcome', '<h1>Hello!</h1>');\n    \n    expect(mockSendMail).toHaveBeenCalledWith({\n      from: expect.any(String),\n      to: 'user@example.com',\n      subject: 'Welcome',\n      html: '<h1>Hello!</h1>'\n    });\n  });\n  \n  it('should handle email send failures', async () => {\n    const mockSendMail = nodemailer.createTransporter().sendMail;\n    mockSendMail.mockRejectedValueOnce(new Error('SMTP error'));\n    \n    await expect(sendEmail('user@example.com', 'Test', 'Body'))\n      .rejects.toThrow('SMTP error');\n  });\n});\n```\n\n## Mocking External APIs\n\n```javascript\n// services/weather.js\nimport axios from 'axios';\n\nexport async function getWeather(city) {\n  const response = await axios.get(\n    `https://api.weather.com/v1/current?city=${city}&appid=${process.env.WEATHER_API_KEY}`\n  );\n  return {\n    temperature: response.data.main.temp,\n    description: response.data.weather[0].description,\n    humidity: response.data.main.humidity\n  };\n}\n```\n\n```javascript\n// services/weather.test.js\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport axios from 'axios';\nimport { getWeather } from './weather';\n\nvi.mock('axios');\n\ndescribe('getWeather', () => {\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n  \n  it('should return weather data for a city', async () => {\n    const mockWeatherData = {\n      data: {\n        main: { temp: 25, humidity: 60 },\n        weather: [{ description: 'clear sky' }]\n      }\n    };\n    \n    axios.get.mockResolvedValue(mockWeatherData);\n    \n    const result = await getWeather('Paris');\n    \n    expect(result).toEqual({\n      temperature: 25,\n      description: 'clear sky',\n      humidity: 60\n    });\n    \n    expect(axios.get).toHaveBeenCalledWith(\n      expect.stringContaining('city=Paris')\n    );\n  });\n  \n  it('should handle API errors', async () => {\n    axios.get.mockRejectedValue(new Error('API limit exceeded'));\n    \n    await expect(getWeather('Paris')).rejects.toThrow('API limit exceeded');\n  });\n  \n  it('should handle malformed responses', async () => {\n    axios.get.mockResolvedValue({\n      data: { main: {}, weather: [] }\n    });\n    \n    const result = await getWeather('Paris');\n    expect(result.temperature).toBeUndefined();\n  });\n});\n```\n\n## Mocking Databases\n\n```javascript\n// services/userService.js\nimport { db } from '../database/connection';\n\nexport async function createUser(userData) {\n  const [user] = await db('users')\n    .insert(userData)\n    .returning('*');\n  return user;\n}\n\nexport async function findUserByEmail(email) {\n  return db('users').where({ email }).first();\n}\n```\n\n```javascript\n// services/userService.test.js\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\n\n// Mock the database module\nvi.mock('../database/connection', () => ({\n  db: vi.fn()\n}));\n\nimport { db } from '../database/connection';\nimport { createUser, findUserByEmail } from './userService';\n\ndescribe('UserService', () => {\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n  \n  describe('createUser', () => {\n    it('should insert user and return created user', async () => {\n      const mockUser = { id: 1, name: 'John', email: 'john@example.com' };\n      \n      // Mock the knex query builder chain\n      const insertMock = vi.fn().mockReturnThis();\n      const returningMock = vi.fn().mockResolvedValue([mockUser]);\n      \n      db.mockReturnValue({\n        insert: insertMock,\n        returning: returningMock\n      });\n      \n      const result = await createUser({ name: 'John', email: 'john@example.com' });\n      \n      expect(result).toEqual(mockUser);\n      expect(insertMock).toHaveBeenCalledWith({ name: 'John', email: 'john@example.com' });\n    });\n  });\n  \n  describe('findUserByEmail', () => {\n    it('should find user by email', async () => {\n      const mockUser = { id: 1, name: 'John', email: 'john@example.com' };\n      \n      const whereMock = vi.fn().mockReturnThis();\n      const firstMock = vi.fn().mockResolvedValue(mockUser);\n      \n      db.mockReturnValue({\n        where: whereMock,\n        first: firstMock\n      });\n      \n      const result = await findUserByEmail('john@example.com');\n      \n      expect(result).toEqual(mockUser);\n      expect(whereMock).toHaveBeenCalledWith({ email: 'john@example.com' });\n    });\n    \n    it('should return undefined when user not found', async () => {\n      const whereMock = vi.fn().mockReturnThis();\n      const firstMock = vi.fn().mockResolvedValue(undefined);\n      \n      db.mockReturnValue({\n        where: whereMock,\n        first: firstMock\n      });\n      \n      const result = await findUserByEmail('nonexistent@example.com');\n      expect(result).toBeUndefined();\n    });\n  });\n});\n```\n\n## Spies\n\nSpies let you observe function calls without changing behavior.\n\n```javascript\n// utils/logger.js\nexport const logger = {\n  info: (msg) => console.log(`[INFO] ${msg}`),\n  error: (msg) => console.error(`[ERROR] ${msg}`),\n  warn: (msg) => console.warn(`[WARN] ${msg}`)\n};\n```\n\n```javascript\n// services/orderService.js\nimport { logger } from '../utils/logger';\n\nexport async function processOrder(orderData) {\n  logger.info(`Processing order ${orderData.id}`);\n  \n  try {\n    // Process order...\n    logger.info(`Order ${orderData.id} processed successfully`);\n    return { success: true };\n  } catch (error) {\n    logger.error(`Order ${orderData.id} failed: ${error.message}`);\n    throw error;\n  }\n}\n```\n\n```javascript\n// services/orderService.test.js\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { logger } from '../utils/logger';\nimport { processOrder } from './orderService';\n\ndescribe('processOrder', () => {\n  beforeEach(() => {\n    // Spy on logger methods\n    vi.spyOn(logger, 'info');\n    vi.spyOn(logger, 'error');\n  });\n  \n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n  \n  it('should log info messages during processing', async () => {\n    await processOrder({ id: '123', items: [] });\n    \n    expect(logger.info).toHaveBeenCalledTimes(2);\n    expect(logger.info).toHaveBeenNthCalledWith(1, 'Processing order 123');\n    expect(logger.info).toHaveBeenNthCalledWith(2, 'Order 123 processed successfully');\n  });\n  \n  it('should log error when processing fails', async () => {\n    // Force an error\n    const failingOrder = {\n      id: '456',\n      get items() { throw new Error('Invalid items'); }\n    };\n    \n    await expect(processOrder(failingOrder)).rejects.toThrow();\n    \n    expect(logger.error).toHaveBeenCalled();\n    expect(logger.error.mock.calls[0][0]).toContain('Order 456 failed');\n  });\n});\n```\n\n## Mocking File System\n\n```javascript\n// services/fileProcessor.js\nimport fs from 'fs/promises';\nimport path from 'path';\n\nexport async function readConfigFile(configPath) {\n  const fullPath = path.resolve(configPath);\n  const content = await fs.readFile(fullPath, 'utf-8');\n  return JSON.parse(content);\n}\n\nexport async function writeOutputFile(outputPath, data) {\n  await fs.writeFile(outputPath, JSON.stringify(data, null, 2));\n}\n```\n\n```javascript\n// services/fileProcessor.test.js\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport fs from 'fs/promises';\nimport { readConfigFile, writeOutputFile } from './fileProcessor';\n\nvi.mock('fs/promises');\n\ndescribe('FileProcessor', () => {\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n  \n  describe('readConfigFile', () => {\n    it('should read and parse config file', async () => {\n      const mockConfig = { apiKey: 'secret', endpoint: 'https://api.example.com' };\n      fs.readFile.mockResolvedValue(JSON.stringify(mockConfig));\n      \n      const result = await readConfigFile('./config.json');\n      \n      expect(result).toEqual(mockConfig);\n      expect(fs.readFile).toHaveBeenCalledWith(\n        expect.stringContaining('config.json'),\n        'utf-8'\n      );\n    });\n    \n    it('should throw on invalid JSON', async () => {\n      fs.readFile.mockResolvedValue('not valid json');\n      \n      await expect(readConfigFile('./config.json')).rejects.toThrow(SyntaxError);\n    });\n  });\n  \n  describe('writeOutputFile', () => {\n    it('should write formatted JSON', async () => {\n      const data = { status: 'success', count: 42 };\n      \n      await writeOutputFile('./output.json', data);\n      \n      expect(fs.writeFile).toHaveBeenCalledWith(\n        expect.stringContaining('output.json'),\n        JSON.stringify(data, null, 2)\n      );\n    });\n  });\n});\n```",
      "codeExample": "// Mocking example\nimport { vi, describe, it, expect } from 'vitest';\n\n// Mock a module\nvi.mock('./database', () => ({\n  query: vi.fn().mockResolvedValue({ rows: [] })\n}));\n\n// Mock function\nconst mockFn = vi.fn()\n  .mockReturnValue('default')\n  .mockReturnValueOnce('first')\n  .mockReturnValueOnce('second');\n\n// Spy on existing function\nconst spy = vi.spyOn(console, 'log');\n\n// Verify calls\nexpect(mockFn).toHaveBeenCalledWith('arg');\nexpect(mockFn).toHaveBeenCalledTimes(2);"
    },
    {
      "id": "testing-database-patterns",
      "moduleId": "backend-testing",
      "title": "Test Database Patterns",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Use in-memory SQLite or test containers for integration tests\n- Set up fixtures (test data) before each test\n- Clean up database state after tests to avoid interference\n- Run tests in transactions that rollback automatically\n\n---\n\n# Test Database Patterns\n\nTesting with real databases requires careful setup and cleanup to ensure tests are isolated and repeatable.\n\n## Pattern 1: In-Memory SQLite\n\nBest for: Fast unit/integration tests, local development\n\n```javascript\n// database/config.js\nimport knex from 'knex';\n\nconst config = {\n  development: {\n    client: 'sqlite3',\n    connection: {\n      filename: './dev.sqlite3'\n    },\n    useNullAsDefault: true\n  },\n  test: {\n    client: 'sqlite3',\n    connection: ':memory:', // In-memory database\n    useNullAsDefault: true,\n    migrations: {\n      directory: './migrations'\n    },\n    seeds: {\n      directory: './seeds'\n    }\n  }\n};\n\nexport const db = knex(config[process.env.NODE_ENV || 'development']);\n```\n\n```javascript\n// tests/setup.js\nimport { db } from '../database/config';\n\n// Global test setup\nexport async function setupTestDB() {\n  // Run migrations on in-memory database\n  await db.migrate.latest();\n}\n\nexport async function cleanupTestDB() {\n  // Rollback all migrations\n  await db.migrate.rollback(undefined, true);\n}\n\nexport async function resetTestDB() {\n  // Clean all tables but keep schema\n  const tables = await db('sqlite_master')\n    .where('type', 'table')\n    .whereNot('name', 'like', 'sqlite_%')\n    .pluck('name');\n  \n  for (const table of tables) {\n    await db(table).del();\n  }\n}\n```\n\n```javascript\n// tests/integration/users.test.js\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { db, setupTestDB, resetTestDB, cleanupTestDB } from '../setup';\nimport { createUser, getUserById } from '../../services/userService';\n\ndescribe('User Integration Tests', () => {\n  beforeAll(async () => {\n    await setupTestDB();\n  });\n  \n  afterAll(async () => {\n    await cleanupTestDB();\n    await db.destroy();\n  });\n  \n  beforeEach(async () => {\n    await resetTestDB();\n  });\n  \n  it('should create and retrieve a user', async () => {\n    const userData = { name: 'John', email: 'john@example.com' };\n    \n    const created = await createUser(userData);\n    expect(created.id).toBeDefined();\n    \n    const retrieved = await getUserById(created.id);\n    expect(retrieved).toMatchObject(userData);\n  });\n  \n  it('should handle duplicate emails', async () => {\n    const userData = { name: 'John', email: 'john@example.com' };\n    await createUser(userData);\n    \n    await expect(createUser(userData)).rejects.toThrow();\n  });\n});\n```\n\n## Pattern 2: Transaction Rollback\n\nBest for: True test isolation, fast cleanup\n\n```javascript\n// tests/helpers/transaction.js\nimport { db } from '../../database/config';\n\nexport async function withTransaction(callback) {\n  const trx = await db.transaction();\n  \n  try {\n    // Replace db with transaction for this test\n    const result = await callback(trx);\n    await trx.rollback(); // Always rollback\n    return result;\n  } catch (error) {\n    await trx.rollback();\n    throw error;\n  }\n}\n```\n\n```javascript\n// services/userService.js (modified to accept transaction)\nexport async function createUser(userData, trx = db) {\n  const [user] = await trx('users')\n    .insert(userData)\n    .returning('*');\n  return user;\n}\n```\n\n```javascript\n// tests/integration/users.transaction.test.js\nimport { describe, it, expect } from 'vitest';\nimport { withTransaction } from '../helpers/transaction';\nimport { createUser, getUserById } from '../../services/userService';\n\ndescribe('User Tests with Transactions', () => {\n  it('should create user within transaction', async () => {\n    await withTransaction(async (trx) => {\n      const userData = { name: 'Jane', email: 'jane@example.com' };\n      \n      const created = await createUser(userData, trx);\n      expect(created.id).toBeDefined();\n      \n      const retrieved = await getUserById(created.id, trx);\n      expect(retrieved.email).toBe(userData.email);\n    });\n  });\n  \n  it('should not see data from other tests', async () => {\n    await withTransaction(async (trx) => {\n      const users = await trx('users').select('*');\n      expect(users).toHaveLength(0); // Clean slate\n    });\n  });\n});\n```\n\n## Pattern 3: Test Fixtures\n\nFixtures provide consistent test data.\n\n```javascript\n// tests/fixtures/users.js\nexport const userFixtures = {\n  admin: {\n    name: 'Admin User',\n    email: 'admin@example.com',\n    role: 'admin',\n    password: 'hashed_admin_pass'\n  },\n  regular: {\n    name: 'Regular User',\n    email: 'user@example.com',\n    role: 'user',\n    password: 'hashed_user_pass'\n  },\n  premium: {\n    name: 'Premium User',\n    email: 'premium@example.com',\n    role: 'user',\n    subscription: 'premium',\n    password: 'hashed_premium_pass'\n  }\n};\n\nexport async function loadUserFixtures(db, users = ['admin', 'regular']) {\n  const userData = users.map(key => userFixtures[key]);\n  return db('users').insert(userData).returning('*');\n}\n```\n\n```javascript\n// tests/fixtures/products.js\nexport const productFixtures = [\n  {\n    name: 'Basic Widget',\n    price: 9.99,\n    category: 'widgets',\n    stock: 100\n  },\n  {\n    name: 'Premium Widget',\n    price: 29.99,\n    category: 'widgets',\n    stock: 50\n  },\n  {\n    name: 'Super Gadget',\n    price: 99.99,\n    category: 'gadgets',\n    stock: 10\n  }\n];\n\nexport async function loadProductFixtures(db, count = 3) {\n  const products = productFixtures.slice(0, count);\n  return db('products').insert(products).returning('*');\n}\n```\n\n```javascript\n// tests/fixtures/index.js\nimport { loadUserFixtures } from './users';\nimport { loadProductFixtures } from './products';\n\nexport async function loadAllFixtures(db) {\n  const users = await loadUserFixtures(db);\n  const products = await loadProductFixtures(db);\n  return { users, products };\n}\n\nexport async function clearAllTables(db) {\n  await db('order_items').del();\n  await db('orders').del();\n  await db('products').del();\n  await db('users').del();\n}\n```\n\n```javascript\n// tests/integration/orders.test.js\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { db } from '../../database/config';\nimport { loadUserFixtures, loadProductFixtures } from '../fixtures';\nimport { clearAllTables } from '../fixtures';\nimport { createOrder } from '../../services/orderService';\n\ndescribe('Order Creation', () => {\n  beforeAll(async () => {\n    await db.migrate.latest();\n  });\n  \n  afterAll(async () => {\n    await db.destroy();\n  });\n  \n  beforeEach(async () => {\n    await clearAllTables(db);\n  });\n  \n  it('should create order with existing user and product', async () => {\n    // Load fixtures\n    const [user] = await loadUserFixtures(db, ['regular']);\n    const [product] = await loadProductFixtures(db, 1);\n    \n    // Test the service\n    const orderData = {\n      userId: user.id,\n      items: [{ productId: product.id, quantity: 2 }]\n    };\n    \n    const order = await createOrder(orderData);\n    \n    expect(order.userId).toBe(user.id);\n    expect(order.total).toBe(product.price * 2);\n    expect(order.status).toBe('pending');\n  });\n  \n  it('should apply discount for premium users', async () => {\n    const [premiumUser] = await loadUserFixtures(db, ['premium']);\n    const [product] = await loadProductFixtures(db, 1);\n    \n    const order = await createOrder({\n      userId: premiumUser.id,\n      items: [{ productId: product.id, quantity: 1 }]\n    });\n    \n    // Premium users get 10% off\n    expect(order.discount).toBe(product.price * 0.1);\n    expect(order.total).toBe(product.price * 0.9);\n  });\n});\n```\n\n## Pattern 4: Factory Functions\n\nMore flexible than static fixtures.\n\n```javascript\n// tests/factories/userFactory.js\nimport { faker } from '@faker-js/faker';\n\nlet userCounter = 0;\n\nexport function buildUser(overrides = {}) {\n  userCounter++;\n  \n  return {\n    name: faker.person.fullName(),\n    email: `test-${userCounter}@example.com`,\n    password: faker.internet.password(),\n    role: 'user',\n    createdAt: new Date(),\n    ...overrides\n  };\n}\n\nexport async function createUserInDB(db, overrides = {}) {\n  const userData = buildUser(overrides);\n  const [user] = await db('users').insert(userData).returning('*');\n  return user;\n}\n\nexport async function createManyUsers(db, count, overrides = {}) {\n  const users = Array.from({ length: count }, () => buildUser(overrides));\n  return db('users').insert(users).returning('*');\n}\n```\n\n```javascript\n// tests/integration/users.factory.test.js\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { db } from '../../database/config';\nimport { createUserInDB, createManyUsers } from '../factories/userFactory';\n\ndescribe('User Factory', () => {\n  beforeEach(async () => {\n    await db('users').del();\n  });\n  \n  it('should create user with fake data', async () => {\n    const user = await createUserInDB(db);\n    \n    expect(user.id).toBeDefined();\n    expect(user.email).toMatch(/test-\\d+@example\\.com/);\n    expect(user.name).toBeTruthy();\n  });\n  \n  it('should allow overriding specific fields', async () => {\n    const user = await createUserInDB(db, {\n      name: 'Custom Name',\n      role: 'admin'\n    });\n    \n    expect(user.name).toBe('Custom Name');\n    expect(user.role).toBe('admin');\n  });\n  \n  it('should create multiple users', async () => {\n    const users = await createManyUsers(db, 5);\n    expect(users).toHaveLength(5);\n    \n    // Each user has unique email\n    const emails = users.map(u => u.email);\n    expect(new Set(emails).size).toBe(5);\n  });\n});\n```\n\n## Pattern 5: Docker Test Containers\n\nBest for: Testing against real database (PostgreSQL, MySQL)\n\n```javascript\n// tests/setup-docker.js\nimport { GenericContainer } from 'testcontainers';\nimport { db } from '../database/config';\n\nlet container;\n\nexport async function startTestContainer() {\n  container = await new GenericContainer('postgres:15')\n    .withEnvironment({\n      POSTGRES_USER: 'test',\n      POSTGRES_PASSWORD: 'test',\n      POSTGRES_DB: 'testdb'\n    })\n    .withExposedPorts(5432)\n    .start();\n  \n  const port = container.getMappedPort(5432);\n  const host = container.getHost();\n  \n  // Update database config to use container\n  process.env.DATABASE_URL = `postgresql://test:test@${host}:${port}/testdb`;\n  \n  return container;\n}\n\nexport async function stopTestContainer() {\n  if (container) {\n    await container.stop();\n  }\n}\n```\n\n```javascript\n// vitest.config.js\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globalSetup: './tests/global-setup.js',\n    setupFiles: ['./tests/setup.js']\n  }\n});\n```\n\n```javascript\n// tests/global-setup.js\nimport { startTestContainer, stopTestContainer } from './setup-docker';\n\nexport async function setup() {\n  await startTestContainer();\n}\n\nexport async function teardown() {\n  await stopTestContainer();\n}\n```",
      "codeExample": "// Test database setup with transactions\nimport { db } from '../database/config';\n\nexport async function withTransaction(callback) {\n  const trx = await db.transaction();\n  try {\n    const result = await callback(trx);\n    await trx.rollback();\n    return result;\n  } catch (error) {\n    await trx.rollback();\n    throw error;\n  }\n}\n\n// Usage in tests\nit('should create user', async () => {\n  await withTransaction(async (trx) => {\n    const user = await createUser(data, trx);\n    expect(user.id).toBeDefined();\n  });\n});"
    }
  ],
  "exercises": []
}
