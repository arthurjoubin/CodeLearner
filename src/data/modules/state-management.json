{
  "module": {
    "id": "state-management",
    "title": "State Management Patterns",
    "description": "Compare and implement modern state management solutions for React",
    "icon": "Database",
    "requiredXp": 9000,
    "color": "from-cyan-500 to-blue-600",
    "courseId": "react"
  },
  "lessons": [
    {
      "id": "state-overview",
      "moduleId": "state-management",
      "title": "State Management Landscape",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Different state types: local, global, server, URL\n- Context API for simple global state\n- Redux for complex state logic\n- Zustand for lightweight global state\n- React Query for server state\n\n---\n\n# Understanding State Management\n\n## Types of State\n\n### 1. Local State\nComponent-specific state:\n\n```javascript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(c + 1)}>{count}</button>;\n}\n```\n\n### 2. Global State\nShared across multiple components:\n\n```javascript\n// Theme, user authentication, shopping cart\nconst [theme, setTheme] = useState('light');\nconst [user, setUser] = useState(null);\nconst [cart, setCart] = useState([]);\n```\n\n### 3. Server State\nData from external sources:\n\n```javascript\n// API data, cached responses, loading states\nconst { data, isLoading, error } = useQuery(['users'], fetchUsers);\n```\n\n### 4. URL State\nState in the URL:\n\n```javascript\n// /products?page=2&category=electronics\nconst [searchParams, setSearchParams] = useSearchParams();\n```\n\n## When to Use What\n\n**Use Local State When:**\n- Data is only needed by one component\n- No need to share between siblings\n- Form inputs (before submission)\n- UI state (isOpen, isLoading)\n\n**Use Context When:**\n- Need to share state with many components\n- Prop drilling becomes annoying (3+ levels)\n- Theme, auth state, user preferences\n- Relatively simple state updates\n\n**Use Redux/Zustand When:**\n- Complex state logic\n- Need time-travel debugging\n- Multiple sources of state updates\n- Middleware needs (logging, persistence)\n\n**Use React Query When:**\n- Caching API responses\n- Background updates\n- Pagination, infinite scroll\n- Optimistic updates\n\n## Solution Comparison\n\n| Feature | Context | Redux | Zustand | React Query |\n|---------|---------|-------|---------|-------------|\n| Learning Curve | Low | High | Low | Medium |\n| Boilerplate | Medium | High | Low | Low |\n| DevTools | Basic | Excellent | Good | Excellent |\n| Middleware | No | Yes | Yes | Built-in |\n| Bundle Size | ~0kb | ~11kb | ~1kb | ~12kb |\n| Best For | Simple global | Complex apps | Lightweight | Server data |\n\n## Common Patterns\n\n### The Provider Pattern\n\n```javascript\n// Wrap app with providers\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ReduxProvider store={store}>\n        <ThemeProvider>\n          <App />\n        </ThemeProvider>\n      </ReduxProvider>\n    </QueryClientProvider>\n  );\n}\n```\n\n### Composing State\n\n```javascript\n// Combine different solutions\nfunction Dashboard() {\n  // Server state with React Query\n  const { data: user } = useQuery(['user'], fetchUser);\n  \n  // Global state with Zustand\n  const sidebarOpen = useStore(state => state.sidebarOpen);\n  \n  // Local state\n  const [activeTab, setActiveTab] = useState('overview');\n  \n  return (...);\n}\n```\n\n## Anti-Patterns to Avoid\n\n❌ **Putting everything in global state**\n```javascript\n// BAD\nconst [inputValue, setInputValue] = useGlobalState('inputValue');\n\n// GOOD\nconst [inputValue, setInputValue] = useState('');\n```\n\n❌ **Duplicate state**\n```javascript\n// BAD\nconst [users, setUsers] = useState([]);\nconst [userCount, setUserCount] = useState(0); // Derived!\n\n// GOOD\nconst [users, setUsers] = useState([]);\nconst userCount = users.length; // Compute from source\n```\n\n❌ **Over-using Context for everything**\n```javascript\n// BAD - Context for every piece of state\n<ThemeContext>\n  <UserContext>\n    <CartContext>\n      <FilterContext>\n        <App />\n      </FilterContext>\n    </CartContext>\n  </UserContext>\n</ThemeContext>\n\n// GOOD - Use appropriate tool for each\n```"
    },
    {
      "id": "zustand-basics",
      "moduleId": "state-management",
      "title": "Zustand: Lightweight State",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Zustand is minimal, unopinionated state management\n- No providers needed\n- Simple API: create store, use in components\n- Supports middleware (persist, devtools)\n- Great TypeScript support\n\n---\n\n# Getting Started with Zustand\n\n## Installation\n\n```bash\nnpm install zustand\n```\n\n## Creating a Store\n\n```javascript\n// store.js\nimport { create } from 'zustand';\n\nexport const useStore = create((set, get) => ({\n  // State\n  count: 0,\n  user: null,\n  todos: [],\n  \n  // Actions\n  increment: () => set((state) => ({ count: state.count + 1 })),\n  decrement: () => set((state) => ({ count: state.count - 1 })),\n  setUser: (user) => set({ user }),\n  addTodo: (text) => set((state) => ({\n    todos: [...state.todos, { id: Date.now(), text, done: false }]\n  })),\n  toggleTodo: (id) => set((state) => ({\n    todos: state.todos.map(todo =>\n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    )\n  })),\n  \n  // Computed values\n  get completedTodos() {\n    return get().todos.filter(todo => todo.done);\n  },\n  \n  // Async actions\n  fetchUser: async (id) => {\n    const response = await fetch(`/api/users/${id}`);\n    const user = await response.json();\n    set({ user });\n  }\n}));\n```\n\n## Using in Components\n\n```javascript\n// Counter.js\nimport { useStore } from './store';\n\nfunction Counter() {\n  // Subscribe to specific state\n  const count = useStore(state => state.count);\n  const increment = useStore(state => state.increment);\n  \n  return (\n    <div>\n      <span>{count}</span>\n      <button onClick={increment}>+</button>\n    </div>\n  );\n}\n```\n\n```javascript\n// UserProfile.js\nfunction UserProfile() {\n  // Select multiple pieces of state\n  const { user, fetchUser } = useStore(state => ({\n    user: state.user,\n    fetchUser: state.fetchUser\n  }));\n  \n  useEffect(() => {\n    fetchUser(123);\n  }, [fetchUser]);\n  \n  if (!user) return <div>Loading...</div>;\n  \n  return <div>Hello, {user.name}</div>;\n}\n```\n\n## With TypeScript\n\n```typescript\n// store.ts\nimport { create } from 'zustand';\n\ninterface Todo {\n  id: number;\n  text: string;\n  done: boolean;\n}\n\ninterface Store {\n  todos: Todo[];\n  addTodo: (text: string) => void;\n  toggleTodo: (id: number) => void;\n  removeTodo: (id: number) => void;\n}\n\nexport const useStore = create<Store>((set) => ({\n  todos: [],\n  addTodo: (text) => set((state) => ({\n    todos: [...state.todos, { id: Date.now(), text, done: false }]\n  })),\n  toggleTodo: (id) => set((state) => ({\n    todos: state.todos.map(todo =>\n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    )\n  })),\n  removeTodo: (id) => set((state) => ({\n    todos: state.todos.filter(todo => todo.id !== id)\n  }))\n}));\n```\n\n## Middleware\n\n### DevTools\n\n```javascript\nimport { create } from 'zustand';\nimport { devtools } from 'zustand/middleware';\n\nexport const useStore = create(\n  devtools((set) => ({\n    count: 0,\n    increment: () => set((state) => ({ count: state.count + 1 }))\n  }),\n  { name: 'MyStore' }\n);\n```\n\n### Persistence\n\n```javascript\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nexport const useStore = create(\n  persist(\n    (set) => ({\n      theme: 'light',\n      setTheme: (theme) => set({ theme })\n    }),\n    {\n      name: 'app-storage', // localStorage key\n      partialize: (state) => ({ theme: state.theme }) // Only persist theme\n    }\n  )\n);\n```\n\n### Combined Middleware\n\n```javascript\nimport { create } from 'zustand';\nimport { devtools, persist } from 'zustand/middleware';\n\nexport const useStore = create(\n  devtools(\n    persist(\n      (set) => ({\n        // ... state\n      }),\n      { name: 'my-storage' }\n    ),\n    { name: 'MyStore' }\n  )\n);\n```\n\n## Best Practices\n\n**1. Keep stores focused:**\n```javascript\n// GOOD - Separate concerns\nconst useUserStore = create(...);\nconst useCartStore = create(...);\nconst useThemeStore = create(...);\n\n// BAD - One giant store\nconst useStore = create({ user, cart, theme, posts, comments, ... });\n```\n\n**2. Use selectors for performance:**\n```javascript\n// GOOD - Component only re-renders when count changes\nconst count = useStore(state => state.count);\n\n// BAD - Component re-renders when ANY state changes\nconst { count } = useStore();\n```\n\n**3. Split state and actions:**\n```javascript\n// Separate file for store logic\n// store/countStore.js\nexport const useCountStore = create((set) => ({\n  count: 0,\n  increment: () => set((state) => ({ count: state.count + 1 })),\n  decrement: () => set((state) => ({ count: state.count - 1 }))\n}));\n```"
    },
    {
      "id": "react-query",
      "moduleId": "state-management",
      "title": "React Query: Server State",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- React Query (TanStack Query) manages server state\n- Automatic caching and background updates\n- Handles loading, error, and success states\n- Built-in pagination and infinite scroll\n- Optimistic updates for better UX\n\n---\n\n# Mastering React Query\n\n## Setup\n\n```bash\nnpm install @tanstack/react-query\n```\n\n```javascript\n// App.js\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 1000 * 60 * 5, // 5 minutes\n      retry: 3,\n      refetchOnWindowFocus: false\n    }\n  }\n});\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <MyApp />\n    </QueryClientProvider>\n  );\n}\n```\n\n## Basic Queries\n\n```javascript\nimport { useQuery } from '@tanstack/react-query';\n\nfunction Users() {\n  const { data, isLoading, error } = useQuery({\n    queryKey: ['users'],\n    queryFn: async () => {\n      const response = await fetch('/api/users');\n      if (!response.ok) throw new Error('Failed to fetch');\n      return response.json();\n    }\n  });\n  \n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  \n  return (\n    <ul>\n      {data.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n## Query Keys\n\nQuery keys determine caching:\n\n```javascript\n// Simple key\nuseQuery({ queryKey: ['users'], ... });\n\n// With parameters\nuseQuery({\n  queryKey: ['users', userId], // ['users', 123]\n  queryFn: () => fetchUser(userId)\n});\n\n// Multiple parameters\nuseQuery({\n  queryKey: ['users', { status: 'active', page: 1 }],\n  queryFn: () => fetchUsers({ status: 'active', page: 1 })\n});\n```\n\n## Mutations\n\n```javascript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\n\nfunction AddUser() {\n  const queryClient = useQueryClient();\n  \n  const mutation = useMutation({\n    mutationFn: async (newUser) => {\n      const response = await fetch('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(newUser)\n      });\n      return response.json();\n    },\n    onSuccess: () => {\n      // Invalidate and refetch\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    },\n    onError: (error) => {\n      console.error('Failed to add user:', error);\n    }\n  });\n  \n  return (\n    <form onSubmit={(e) => {\n      e.preventDefault();\n      mutation.mutate({ name: 'John', email: 'john@example.com' });\n    }}>\n      <button type=\"submit\" disabled={mutation.isPending}\u003e\n        {mutation.isPending ? 'Adding...' : 'Add User'}\n      </button>\n    </form>\n  );\n}\n```\n\n## Pagination\n\n```javascript\nfunction PaginatedUsers() {\n  const [page, setPage] = useState(1);\n  \n  const { data, isLoading, isPlaceholderData } = useQuery({\n    queryKey: ['users', page],\n    queryFn: () => fetchUsers(page),\n    placeholderData: (previousData) => previousData // Keep old data while loading\n  });\n  \n  return (\n    <div>\n      {data?.users.map(user => (\n        <UserCard key={user.id} user={user} />\n      ))}\n      \n      <button\n        onClick={() => setPage(p => p - 1)}\n        disabled={page === 1}\n      \u003e\n        Previous\n      </button>\n      \n      <span>Page {page}</span>\n      \n      <button\n        onClick={() => setPage(p => p + 1)}\n        disabled={!data?.hasMore}\n      \u003e\n        Next\n      </button>\n    </div>\n  );\n}\n```\n\n## Infinite Scroll\n\n```javascript\nimport { useInfiniteQuery } from '@tanstack/react-query';\n\nfunction InfiniteUsers() {\n  const {\n    data,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage\n  } = useInfiniteQuery({\n    queryKey: ['users'],\n    queryFn: ({ pageParam = 1 }) => fetchUsers(pageParam),\n    getNextPageParam: (lastPage) => lastPage.nextPage\n  });\n  \n  const users = data?.pages.flatMap(page => page.users) || [];\n  \n  return (\n    <div>\n      {users.map(user => (\n        <UserCard key={user.id} user={user} />\n      ))}\n      \n      <button\n        onClick={() => fetchNextPage()}\n        disabled={!hasNextPage || isFetchingNextPage}\n      \u003e\n        {isFetchingNextPage\n          ? 'Loading more...'\n          : hasNextPage\n          ? 'Load More'\n          : 'No more users'}\n      </button>\n    </div>\n  );\n}\n```\n\n## Optimistic Updates\n\n```javascript\nconst mutation = useMutation({\n  mutationFn: updateTodo,\n  onMutate: async (newTodo) => {\n    // Cancel outgoing refetches\n    await queryClient.cancelQueries({ queryKey: ['todos'] });\n    \n    // Snapshot previous value\n    const previousTodos = queryClient.getQueryData(['todos']);\n    \n    // Optimistically update\n    queryClient.setQueryData(['todos'], (old) =>\n      old.map(todo =>\n        todo.id === newTodo.id ? { ...todo, ...newTodo } : todo\n      )\n    );\n    \n    // Return context for onError\n    return { previousTodos };\n  },\n  onError: (err, newTodo, context) => {\n    // Rollback on error\n    queryClient.setQueryData(['todos'], context.previousTodos);\n  },\n  onSettled: () => {\n    // Always refetch after error or success\n    queryClient.invalidateQueries({ queryKey: ['todos'] });\n  }\n});\n```\n\n## Prefetching\n\n```javascript\nfunction UserList() {\n  const queryClient = useQueryClient();\n  \n  const prefetchUser = (userId) => {\n    queryClient.prefetchQuery({\n      queryKey: ['user', userId],\n      queryFn: () => fetchUser(userId),\n      staleTime: 1000 * 60 * 5 // 5 minutes\n    });\n  };\n  \n  return (\n    <div>\n      {users.map(user => (\n        <link\n          key={user.id}\n          to={`/users/${user.id}`}\n          onMouseEnter={() => prefetchUser(user.id)}\n        \u003e\n          {user.name}\n        </link>\n      ))}\n    </div>\n  );\n}\n```\n\n## DevTools\n\n```javascript\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <MyApp />\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  );\n}\n```"
    }
  ],
  "exercises": [
    {
      "id": "state-ex-1",
      "type": "quiz",
      "lessonId": "state-overview",
      "moduleId": "state-management",
      "title": "State Management Basics",
      "difficulty": "easy",
      "questions": [
        {
          "question": "Which solution is best for managing server state (API data)?",
          "options": [
            "Zustand",
            "Redux",
            "React Query",
            "Context API"
          ],
          "correctAnswer": 2,
          "explanation": "React Query (TanStack Query) is specifically designed for managing server state with features like caching, background updates, and optimistic updates."
        },
        {
          "question": "When should you NOT use Context API?",
          "options": [
            "For theme state",
            "For authentication state",
            "For high-frequency updates (like animations)",
            "For user preferences"
          ],
          "correctAnswer": 2,
          "explanation": "Context API causes all consumers to re-render when the context value changes. For high-frequency updates like animations or rapidly changing data, use a dedicated state management solution like Zustand."
        }
      ]
    }
  ]
}
