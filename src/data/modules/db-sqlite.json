{
  "module": {
    "id": "db-sqlite",
    "title": "SQLite: Embedded Database",
    "description": "Master SQLite for local development, testing and embedded applications",
    "icon": "Database",
    "requiredXp": 800,
    "color": "from-blue-400 to-cyan-500",
    "courseId": "databases"
  },
  "lessons": [
    {
      "id": "sqlite-intro",
      "moduleId": "db-sqlite",
      "title": "Introduction to SQLite",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- SQLite = database in a single file\n- Zero configuration, zero server\n- Perfect for development, tests, IoT\n- Limited to one writer at a time\n- Included with Node.js (sqlite3 package)\n\n---\n\n# What is SQLite?\n\nSQLite is a complete relational database contained in a single C library. Unlike PostgreSQL or MySQL, there's no separate server to install and manage.\n\n## Unique Characteristics\n\n### ✅ Advantages\n- **Single file**: Your entire database is one `.db` or `.sqlite` file\n- **Zero-config**: No installation, no server to start\n- **Portable**: Copy the file, you copy the entire DB\n- **Embedded**: Works inside the application (mobile, IoT, desktop)\n- **Test-friendly**: Creating test DB = copying a file\n- **Transactional**: Full ACID despite simplicity\n\n### ❌ Limitations\n- **Single writer**: Writes are sequential\n- **No users/privileges**: Security at OS file level\n- **No networking**: No remote connections\n- **No ALTER COLUMN**: Schema modifications limited\n- **No RIGHT/FULL JOIN**: Only INNER and LEFT JOINs\n\n## When to Use SQLite?\n\n✅ **Perfect for:**\n- Local development and prototyping\n- Automated tests (fast DB creation)\n- Desktop/mobile applications offline\n- IoT and embedded devices\n- Web sites with low traffic (up to 100K visits/day)\n- Data analysis (ETL, data science)\n\n❌ **Avoid for:**\n- Applications with heavy write traffic\n- Multi-user with simultaneous writes\n- Replication and clustering\n- Advanced features needed (JSONB, arrays)\n\n## Installation with Node.js\n\n```bash\n# Native sqlite3 with C++ bindings\nnpm install sqlite3\n\n# Alternative pure JavaScript (slower but no compilation)\nnpm install better-sqlite3\n```\n\n## First Example\n\n```javascript\nimport sqlite3 from 'sqlite3';\nimport { open } from 'sqlite';\n\n// Open connection\nconst db = await open({\n  filename: './mydata.db',\n  driver: sqlite3.Database\n});\n\n// Create table\nawait db.exec(`\n  CREATE TABLE IF NOT EXISTS users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL,\n    email TEXT UNIQUE,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n  )\n`);\n\n// Insert data\nawait db.run(\n  'INSERT INTO users (name, email) VALUES (?, ?)',\n  ['John Doe', 'john@example.com']\n);\n\n// Read data\nconst users = await db.all('SELECT * FROM users');\nconsole.log(users);\n\n// Close connection\nawait db.close();\n```\n\n## SQLite Data Types\n\nSQLite uses a flexible type system (type affinity):\n\n| SQLite Type | Storage | Examples |\n|------------|---------|----------|\n| INTEGER | Integer number | id, age, quantity |\n| REAL | Floating point | price, latitude |\n| TEXT | UTF-8 string | name, email, description |\n| BLOB | Binary data | images, files |\n| NUMERIC | Date, boolean, decimal | timestamps |\n| NULL | Null value | - |\n\n```sql\n-- SQLite is flexible with types\nCREATE TABLE test (\n  id INTEGER,\n  name TEXT,\n  data ANY_TYPE  -- SQLite accepts anything\n);\n\n-- But follow best practices\nCREATE TABLE products (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  name TEXT NOT NULL,\n  price REAL CHECK (price >= 0),\n  quantity INTEGER DEFAULT 0,\n  is_active INTEGER DEFAULT 1,  -- Boolean (0 or 1)\n  metadata TEXT  -- Can store JSON\n);\n```\n\n## Boolean in SQLite\n\nSQLite has no native boolean type. Convention:\n- **0** = false\n- **1** = true\n\n```sql\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  name TEXT,\n  is_active INTEGER DEFAULT 1 CHECK (is_active IN (0, 1))\n);\n\n-- Insert\nINSERT INTO users (name, is_active) VALUES ('John', 1);  -- Active\nINSERT INTO users (name, is_active) VALUES ('Jane', 0);  -- Inactive\n```\n\n## Date and Time\n\nSQLite stores dates as TEXT (ISO 8601), INTEGER (Unix timestamp), or REAL (Julian day).\n\n```sql\n-- Recommended: TEXT ISO 8601\nCREATE TABLE events (\n  id INTEGER PRIMARY KEY,\n  name TEXT,\n  created_at TEXT DEFAULT CURRENT_TIMESTAMP,  -- '2024-01-15 10:30:00'\n  scheduled_date TEXT  -- '2024-01-15'\n);\n\n-- Date functions\nSELECT datetime('now');                    -- Now\nSELECT date('now');                        -- Date only\nSELECT datetime('now', '+1 day');          -- Tomorrow\nSELECT datetime('now', '-1 month');        -- 1 month ago\nSELECT strftime('%Y-%m', created_at) FROM events;  -- Format\n```\n\n## JSON in SQLite\n\nSQLite 3.9+ supports JSON via extension:\n\n```sql\n-- Store JSON\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  name TEXT,\n  preferences TEXT  -- JSON: '{\"theme\":\"dark\",\"lang\":\"en\"}'\n);\n\n-- Extract JSON values\nSELECT json_extract(preferences, '$.theme') FROM users;\n\n-- Update JSON\nUPDATE users SET preferences = json_set(preferences, '$.theme', 'light');\n\n-- Query JSON\nSELECT * FROM users WHERE json_extract(preferences, '$.lang') = 'en';\n```"
    },
    {
      "id": "sqlite-node",
      "moduleId": "db-sqlite",
      "title": "SQLite with Node.js",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Use `sqlite` (modern wrapper) or `better-sqlite3`\n- db.run() for INSERT/UPDATE/DELETE\n- db.get() for single row\n- db.all() for multiple rows\n- db.each() for streaming without loading all\n\n---\n\n# sqlite (async/await)\n\nThe `sqlite` package is a modern wrapper around `sqlite3` with native Promise support.\n\n## Installation\n\n```bash\nnpm install sqlite sqlite3\n```\n\n## Common Patterns\n\n```javascript\nimport sqlite3 from 'sqlite3';\nimport { open } from 'sqlite';\n\n// Connect to database\nasync function getDb() {\n  return open({\n    filename: process.env.DATABASE_URL || './database.db',\n    driver: sqlite3.Database\n  });\n}\n\n// CRUD Operations\nclass UserRepository {\n  constructor(db) {\n    this.db = db;\n  }\n\n  // CREATE\n  async create(user) {\n    const result = await this.db.run(\n      'INSERT INTO users (name, email, age) VALUES (?, ?, ?)',\n      [user.name, user.email, user.age]\n    );\n    return { id: result.lastID, ...user };\n  }\n\n  // READ one\n  async findById(id) {\n    return this.db.get(\n      'SELECT * FROM users WHERE id = ?',\n      [id]\n    );\n  }\n\n  // READ many\n  async findAll(options = {}) {\n    const { limit = 20, offset = 0 } = options;\n    return this.db.all(\n      'SELECT * FROM users LIMIT ? OFFSET ?',\n      [limit, offset]\n    );\n  }\n\n  // UPDATE\n  async update(id, updates) {\n    const fields = Object.keys(updates);\n    const values = Object.values(updates);\n\n    const setClause = fields.map(f => `${f} = ?`).join(', ');\n\n    await this.db.run(\n      `UPDATE users SET ${setClause} WHERE id = ?`,\n      [...values, id]\n    );\n\n    return this.findById(id);\n  }\n\n  // DELETE\n  async delete(id) {\n    const result = await this.db.run(\n      'DELETE FROM users WHERE id = ?',\n      [id]\n    );\n    return result.changes > 0;\n  }\n\n  // Search\n  async search(query) {\n    return this.db.all(\n      'SELECT * FROM users WHERE name LIKE ? OR email LIKE ?',\n      [`%${query}%`, `%${query}%`]\n    );\n  }\n}\n\n// Usage\nconst db = await getDb();\nconst users = new UserRepository(db);\n\nconst newUser = await users.create({\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 30\n});\n\nconsole.log('Created:', newUser);\n```\n\n## better-sqlite3 (synchronous but faster)\n\nFor performance-critical cases, `better-sqlite3` is 10x faster because it's synchronous.\n\n```bash\nnpm install better-sqlite3\n```\n\n```javascript\nimport Database from 'better-sqlite3';\n\nconst db = new Database('mydata.db');\n\n// Prepare query (recommended for reuse)\nconst insertUser = db.prepare(\n  'INSERT INTO users (name, email) VALUES (?, ?)'\n);\n\n// Execute\nconst result = insertUser.run('John', 'john@example.com');\nconsole.log('Inserted ID:', result.lastInsertRowid);\n\n// SELECT one\nconst getUser = db.prepare('SELECT * FROM users WHERE id = ?');\nconst user = getUser.get(1);\n\n// SELECT many\nconst getAllUsers = db.prepare('SELECT * FROM users');\nconst users = getAllUsers.all();\n\n// Transactions\nconst insertOrder = db.prepare('INSERT INTO orders ...');\nconst updateStock = db.prepare('UPDATE products ...');\n\nconst createOrder = db.transaction((order) => {\n  const orderId = insertOrder.run(order).lastInsertRowid;\n  for (const item of order.items) {\n    updateStock.run(item.productId, item.quantity);\n  }\n  return orderId;\n});\n\ncreateOrder({ items: [...], userId: 1 });  // Atomic\n```\n\n## Error Handling\n\n```javascript\nimport { open } from 'sqlite';\n\nasync function safeQuery(db, query, params) {\n  try {\n    return await db.all(query, params);\n  } catch (error) {\n    if (error.message.includes('UNIQUE constraint failed')) {\n      throw new Error('This email is already in use');\n    }\n    if (error.message.includes('FOREIGN KEY constraint failed')) {\n      throw new Error('Invalid reference');\n    }\n    throw error;\n  }\n}\n```\n\n## Database Migrations\n\n```javascript\n// db/migrations.js\nconst migrations = [\n  {\n    version: 1,\n    up: `\n      CREATE TABLE users (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT NOT NULL,\n        email TEXT UNIQUE\n      );\n    `\n  },\n  {\n    version: 2,\n    up: `\n      ALTER TABLE users ADD COLUMN created_at TEXT DEFAULT CURRENT_TIMESTAMP;\n    `\n  },\n  {\n    version: 3,\n    up: `\n      CREATE TABLE posts (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        user_id INTEGER REFERENCES users(id),\n        title TEXT,\n        content TEXT\n      );\n    `\n  }\n];\n\nexport async function migrate(db) {\n  await db.exec(`\n    CREATE TABLE IF NOT EXISTS migrations (\n      version INTEGER PRIMARY KEY,\n      applied_at TEXT DEFAULT CURRENT_TIMESTAMP\n    )\n  `);\n\n  const applied = await db.all('SELECT version FROM migrations');\n  const appliedVersions = new Set(applied.map(a => a.version));\n\n  for (const migration of migrations) {\n    if (!appliedVersions.has(migration.version)) {\n      console.log(`Applying migration ${migration.version}...`);\n      await db.exec(migration.up);\n      await db.run(\n        'INSERT INTO migrations (version) VALUES (?)',\n        [migration.version]\n      );\n    }\n  }\n}\n```"
    },
    {
      "id": "sqlite-prod",
      "moduleId": "db-sqlite",
      "title": "SQLite in Production",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- WAL mode (Write-Ahead Logging) for better concurrency\n- Backups: copy .db file (after .backup or vacuum)\n- Foreign keys must be enabled (PRAGMA foreign_keys = ON)\n- Journal mode for durability\n- Security at file level (permissions)\n\n---\n\n# Optimizing SQLite in Production\n\n## Write-Ahead Logging (WAL)\n\nWAL significantly improves concurrent performance:\n\n```javascript\nawait db.exec('PRAGMA journal_mode = WAL');\n```\n\nWAL mode benefits:\n- **Readers and writer simultaneous**: Multiple reads during writes\n- **Better performance**: 10-100x faster writes\n- **Durability**: No corruption on crash\n\nFiles created:\n- `database.db`: Main database\n- `database.db-wal`: Transaction journal\n- `database.db-shm`: Shared memory\n\n## Essential PRAGMAs\n\n```javascript\n// Enable foreign keys (disabled by default!)\nawait db.exec('PRAGMA foreign_keys = ON');\n\n// Performance optimizations\nawait db.exec('PRAGMA synchronous = NORMAL');  // or FULL for more safety\nawait db.exec('PRAGMA cache_size = -64000');   // 64MB cache\nawait db.exec('PRAGMA temp_store = MEMORY');   // Temp in RAM\n\n// WAL mode\nawait db.exec('PRAGMA journal_mode = WAL');\nawait db.exec('PRAGMA wal_autocheckpoint = 1000');  // Auto checkpoint\n```\n\n## Backup and Restore\n\n```javascript\n// Backup with SQLite API\nasync function backup(sourceDb, destPath) {\n  const backup = await sourceDb.backup(destPath);\n  console.log(`Backup: ${backup.totalPages} pages`);\n}\n\n// Backup command line\nsqlite3 database.db '.backup backup.db'\n\n// Vacuum (optimize and compact)\nawait db.exec('VACUUM');\n\n// Export SQL\nsqlite3 database.db '.dump' > backup.sql\n\n// Import SQL\nsqlite3 new.db < backup.sql\n```\n\n## Security\n\n```bash\n# Restrictive permissions (Unix)\nchmod 600 database.db      # Owner read/write only\nchmod 600 database.db-wal\nchmod 600 database.db-shm\n```\n\n```javascript\n// Never expose DB\n// ❌ Bad: app.get('/database.db', ...)\n\n// ✅ Good: DB outside public folder\nconst db = await open({\n  filename: './data/database.db',  // Not in ./public!\n  driver: sqlite3.Database\n});\n```\n\n## When to Migrate to PostgreSQL?\n\nConsider PostgreSQL when:\n\n1. **High traffic**: Many simultaneous writes\n2. **Multi-server**: Need replication, clustering\n3. **Advanced features**: Full-text search, JSONB, arrays\n4. **Security**: Need user/privilege granularity\n5. **Remote access**: Multiple servers accessing DB\n\n## SQLite → PostgreSQL Migration\n\n```javascript\n// 1. Export SQLite to SQL\n// sqlite3 database.db '.dump' > dump.sql\n\n// 2. Adapt dump for PostgreSQL\n// - Replace AUTOINCREMENT with SERIAL\n// - Replace INTEGER PRIMARY KEY with SERIAL PRIMARY KEY\n// - Adapt types (TEXT → VARCHAR, etc.)\n\n// 3. Import into PostgreSQL\n// psql -d mydb -f dump.sql\n\n// 4. Adapt Node.js code\n// Replace sqlite3 with pg\n// Adapt SQLite-specific queries\n```\n\n## Recommended Hybrid Architecture\n\n```\nLocal Development: SQLite (fast, simple)\n         ↓\nAutomated Tests: SQLite (in-memory or file)\n         ↓\nProduction: PostgreSQL (robustness, scaling)\n```\n\nWith Prisma ORM, the switch is transparent:\n```prisma\n// schema.prisma\ndatasource db {\n  provider = env(\"DB_PROVIDER\")  // \"sqlite\" or \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n```"
    }
  ],
  "exercises": []
}
