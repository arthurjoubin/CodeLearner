{
  "module": {
    "id": "devops-basics",
    "title": "DevOps Basics",
    "description": "Learn essential DevOps concepts: version control, CI/CD, containers, and deployment",
    "icon": "GitBranch",
    "requiredXp": 2500,
    "color": "from-sky-400 to-sky-600",
    "courseId": "web-stack"
  },
  "lessons": [
    {
      "id": "git-workflows",
      "moduleId": "devops-basics",
      "title": "Git Workflows",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Git is version control - tracks code changes over time\n- Branches let you work on features without breaking main code\n- Common workflow: branch ‚Üí commit ‚Üí push ‚Üí pull request ‚Üí merge\n- Master/main branch should always be deployable\n\n---\n\n# Git Workflows Explained\n\n## Why Git?\n\n**Git** tracks every change to your code:\n- ‚úÖ Undo mistakes easily\n- ‚úÖ Work with teams without conflicts\n- ‚úÖ Try new features safely\n- ‚úÖ See who changed what and when\n\nThink of it as **\"Track Changes\" for code**.\n\n## Basic Workflow\n\n### 1. Clone the Repository\n```bash\ngit clone https://github.com/user/project.git\ncd project\n```\nDownloads the project to your computer.\n\n### 2. Create a Branch\n```bash\ngit checkout -b feature/add-login\n```\nCreates a new branch for your feature. This keeps your work separate from the main code.\n\n**Branch naming conventions:**\n- `feature/` - New features\n- `fix/` - Bug fixes\n- `hotfix/` - Urgent production fixes\n\n### 3. Make Changes and Commit\n```bash\ngit add .\ngit commit -m \"Add login form component\"\n```\n\n**Good commit messages:**\n- ‚úÖ \"Fix navigation bug on mobile\"\n- ‚úÖ \"Add user authentication\"\n- ‚ùå \"Fixed stuff\"\n- ‚ùå \"Changes\"\n\n### 4. Push to Remote\n```bash\ngit push origin feature/add-login\n```\nUploads your branch to GitHub/GitLab.\n\n### 5. Create Pull Request\nOn GitHub: Create a PR to merge your branch into `main`.\n\n**Pull Request = Code Review**\n- Team reviews your code\n- Suggests improvements\n- Tests run automatically\n- Once approved ‚Üí merge!\n\n### 6. Merge and Delete Branch\n```bash\ngit checkout main\ngit pull origin main\ngit branch -d feature/add-login\n```\n\n## Common Git Commands\n\n**Check status:**\n```bash\ngit status\n```\nShows modified files, staged changes.\n\n**See history:**\n```bash\ngit log --oneline\n```\nShows recent commits.\n\n**Switch branches:**\n```bash\ngit checkout main\n```\n\n**Pull latest changes:**\n```bash\ngit pull origin main\n```\nDownloads changes from remote.\n\n**Undo changes:**\n```bash\ngit checkout -- filename.js  # Undo unstaged changes\ngit reset HEAD~1             # Undo last commit (keep changes)\n```\n\n## Merge vs Rebase\n\n**Merge** - Combines branches with a merge commit\n```bash\ngit merge feature/login\n```\n- ‚úÖ Preserves history\n- ‚úÖ Safer for beginners\n- ‚ùå Creates merge commits\n\n**Rebase** - Replays your commits on top of another branch\n```bash\ngit rebase main\n```\n- ‚úÖ Cleaner history\n- ‚ùå Rewrites history (dangerous if shared)\n- Use on your own branches only!\n\n## Handling Conflicts\n\nConflict happens when two people edit the same lines:\n\n```\n<<<<<<< HEAD\nconst greeting = \"Hello\";\n=======\nconst greeting = \"Hi\";\n>>>>>>> feature/update-greeting\n```\n\n**To resolve:**\n1. Pick which version to keep (or combine)\n2. Remove conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`)\n3. `git add` the file\n4. `git commit`\n\n## Best Practices\n\n‚úÖ Commit often with clear messages\n‚úÖ Pull before starting work\n‚úÖ Keep branches short-lived\n‚úÖ One feature per branch\n‚úÖ Review code before merging\n‚úÖ Never commit secrets or passwords\n‚úÖ Use `.gitignore` for node_modules, .env, etc.",
      "codeExample": "// Typical Git workflow for adding a feature\n\n// 1. Start from main branch\n// git checkout main\n// git pull origin main\n\n// 2. Create feature branch\n// git checkout -b feature/add-dark-mode\n\n// 3. Make changes to code\n// ... edit files ...\n\n// 4. Check what changed\n// git status\n// git diff\n\n// 5. Stage and commit\n// git add src/components/ThemeToggle.tsx\n// git commit -m \"Add dark mode toggle component\"\n\n// 6. More changes?\n// git add .\n// git commit -m \"Apply dark theme styles\"\n\n// 7. Push to remote\n// git push origin feature/add-dark-mode\n\n// 8. Create PR on GitHub\n// 9. After merge, cleanup:\n// git checkout main\n// git pull origin main\n// git branch -d feature/add-dark-mode\n\n// Common fixes:\n// Oops, forgot to add a file:\n// git add forgotten-file.js\n// git commit --amend --no-edit\n\n// Wrong branch? Move commits:\n// git checkout correct-branch\n// git cherry-pick commit-hash"
    },
    {
      "id": "cicd-explained",
      "moduleId": "devops-basics",
      "title": "CI/CD Explained",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- CI/CD automates testing and deployment\n- CI = Continuous Integration (automatic testing)\n- CD = Continuous Delivery/Deployment (automatic releases)\n- Catches bugs early, deploys faster\n\n---\n\n# CI/CD: Automating Your Workflow\n\n## The Problem Without CI/CD\n\n**Traditional workflow:**\n1. Developer writes code\n2. Manually runs tests (maybe forgets)\n3. Pushes to production\n4. üí• **PRODUCTION BREAKS!**\n\n**With CI/CD:**\n1. Developer pushes code\n2. Tests run automatically\n3. If tests pass ‚Üí automatically deploy\n4. ‚úÖ **Production stays stable!**\n\n## What is CI (Continuous Integration)?\n\n**CI** = Automatically test code whenever someone pushes.\n\n### How CI Works\n\n```\nYou push code ‚Üí CI server detects push ‚Üí Runs tests ‚Üí Reports results\n```\n\n**Example (GitHub Actions):**\n```yaml\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: npm install\n      - run: npm test\n```\n\nEvery push triggers:\n- Install dependencies\n- Run tests\n- Check code style (linting)\n- Build the project\n\nIf anything fails ‚Üí **PR is blocked** until fixed.\n\n## What is CD (Continuous Delivery/Deployment)?\n\n**CD** = Automatically deploy code when tests pass.\n\n### Continuous Delivery\n**Manual button click** to deploy to production.\n\n```\nTests pass ‚Üí Build artifact ‚Üí Ready to deploy ‚Üí [Deploy button] ‚Üí Production\n```\n\n### Continuous Deployment\n**Fully automatic** - no manual step.\n\n```\nTests pass ‚Üí Build artifact ‚Üí Automatically deploy ‚Üí Production\n```\n\n## CI/CD Pipeline Example\n\n**A typical pipeline:**\n\n```\n1. Code pushed to GitHub\n   ‚Üì\n2. CI server starts\n   ‚Üì\n3. Install dependencies (npm install)\n   ‚Üì\n4. Run linter (eslint)\n   ‚Üì\n5. Run tests (jest)\n   ‚Üì\n6. Build app (npm build)\n   ‚Üì\n7. Deploy to staging server\n   ‚Üì\n8. Run E2E tests on staging\n   ‚Üì\n9. If all pass ‚Üí Deploy to production\n   ‚Üì\n10. Monitor for errors\n```\n\n## Popular CI/CD Tools\n\n**GitHub Actions** - Built into GitHub\n```yaml\nname: CI\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: npm test\n```\n\n**GitLab CI** - Built into GitLab\n```yaml\ntest:\n  script:\n    - npm install\n    - npm test\n```\n\n**Jenkins** - Self-hosted, very customizable\n**CircleCI** - Cloud-based\n**Travis CI** - Popular for open source\n\n## Benefits of CI/CD\n\n‚úÖ **Catch bugs early** - Tests run on every change\n‚úÖ **Deploy faster** - No manual steps\n‚úÖ **Less stress** - Confidence in deployments\n‚úÖ **Better code quality** - Enforces tests and linting\n‚úÖ **Team collaboration** - Everyone sees test results\n\n## Environments\n\nMost projects have multiple environments:\n\n**Development** - Your local machine\n- `http://localhost:3000`\n- Connects to local/dev database\n\n**Staging** - Production clone for testing\n- `https://staging.example.com`\n- Safe to break things\n\n**Production** - Real users\n- `https://example.com`\n- Must be stable!\n\n**CI/CD flow:**\n```\ndev ‚Üí staging ‚Üí production\n```\n\n## What Gets Automated?\n\n**Testing:**\n- Unit tests\n- Integration tests\n- E2E tests\n- Security scans\n\n**Code Quality:**\n- Linting (ESLint)\n- Formatting (Prettier)\n- Type checking (TypeScript)\n\n**Building:**\n- Compile code\n- Optimize assets\n- Generate static files\n\n**Deployment:**\n- Upload to servers\n- Update databases\n- Clear caches\n- Send notifications\n\n## Best Practices\n\n‚úÖ Keep builds fast (<10 minutes)\n‚úÖ Run tests on every PR\n‚úÖ Deploy small changes frequently\n‚úÖ Have a rollback plan\n‚úÖ Monitor after deployments\n‚úÖ Use staging for testing\n‚úÖ Automate everything possible\n\n## When CI Fails\n\n**Red X on GitHub?**\n1. Click to see logs\n2. Find the failing step\n3. Fix the issue locally\n4. Push the fix\n5. CI runs again automatically\n\n**Never bypass CI to \"save time\"** - it saves you from bugs!",
      "codeExample": "// Example: GitHub Actions workflow file\n// Save as .github/workflows/ci.yml\n\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n      # Checkout code\n      - uses: actions/checkout@v3\n      \n      # Setup Node.js\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      # Install dependencies\n      - name: Install dependencies\n        run: npm ci\n      \n      # Run linter\n      - name: Lint code\n        run: npm run lint\n      \n      # Run tests\n      - name: Run tests\n        run: npm test -- --coverage\n      \n      # Build project\n      - name: Build\n        run: npm run build\n      \n      # Upload artifacts\n      - uses: actions/upload-artifact@v3\n        with:\n          name: build\n          path: dist/\n  \n  deploy:\n    needs: test  # Only run if tests pass\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Deploy to production\n        run: |\n          echo \"Deploying to production...\"\n          # Deploy commands here\n          # Example: npm run deploy"
    },
    {
      "id": "docker-intro",
      "moduleId": "devops-basics",
      "title": "Docker Containers Intro",
      "order": 3,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Docker packages your app + its environment into a container\n- \"It works on my machine\" ‚Üí Docker ensures it works everywhere\n- Containers are lightweight, isolated, and portable\n- Dockerfile = recipe for building your container\n\n---\n\n# Docker: Shipping Your App Anywhere\n\n## The Problem Docker Solves\n\n**Without Docker:**\n```\nDeveloper: \"It works on my machine!\" ü§∑\nProduction: \"It crashes on the server!\" üí•\n```\n\n**Why?**\n- Different Node versions\n- Missing dependencies\n- Different operating systems\n- Environment variables not set\n\n**With Docker:**\n```\nDeveloper: \"Here's a container with everything!\"\nProduction: \"It works perfectly!\" ‚úÖ\n```\n\n## What is a Container?\n\nA **container** is like a **lightweight virtual computer** that:\n- Contains your app + all its dependencies\n- Runs the same way everywhere\n- Starts in seconds (not minutes like VMs)\n- Isolated from other containers\n\n**Analogy:** A shipping container\n- Everything packed inside\n- Standardized size\n- Can be shipped anywhere\n- Contents protected\n\n## Container vs Virtual Machine\n\n**Virtual Machine:**\n```\n[Your App] [Your App]\n[Guest OS] [Guest OS] ‚Üê Full operating system!\n[Hypervisor]\n[Host OS]\n[Hardware]\n```\n- Heavy (GBs)\n- Slow to start (minutes)\n- More isolated\n\n**Container:**\n```\n[Your App] [Your App] [Your App]\n[Docker Engine]\n[Host OS]\n[Hardware]\n```\n- Lightweight (MBs)\n- Fast to start (seconds)\n- Shares host OS kernel\n\n## Docker Basics\n\n### Dockerfile\n\nA **recipe** for building your container:\n\n```dockerfile\n# Start from a base image\nFROM node:18-alpine\n\n# Set working directory\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\n\n# Install dependencies\nRUN npm ci\n\n# Copy app code\nCOPY . .\n\n# Build the app\nRUN npm run build\n\n# Expose port\nEXPOSE 3000\n\n# Start the app\nCMD [\"npm\", \"start\"]\n```\n\n### Building an Image\n\n**Image** = The container blueprint\n\n```bash\ndocker build -t my-app:latest .\n```\n\nCreates an image named `my-app` with tag `latest`.\n\n### Running a Container\n\n```bash\ndocker run -p 3000:3000 my-app:latest\n```\n\n- `-p 3000:3000` maps port 3000 on your computer to port 3000 in the container\n- Container starts and app is accessible at `http://localhost:3000`\n\n## Common Docker Commands\n\n**List running containers:**\n```bash\ndocker ps\n```\n\n**List all containers (including stopped):**\n```bash\ndocker ps -a\n```\n\n**Stop a container:**\n```bash\ndocker stop container-id\n```\n\n**Remove a container:**\n```bash\ndocker rm container-id\n```\n\n**List images:**\n```bash\ndocker images\n```\n\n**Remove an image:**\n```bash\ndocker rmi image-id\n```\n\n**View logs:**\n```bash\ndocker logs container-id\n```\n\n**Run container in background:**\n```bash\ndocker run -d -p 3000:3000 my-app\n```\n\n## Docker Compose\n\n**Problem:** Running multiple containers (app + database + redis)\n\n**Solution:** docker-compose.yml\n\n```yaml\nversion: '3'\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - DATABASE_URL=postgresql://db:5432/myapp\n    depends_on:\n      - db\n  \n  db:\n    image: postgres:15\n    environment:\n      - POSTGRES_PASSWORD=secret\n    volumes:\n      - db-data:/var/lib/postgresql/data\n\nvolumes:\n  db-data:\n```\n\n**Start everything:**\n```bash\ndocker-compose up\n```\n\n**Stop everything:**\n```bash\ndocker-compose down\n```\n\n## When to Use Docker\n\n‚úÖ **Production deployments** - Consistent environment\n‚úÖ **Team development** - Same setup for everyone\n‚úÖ **Microservices** - Each service in its own container\n‚úÖ **CI/CD pipelines** - Tests run in containers\n‚úÖ **Complex dependencies** - Package everything together\n\n‚ùå **Simple static sites** - Might be overkill\n‚ùå **GUI desktop apps** - Containers are for servers\n\n## Benefits\n\n‚úÖ **Consistency** - Works same everywhere\n‚úÖ **Isolation** - Dependencies don't conflict\n‚úÖ **Portability** - Deploy anywhere\n‚úÖ **Scalability** - Easy to run multiple instances\n‚úÖ **Fast** - Starts in seconds\n\n## Basic Workflow\n\n```\n1. Write Dockerfile\n2. Build image (docker build)\n3. Test locally (docker run)\n4. Push to registry (Docker Hub)\n5. Pull on server (docker pull)\n6. Run in production (docker run)\n```",
      "codeExample": "// Dockerfile for a React app\n// Save as: Dockerfile\n\n# Build stage\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\n# Production stage\nFROM nginx:alpine\nCOPY --from=builder /app/dist /usr/share/nginx/html\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n\n# ---\n# Build and run:\n# docker build -t my-react-app .\n# docker run -p 8080:80 my-react-app\n# Visit: http://localhost:8080\n\n// ---\n// docker-compose.yml for full stack app\n\nversion: '3.8'\nservices:\n  frontend:\n    build: ./frontend\n    ports:\n      - \"3000:3000\"\n    environment:\n      - REACT_APP_API_URL=http://localhost:4000\n    depends_on:\n      - backend\n  \n  backend:\n    build: ./backend\n    ports:\n      - \"4000:4000\"\n    environment:\n      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp\n      - PORT=4000\n    depends_on:\n      - db\n  \n  db:\n    image: postgres:15-alpine\n    environment:\n      - POSTGRES_PASSWORD=password\n      - POSTGRES_DB=myapp\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n\nvolumes:\n  postgres-data:\n\n# Run with: docker-compose up\n# Stop with: docker-compose down"
    },
    {
      "id": "deployment-strategies",
      "moduleId": "devops-basics",
      "title": "Deployment Strategies",
      "order": 4,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Deployment = Getting your code to production\n- Different strategies balance risk vs speed\n- Zero-downtime deployments keep your app running\n- Rollback plan is essential for safety\n\n---\n\n# Deployment Strategies\n\n## What is Deployment?\n\n**Deployment** = Making your new code available to users.\n\nChallenges:\n- Don't break the live site\n- Minimize downtime\n- Handle errors gracefully\n- Be able to rollback\n\n## Deployment Strategies\n\n### 1. Recreate (All at Once)\n\n**How it works:**\n1. Stop old version\n2. Deploy new version\n3. Start new version\n\n**Pros:**\n- ‚úÖ Simple\n- ‚úÖ Clean cutover\n\n**Cons:**\n- ‚ùå **Downtime!** (seconds to minutes)\n- ‚ùå Risky if new version fails\n\n**When to use:**\n- Development/staging environments\n- Scheduled maintenance windows\n- Small personal projects\n\n### 2. Rolling Update\n\n**How it works:**\n1. Update one server at a time\n2. Wait for health check\n3. Move to next server\n\n```\nServer 1: [Old] ‚Üí [New] ‚úÖ\nServer 2: [Old] ‚Üí [Old]\nServer 3: [Old] ‚Üí [Old]\n\nServer 1: [New] ‚úÖ\nServer 2: [Old] ‚Üí [New] ‚úÖ\nServer 3: [Old] ‚Üí [Old]\n\nServer 1: [New] ‚úÖ\nServer 2: [New] ‚úÖ\nServer 3: [Old] ‚Üí [New] ‚úÖ\n```\n\n**Pros:**\n- ‚úÖ Zero downtime\n- ‚úÖ Gradual rollout\n\n**Cons:**\n- ‚ùå Slower deployment\n- ‚ùå Both versions running simultaneously\n\n**When to use:**\n- Production with multiple servers\n- When downtime is unacceptable\n\n### 3. Blue-Green Deployment\n\n**How it works:**\n1. Run new version (Green) alongside old (Blue)\n2. Test Green thoroughly\n3. Switch traffic from Blue to Green\n4. Keep Blue for quick rollback\n\n```\nBlue (Old): [100% traffic] ‚Üê Current\nGreen (New): [0% traffic] ‚Üê Testing\n\n‚Üì Switch! ‚Üì\n\nBlue (Old): [0% traffic] ‚Üê Standby\nGreen (New): [100% traffic] ‚Üê Current\n```\n\n**Pros:**\n- ‚úÖ Zero downtime\n- ‚úÖ Instant rollback (switch back to Blue)\n- ‚úÖ Test before switching\n\n**Cons:**\n- ‚ùå Needs 2x resources\n- ‚ùå Database migrations tricky\n\n**When to use:**\n- Critical production systems\n- When instant rollback is essential\n\n### 4. Canary Deployment\n\n**How it works:**\n1. Deploy new version to small % of servers\n2. Route 5% of traffic to new version\n3. Monitor for errors\n4. Gradually increase to 100%\n\n```\nOld version: [95% traffic]\nNew version: [5% traffic] ‚Üê Monitor closely\n\nIf no errors:\nOld version: [50% traffic]\nNew version: [50% traffic]\n\nThen:\nOld version: [0% traffic]\nNew version: [100% traffic] ‚úÖ\n```\n\n**Pros:**\n- ‚úÖ Low risk - only affects few users\n- ‚úÖ Real-world testing\n- ‚úÖ Early error detection\n\n**Cons:**\n- ‚ùå More complex setup\n- ‚ùå Requires monitoring\n\n**When to use:**\n- Large user bases\n- Risky changes\n- Want to test with real traffic\n\n### 5. A/B Testing Deployment\n\nSimilar to canary, but:\n- Both versions run indefinitely\n- Compare metrics (which is better?)\n- Choose winning version\n\n**Use for:**\n- Testing new features\n- UI/UX experiments\n- Performance comparisons\n\n## Deployment Platforms\n\n**Vercel** (Best for Next.js/React)\n```bash\nnpm install -g vercel\nvercel --prod\n```\n- ‚úÖ Automatic HTTPS\n- ‚úÖ Global CDN\n- ‚úÖ Preview deployments for PRs\n\n**Netlify** (Static sites)\n```bash\nnetlify deploy --prod\n```\n- ‚úÖ Simple drag-and-drop\n- ‚úÖ Serverless functions\n- ‚úÖ Form handling\n\n**Heroku** (Full stack apps)\n```bash\ngit push heroku main\n```\n- ‚úÖ Easy to use\n- ‚úÖ Add-ons (databases, etc.)\n\n**AWS / Google Cloud / Azure** (Enterprise)\n- More complex but powerful\n- Full control\n- Scalable\n\n## Essential Deployment Practices\n\n‚úÖ **Health checks** - Verify app is running before routing traffic\n‚úÖ **Gradual rollout** - Don't deploy to all servers at once\n‚úÖ **Monitoring** - Watch error rates, performance\n‚úÖ **Rollback plan** - Know how to undo deployment\n‚úÖ **Database migrations** - Handle carefully (backwards compatible)\n‚úÖ **Environment variables** - Never commit secrets\n‚úÖ **Automated tests** - Run before deployment\n\n## Rollback Strategies\n\nWhen deployment goes wrong:\n\n**1. Instant rollback**\n```bash\n# Switch back to previous version\nkubectl rollout undo deployment/my-app\n```\n\n**2. Keep old version running**\n- Blue-green: Switch traffic back\n- Canary: Stop rollout at 5%\n\n**3. Feature flags**\n```javascript\nif (featureFlags.newCheckout) {\n  // New code\n} else {\n  // Old code (fallback)\n}\n```\nDisable new feature without redeploying!",
      "codeExample": "// Example: Simple health check endpoint\n// Every deployment strategy needs this!\n\n// server.js\nconst express = require('express');\nconst app = express();\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  // Check if app is healthy\n  const isHealthy = checkDatabase() && checkRedis();\n  \n  if (isHealthy) {\n    res.status(200).json({ status: 'healthy' });\n  } else {\n    res.status(503).json({ status: 'unhealthy' });\n  }\n});\n\nfunction checkDatabase() {\n  try {\n    // Ping database\n    db.ping();\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction checkRedis() {\n  try {\n    // Ping redis\n    redis.ping();\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\napp.listen(3000);\n\n// Load balancer uses this to know if server is ready:\n// GET /health ‚Üí 200 OK = Send traffic ‚úÖ\n// GET /health ‚Üí 503 = Don't send traffic ‚ùå\n\n// ---\n// Example: Feature flag for safe rollout\n\nconst features = {\n  newCheckout: process.env.ENABLE_NEW_CHECKOUT === 'true'\n};\n\nfunction checkout(cart) {\n  if (features.newCheckout) {\n    return newCheckoutFlow(cart); // New code\n  } else {\n    return oldCheckoutFlow(cart); // Fallback\n  }\n}\n\n// Can toggle feature without redeploying!\n// Just change environment variable"
    },
    {
      "id": "monitoring-basics",
      "moduleId": "devops-basics",
      "title": "Monitoring Basics",
      "order": 5,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Monitoring = Watching your app's health in production\n- Track errors, performance, uptime\n- Get alerts when things go wrong\n- Logs help debug issues\n\n---\n\n# Monitoring: Keeping Your App Healthy\n\n## Why Monitor?\n\n**Without monitoring:**\n```\nUser: \"Your site is down!\"\nYou: \"What? For how long?\" üò±\n```\n\n**With monitoring:**\n```\nAlert: \"Error rate spiked! 50 errors/min\"\nYou: \"I see it. Rolling back now.\" üòé\n```\n\nMonitoring lets you:\n- ‚úÖ Detect problems before users complain\n- ‚úÖ Understand what went wrong\n- ‚úÖ Track performance trends\n- ‚úÖ Make data-driven decisions\n\n## What to Monitor\n\n### 1. Uptime\n**Is your site accessible?**\n\n```\nPing every 1 minute:\nhttps://myapp.com/health\n\n‚úÖ 200 OK ‚Üí Site is up\n‚ùå 500 Error ‚Üí Site is down ‚Üí Send alert!\n```\n\n**Tools:**\n- UptimeRobot (free)\n- Pingdom\n- StatusCake\n\n### 2. Errors\n**What's breaking?**\n\n```javascript\ntry {\n  processPayment(order);\n} catch (error) {\n  // Log to monitoring service\n  Sentry.captureException(error);\n  throw error;\n}\n```\n\n**Track:**\n- Error messages\n- Stack traces\n- User context (what they were doing)\n- Browser/device info\n\n**Tools:**\n- Sentry (best for errors)\n- Rollbar\n- Bugsnag\n\n### 3. Performance\n**How fast is your app?**\n\n**Metrics:**\n- **Response time** - How long requests take\n- **Throughput** - Requests per second\n- **CPU usage** - Server load\n- **Memory usage** - RAM consumption\n\n```\nAverage response time: 200ms ‚úÖ\nAlert if > 1000ms ‚ùå\n```\n\n### 4. Logs\n**What's happening?**\n\n```javascript\nconsole.log('User logged in:', userId);\nconsole.error('Payment failed:', error);\nconsole.warn('Low inventory:', productId);\n```\n\n**Structured logging:**\n```javascript\nlogger.info({\n  event: 'user_login',\n  userId: 123,\n  ip: '192.168.1.1',\n  timestamp: new Date()\n});\n```\n\n**Tools:**\n- Datadog\n- Loggly\n- Papertrail\n- CloudWatch (AWS)\n\n## Key Metrics\n\n### RED Method\n**Rate, Errors, Duration**\n\n**Rate** - Requests per second\n```\nNormal: 100 req/s\nPeak: 500 req/s\nAlert if > 1000 req/s\n```\n\n**Errors** - Error rate\n```\nNormal: 0.1% errors\nAlert if > 1% errors\n```\n\n**Duration** - Response time\n```\np50: 200ms (50% of requests)\np95: 500ms (95% of requests)\np99: 1000ms (99% of requests)\n```\n\n### USE Method (Servers)\n**Utilization, Saturation, Errors**\n\n**Utilization** - How busy?\n```\nCPU: 40% ‚úÖ\nCPU: 95% ‚ùå Time to scale!\n```\n\n**Saturation** - Queue depth\n```\nRequests waiting: 0 ‚úÖ\nRequests waiting: 100 ‚ùå\n```\n\n**Errors** - Failed operations\n\n## Alerting\n\n**Set up alerts for:**\n\n**Critical (wake me up at 3am):**\n- Site is down\n- Error rate > 5%\n- Payment system failing\n\n**Warning (check soon):**\n- Slow response times\n- High CPU usage\n- Error rate increasing\n\n**Info (review later):**\n- Deploy completed\n- Daily summary\n\n**Alert channels:**\n- Email\n- Slack/Discord\n- PagerDuty (on-call)\n- SMS (for critical)\n\n## Popular Monitoring Tools\n\n**All-in-one:**\n- **Datadog** - Comprehensive, expensive\n- **New Relic** - Application performance\n- **Grafana** - Open source dashboards\n\n**Error tracking:**\n- **Sentry** - Best for frontend/backend errors\n\n**Uptime:**\n- **UptimeRobot** - Free, simple\n\n**Logs:**\n- **LogRocket** - Session replay + logs\n- **Papertrail** - Simple log aggregation\n\n**Real User Monitoring (RUM):**\n- **Google Analytics** - Free\n- **Vercel Analytics** - Performance\n\n## Setting Up Basic Monitoring\n\n### 1. Add Error Tracking\n```javascript\n// Install Sentry\nnpm install @sentry/node\n\n// Initialize\nconst Sentry = require('@sentry/node');\nSentry.init({ dsn: 'your-dsn' });\n\n// Catch errors\napp.use(Sentry.Handlers.errorHandler());\n```\n\n### 2. Add Health Check\n```javascript\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok', timestamp: Date.now() });\n});\n```\n\n### 3. Set Up Uptime Monitor\n1. Go to uptimerobot.com\n2. Add your health check URL\n3. Set check interval (1 min)\n4. Add alert contacts\n\n### 4. Add Performance Tracking\n```javascript\n// Log request duration\napp.use((req, res, next) => {\n  const start = Date.now();\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`${req.method} ${req.url} - ${duration}ms`);\n  });\n  next();\n});\n```\n\n## Best Practices\n\n‚úÖ Monitor production (obviously)\n‚úÖ Monitor staging too (catch issues early)\n‚úÖ Set up alerts before launch\n‚úÖ Don't alert on everything (alert fatigue)\n‚úÖ Track trends over time\n‚úÖ Review dashboards regularly\n‚úÖ Test your alerts (make sure they work!)",
      "codeExample": "// Complete monitoring setup example\n\nconst express = require('express');\nconst Sentry = require('@sentry/node');\n\nconst app = express();\n\n// 1. Initialize error tracking\nSentry.init({\n  dsn: process.env.SENTRY_DSN,\n  environment: process.env.NODE_ENV,\n  tracesSampleRate: 0.1 // Sample 10% of requests\n});\n\napp.use(Sentry.Handlers.requestHandler());\n\n// 2. Request logging middleware\napp.use((req, res, next) => {\n  const start = Date.now();\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(JSON.stringify({\n      timestamp: new Date().toISOString(),\n      method: req.method,\n      url: req.url,\n      status: res.statusCode,\n      duration: `${duration}ms`,\n      userAgent: req.get('user-agent')\n    }));\n  });\n  next();\n});\n\n// 3. Health check endpoint\napp.get('/health', async (req, res) => {\n  try {\n    // Check dependencies\n    await db.ping();\n    await redis.ping();\n    \n    res.json({\n      status: 'healthy',\n      timestamp: Date.now(),\n      version: process.env.APP_VERSION\n    });\n  } catch (error) {\n    res.status(503).json({\n      status: 'unhealthy',\n      error: error.message\n    });\n  }\n});\n\n// 4. Metrics endpoint (for Prometheus/Grafana)\napp.get('/metrics', (req, res) => {\n  res.send(`\n    # HELP requests_total Total requests\n    # TYPE requests_total counter\n    requests_total ${totalRequests}\n    \n    # HELP errors_total Total errors\n    # TYPE errors_total counter\n    errors_total ${totalErrors}\n  `);\n});\n\n// Your routes...\napp.get('/api/users', async (req, res) => {\n  try {\n    const users = await db.getUsers();\n    res.json(users);\n  } catch (error) {\n    // Automatically captured by Sentry\n    Sentry.captureException(error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// 5. Error handler\napp.use(Sentry.Handlers.errorHandler());\n\napp.use((err, req, res, next) => {\n  console.error(JSON.stringify({\n    timestamp: new Date().toISOString(),\n    error: err.message,\n    stack: err.stack,\n    url: req.url\n  }));\n  res.status(500).send('Something broke!');\n});\n\napp.listen(3000, () => {\n  console.log('Server running with monitoring enabled');\n});"
    }
  ],
  "exercises": [
    {
      "id": "devops-ex-1",
      "lessonId": "git-workflows",
      "moduleId": "devops-basics",
      "title": "Git Commands Quiz",
      "difficulty": "easy",
      "description": "Test your knowledge of Git commands and workflows.",
      "instructions": "Choose the correct Git command for each scenario.",
      "type": "quiz",
      "questions": [
        {
          "question": "You want to create a new branch called 'feature/login'. Which command?",
          "options": [
            "git branch feature/login",
            "git checkout -b feature/login",
            "git new branch feature/login",
            "git create feature/login"
          ],
          "correctAnswer": 1,
          "explanation": "git checkout -b creates a new branch AND switches to it in one command."
        },
        {
          "question": "You made changes to 3 files and want to stage all of them. Which command?",
          "options": [
            "git add .",
            "git commit -a",
            "git stage all",
            "git push"
          ],
          "correctAnswer": 0,
          "explanation": "git add . stages all changes in the current directory."
        },
        {
          "question": "You want to see what files have been modified. Which command?",
          "options": [
            "git log",
            "git diff",
            "git status",
            "git show"
          ],
          "correctAnswer": 2,
          "explanation": "git status shows which files are modified, staged, or untracked."
        },
        {
          "question": "What should you do BEFORE starting work on a new feature?",
          "options": [
            "Start coding immediately",
            "git pull to get latest changes",
            "git push your branch",
            "Delete the main branch"
          ],
          "correctAnswer": 1,
          "explanation": "Always pull the latest changes to avoid conflicts later."
        }
      ]
    },
    {
      "id": "devops-ex-2",
      "lessonId": "cicd-explained",
      "moduleId": "devops-basics",
      "title": "CI/CD Concepts",
      "difficulty": "medium",
      "description": "Test your understanding of CI/CD principles.",
      "instructions": "Answer questions about continuous integration and deployment.",
      "type": "quiz",
      "questions": [
        {
          "question": "What does CI stand for?",
          "options": [
            "Code Integration",
            "Continuous Integration",
            "Cloud Infrastructure",
            "Commit Immediately"
          ],
          "correctAnswer": 1,
          "explanation": "CI = Continuous Integration, automatically testing code when pushed."
        },
        {
          "question": "What's the main benefit of CI?",
          "options": [
            "Makes code faster",
            "Reduces server costs",
            "Catches bugs early automatically",
            "Eliminates the need for testing"
          ],
          "correctAnswer": 2,
          "explanation": "CI runs tests automatically on every push, catching bugs before they reach production."
        },
        {
          "question": "When should CI tests run?",
          "options": [
            "Only on Fridays",
            "When you remember",
            "On every push/pull request",
            "Only before production deploys"
          ],
          "correctAnswer": 2,
          "explanation": "CI tests should run automatically on every code push and pull request."
        },
        {
          "question": "What happens if CI tests fail on your pull request?",
          "options": [
            "Nothing, you can still merge",
            "The PR should be blocked until fixed",
            "Tests are automatically skipped",
            "Code is automatically reverted"
          ],
          "correctAnswer": 1,
          "explanation": "Failed tests should block merging to prevent bugs from reaching production."
        },
        {
          "question": "What's Continuous Deployment (as opposed to Continuous Delivery)?",
          "options": [
            "Deploying once a week",
            "Manual approval before production",
            "Automatic deploy to production when tests pass",
            "Deploying to staging only"
          ],
          "correctAnswer": 2,
          "explanation": "Continuous Deployment fully automates releases - code that passes tests goes straight to production."
        }
      ]
    },
    {
      "id": "devops-ex-3",
      "lessonId": "docker-intro",
      "moduleId": "devops-basics",
      "title": "Docker Basics Quiz",
      "difficulty": "medium",
      "description": "Test your knowledge of Docker containers.",
      "instructions": "Answer questions about Docker and containers.",
      "type": "quiz",
      "questions": [
        {
          "question": "What problem does Docker solve?",
          "options": [
            "Makes code run faster",
            "Ensures app runs the same everywhere",
            "Reduces code size",
            "Eliminates bugs"
          ],
          "correctAnswer": 1,
          "explanation": "Docker packages your app with its environment, so 'works on my machine' becomes 'works everywhere'."
        },
        {
          "question": "What is a Dockerfile?",
          "options": [
            "A running container",
            "A recipe/blueprint for building a container",
            "A database file",
            "A configuration file for Docker Desktop"
          ],
          "correctAnswer": 1,
          "explanation": "A Dockerfile contains instructions for building a Docker image."
        },
        {
          "question": "What's the difference between an image and a container?",
          "options": [
            "No difference",
            "Image is the blueprint, container is a running instance",
            "Image is for Linux, container is for Windows",
            "Image is smaller than container"
          ],
          "correctAnswer": 1,
          "explanation": "An image is the template, a container is a running instance of that image."
        },
        {
          "question": "What does 'docker run -p 3000:8080 my-app' do?",
          "options": [
            "Maps port 3000 on your computer to port 8080 in the container",
            "Runs 3000 containers",
            "Sets the version to 3000",
            "Opens port 3000 and 8080"
          ],
          "correctAnswer": 0,
          "explanation": "-p 3000:8080 maps local port 3000 to container port 8080, so localhost:3000 reaches the container."
        },
        {
          "question": "When is Docker most useful?",
          "options": [
            "For all projects always",
            "When you need consistent environments across dev/staging/prod",
            "Only for websites",
            "Never, VMs are better"
          ],
          "correctAnswer": 1,
          "explanation": "Docker shines when you need consistent, reproducible environments across different stages and machines."
        }
      ]
    },
    {
      "id": "devops-ex-4",
      "lessonId": "deployment-strategies",
      "moduleId": "devops-basics",
      "title": "Deployment Strategy Selection",
      "difficulty": "medium",
      "description": "Match deployment strategies to scenarios.",
      "instructions": "Choose the best deployment strategy for each situation.",
      "type": "quiz",
      "questions": [
        {
          "question": "You're deploying a critical banking app. You need instant rollback capability. Which strategy?",
          "options": [
            "Recreate (all at once)",
            "Rolling update",
            "Blue-green deployment",
            "Just push to production"
          ],
          "correctAnswer": 2,
          "explanation": "Blue-green allows instant rollback by switching traffic back to the old version."
        },
        {
          "question": "You want to test a risky change with 5% of users first. Which strategy?",
          "options": [
            "Recreate",
            "Blue-green",
            "Canary deployment",
            "Rolling update"
          ],
          "correctAnswer": 2,
          "explanation": "Canary deployment gradually rolls out to a small percentage first, then increases if no issues."
        },
        {
          "question": "What's the main disadvantage of 'recreate' deployment?",
          "options": [
            "Too slow",
            "Too expensive",
            "Causes downtime",
            "Requires too many servers"
          ],
          "correctAnswer": 2,
          "explanation": "Recreate deployment stops the old version before starting the new one, causing downtime."
        },
        {
          "question": "Why is a health check endpoint important?",
          "options": [
            "For user analytics",
            "To verify the app is ready before routing traffic",
            "For SEO",
            "To check code quality"
          ],
          "correctAnswer": 1,
          "explanation": "Health checks let load balancers know if a server is healthy and ready to receive traffic."
        },
        {
          "question": "Your personal blog has one server. Which deployment is most realistic?",
          "options": [
            "Blue-green (requires 2x servers)",
            "Canary (requires multiple servers)",
            "Rolling update (requires multiple servers)",
            "Recreate (simple, just restart)"
          ],
          "correctAnswer": 3,
          "explanation": "With one server, recreate is simplest. A few seconds of downtime is acceptable for a personal blog."
        }
      ]
    },
    {
      "id": "devops-ex-5",
      "lessonId": "monitoring-basics",
      "moduleId": "devops-basics",
      "title": "Monitoring Best Practices",
      "difficulty": "easy",
      "description": "Test your knowledge of monitoring and observability.",
      "type": "quiz",
      "questions": [
        {
          "question": "What should you monitor in production?",
          "options": [
            "Nothing, trust it works",
            "Only traffic numbers",
            "Errors, uptime, performance, and logs",
            "Just CPU usage"
          ],
          "correctAnswer": 2,
          "explanation": "Comprehensive monitoring includes errors, uptime, performance metrics, and logs."
        },
        {
          "question": "What is a health check endpoint?",
          "options": [
            "A page showing company benefits",
            "An endpoint that returns 200 OK if the app is healthy",
            "A medical service API",
            "User profile settings"
          ],
          "correctAnswer": 1,
          "explanation": "A health check endpoint (like /health) returns 200 if the app and its dependencies are working."
        },
        {
          "question": "When should you get alerted?",
          "options": [
            "For every single request",
            "Only for critical issues like site down or high error rates",
            "Never, just check manually",
            "Every time someone visits your site"
          ],
          "correctAnswer": 1,
          "explanation": "Alert on critical issues only to avoid alert fatigue. Don't alert on normal operations."
        },
        {
          "question": "What's error tracking (like Sentry) useful for?",
          "options": [
            "Preventing all errors",
            "Seeing stack traces and context when errors occur",
            "Writing error-free code",
            "Just logging to console"
          ],
          "correctAnswer": 1,
          "explanation": "Error tracking captures exceptions with stack traces, user context, and environment info to help debug."
        },
        {
          "question": "Why track response time (performance)?",
          "options": [
            "Just for fun",
            "To detect slowdowns before users complain",
            "It doesn't matter",
            "Only for gaming sites"
          ],
          "correctAnswer": 1,
          "explanation": "Monitoring response times helps you detect performance degradation and fix it proactively."
        }
      ]
    }
  ]
}
