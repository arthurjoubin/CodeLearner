{
  "module": {
    "id": "express-middleware",
    "title": "Express: Advanced Middleware",
    "description": "Master Express middlewares: creation, chaining, error handling, and essential middlewares",
    "icon": "Layers",
    "requiredXp": 500,
    "color": "from-orange-500 to-red-500",
    "courseId": "node-express"
  },
  "lessons": [
    {
      "id": "middleware-concept",
      "moduleId": "express-middleware",
      "title": "The Middleware Concept",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- A middleware is a function with (req, res, next)\n- Executed in order of declaration\n- `next()` passes to the next middleware\n- Can modify req/res, stop the chain, or pass to the next\n\n---\n\n# Understanding Middlewares\n\nMiddlewares are the heart of Express. They are functions that have access to:\n- **req**: the request object\n- **res**: the response object\n- **next**: function to pass to the next middleware\n\n## Middleware Signature\n\n```javascript\nfunction myMiddleware(req, res, next) {\n  // Do something with req/res\n  console.log('Request:', req.method, req.url);\n  \n  // Pass to next (otherwise the request stays blocked!)\n  next();\n}\n\n// Arrow function\nconst logger = (req, res, next) => {\n  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);\n  next();\n};\n```\n\n## Three Types of Middlewares\n\n### 1. Application-level\n```javascript\n// Applies to all routes\napp.use(logger);\n\n// Applies to a specific path\napp.use('/api', authMiddleware);\n```\n\n### 2. Router-level\n```javascript\nconst router = express.Router();\n\n// Middleware for this router only\nrouter.use(validateUser);\n\nrouter.get('/', getUsers);\nrouter.post('/', createUser);\n```\n\n### 3. Route-specific\n```javascript\n// Middleware for a single route\napp.get('/admin', requireAuth, requireAdmin, (req, res) => {\n  res.json({ message: 'Admin area' });\n});\n```\n\n## Execution Order\n\nMiddlewares execute in the order they are defined:\n\n```javascript\n// 1. Global logger\napp.use((req, res, next) => {\n  console.log('1. Logger');\n  next();\n});\n\n// 2. Auth for /admin only\napp.use('/admin', (req, res, next) => {\n  console.log('2. Auth middleware');\n  next();\n});\n\n// 3. Route\napp.get('/admin', (req, res) => {\n  console.log('3. Route handler');\n  res.send('Admin');\n});\n\n// GET /admin request displays:\n// 1. Logger\n// 2. Auth middleware\n// 3. Route handler\n```\n\n## Middlewares Can Stop the Chain\n\n```javascript\n// Authentication middleware\nconst requireAuth = (req, res, next) => {\n  const token = req.headers.authorization;\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Authentication required' });\n  }\n  \n  // If authenticated, continue\n  next();\n};\n\n// If no token: stops with 401\n// If token exists: continues to route\napp.get('/protected', requireAuth, (req, res) => {\n  res.json({ message: 'Secret data' });\n});\n```\n\n## Middlewares Can Modify req/res\n\n```javascript\n// Add data to request\napp.use((req, res, next) => {\n  req.timestamp = Date.now();\n  req.user = { id: '123', role: 'admin' };\n  next();\n});\n\n// Later in routes:\napp.get('/data', (req, res) => {\n  console.log(req.timestamp);  // Available here!\n  console.log(req.user.role);  // Also available\n});\n```"
    },
    {
      "id": "middleware-common",
      "moduleId": "express-middleware",
      "title": "Essential Middlewares",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- cors: Handle cross-origin requests\n- helmet: Secure with HTTP headers\n- morgan: Log HTTP requests\n- compression: Compress responses\n- rate-limiter: Limit the number of requests\n\n---\n\n# Essential Middlewares\n\n## CORS (Cross-Origin Resource Sharing)\n\nBy default, browsers block requests between different domains. CORS allows controlling who can access your API.\n\n```bash\nnpm install cors\n```\n\n```javascript\nimport cors from 'cors';\n\n// Allow all origins (development only!)\napp.use(cors());\n\n// Production configuration\napp.use(cors({\n  origin: ['https://my-site.com', 'https://app.my-site.com'],\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  credentials: true  // Allow cookies\n}));\n\n// Route specific\napp.get('/public', cors(), (req, res) => {\n  res.json({ public: true });\n});\n```\n\n## Helmet (Security)\n\nHelmet automatically configures security headers:\n\n```bash\nnpm install helmet\n```\n\n```javascript\nimport helmet from 'helmet';\n\n// Default configuration (recommended)\napp.use(helmet());\n\n// Custom configuration\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", 'https:', \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:']\n    }\n  },\n  crossOriginEmbedderPolicy: false\n}));\n```\n\nHeaders added:\n- `Content-Security-Policy`: Prevent XSS\n- `X-Frame-Options`: Prevent clickjacking\n- `X-Content-Type-Options`: Prevent MIME sniffing\n- `Strict-Transport-Security`: Force HTTPS\n\n## Morgan (HTTP Logging)\n\n```bash\nnpm install morgan\n```\n\n```javascript\nimport morgan from 'morgan';\n\n// Predefined formats\napp.use(morgan('dev'));      // Concise for dev\napp.use(morgan('combined')); // Complete (Apache style)\napp.use(morgan('tiny'));     // Minimal\napp.use(morgan('short'));    // Short\n\n// Custom format\napp.use(morgan(':method :url :status :res[content-length] - :response-time ms'));\n\n// Log to file\nimport { createWriteStream } from 'fs';\nconst accessLogStream = createWriteStream('./access.log', { flags: 'a' });\napp.use(morgan('combined', { stream: accessLogStream }));\n```\n\n## Compression (Response Compression)\n\n```bash\nnpm install compression\n```\n\n```javascript\nimport compression from 'compression';\n\n// Compress all responses\napp.use(compression());\n\n// Custom filter\napp.use(compression({\n  filter: (req, res) => {\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    return compression.filter(req, res);\n  },\n  level: 6  // Compression level (1-9)\n}));\n```\n\n## Rate Limiting\n\n```bash\nnpm install express-rate-limit\n```\n\n```javascript\nimport rateLimit from 'express-rate-limit';\n\n// General limit\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,  // 15 minutes\n  max: 100,  // 100 requests per window\n  message: 'Too many requests from this IP'\n});\napp.use(limiter);\n\n// Strict limit for auth routes\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,  // 5 attempts\n  skipSuccessfulRequests: true\n});\napp.use('/auth/', authLimiter);\n```\n\n## Complete Security Setup\n\n```javascript\nimport express from 'express';\nimport helmet from 'helmet';\nimport cors from 'cors';\nimport morgan from 'morgan';\nimport compression from 'compression';\nimport rateLimit from 'express-rate-limit';\n\nconst app = express();\n\n// Security\napp.use(helmet());\napp.use(cors({\n  origin: process.env.ALLOWED_ORIGINS?.split(',') || 'http://localhost:3000'\n}));\n\n// Logging\napp.use(morgan('dev'));\n\n// Performance\napp.use(compression());\n\n// Rate limiting\napp.use(rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100\n}));\n\n// Body parsing\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Routes...\n```"
    },
    {
      "id": "middleware-custom",
      "moduleId": "express-middleware",
      "title": "Creating Custom Middlewares",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Create reusable middlewares for your business logic\n- Factor out authentication, validation, logging\n- Middlewares can be asynchronous\n- Always handle errors with try/catch\n\n---\n\n# Essential Custom Middlewares\n\n## 1. Authentication\n\n```javascript\n// middleware/auth.js\nimport jwt from 'jsonwebtoken';\n\nexport const requireAuth = (req, res, next) => {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader?.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'Token missing' });\n  }\n  \n  const token = authHeader.substring(7);\n  \n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    req.userId = decoded.userId;\n    next();\n  } catch (err) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n};\n\n// Variant with full user retrieval\nexport const loadUser = async (req, res, next) => {\n  const token = req.headers.authorization?.substring(7);\n  \n  if (token) {\n    try {\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\n      req.user = await User.findById(decoded.userId);\n    } catch {\n      // Invalid token, continue without user\n    }\n  }\n  \n  next();\n};\n```\n\n## 2. Validation with Zod\n\n```javascript\n// middleware/validate.js\nimport { z } from 'zod';\n\nexport const validate = (schema) => {\n  return (req, res, next) => {\n    try {\n      schema.parse({\n        body: req.body,\n        query: req.query,\n        params: req.params\n      });\n      next();\n    } catch (err) {\n      if (err instanceof z.ZodError) {\n        return res.status(400).json({\n          error: 'Validation failed',\n          details: err.errors\n        });\n      }\n      next(err);\n    }\n  };\n};\n\n// Usage\nconst createUserSchema = z.object({\n  body: z.object({\n    email: z.string().email(),\n    password: z.string().min(8),\n    name: z.string().min(2)\n  })\n});\n\napp.post('/users', validate(createUserSchema), createUser);\n```\n\n## 3. Request Logger with ID\n\n```javascript\n// middleware/requestLogger.js\nimport { v4 as uuidv4 } from 'uuid';\n\nexport const requestLogger = (req, res, next) => {\n  req.id = uuidv4();\n  const start = Date.now();\n  \n  console.log(`[${req.id}] ${req.method} ${req.url} - Start`);\n  \n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(\n      `[${req.id}] ${req.method} ${req.url} - ${res.statusCode} - ${duration}ms`\n    );\n  });\n  \n  next();\n};\n```\n\n## 4. Async Handler Wrapper\n\n```javascript\n// middleware/asyncHandler.js\nexport const asyncHandler = (fn) => {\n  return (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n\n// Usage\napp.get('/users', asyncHandler(async (req, res) => {\n  const users = await User.findAll();  // If rejected, caught automatically\n  res.json(users);\n}));\n```\n\n## 5. Request Timing\n\n```javascript\n// middleware/timing.js\nexport const addTiming = (req, res, next) => {\n  req.startTime = Date.now();\n  \n  // Add method to get duration\n  req.getDuration = () => Date.now() - req.startTime;\n  \n  // Add to response headers\n  res.on('finish', () => {\n    res.setHeader('X-Response-Time', `${req.getDuration()}ms`);\n  });\n  \n  next();\n};\n```\n\n## 6. Maintenance Mode\n\n```javascript\n// middleware/maintenance.js\nexport const maintenanceMode = (req, res, next) => {\n  if (process.env.MAINTENANCE_MODE === 'true') {\n    return res.status(503).json({\n      error: 'Maintenance in progress',\n      retryAfter: 3600\n    });\n  }\n  next();\n};\n```\n\n## 7. API Versioning\n\n```javascript\n// middleware/version.js\nexport const apiVersion = (version) => {\n  return (req, res, next) => {\n    req.apiVersion = version;\n    res.setHeader('X-API-Version', version);\n    next();\n  };\n};\n\n// Routes\napp.use('/api/v1', apiVersion('1.0.0'), v1Router);\napp.use('/api/v2', apiVersion('2.0.0'), v2Router);\n```\n\n## Organization: middleware/index.js\n\n```javascript\n// middleware/index.js\nexport { requireAuth, loadUser } from './auth.js';\nexport { validate } from './validate.js';\nexport { requestLogger } from './requestLogger.js';\nexport { asyncHandler } from './asyncHandler.js';\nexport { errorHandler } from './errorHandler.js';\n```\n\n```javascript\n// app.js\nimport { requireAuth, validate, requestLogger } from './middleware/index.js';\n\napp.use(requestLogger);\napp.use('/api/protected', requireAuth);\n```"
    },
    {
      "id": "middleware-error",
      "moduleId": "express-middleware",
      "title": "Error Handling",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Errors in middlewares/routes are caught by the error handler\n- Error handler = middleware with 4 parameters: (err, req, res, next)\n- Must be defined AFTER all other routes\n- Differentiate dev vs prod for error messages\n\n---\n\n# Centralized Error Handling\n\nExpress automatically captures synchronous errors. For asynchronous errors, use a wrapper or async/await with try/catch.\n\n## Basic Error Handler\n\n```javascript\n// Always 4 parameters!\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Something broke!' });\n});\n```\n\n## Advanced Error Handler\n\n```javascript\n// utils/errors.js\nexport class AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = true;  // Expected error vs bug\n    \n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(message) {\n    super(message, 400);\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(resource) {\n    super(`${resource} not found`, 404);\n  }\n}\n\nexport class UnauthorizedError extends AppError {\n  constructor(message = 'Unauthorized') {\n    super(message, 401);\n  }\n}\n```\n\n```javascript\n// middleware/errorHandler.js\nexport const errorHandler = (err, req, res, next) => {\n  err.statusCode = err.statusCode || 500;\n  err.message = err.message || 'Server error';\n  \n  // Operational errors (expected) vs programming (bugs)\n  if (err.isOperational) {\n    return res.status(err.statusCode).json({\n      status: 'error',\n      message: err.message\n    });\n  }\n  \n  // Programming errors: don't leak details in production\n  console.error('ERROR ðŸ’¥', err);\n  \n  if (process.env.NODE_ENV === 'production') {\n    return res.status(500).json({\n      status: 'error',\n      message: 'Something went wrong'\n    });\n  }\n  \n  // In development, show full details\n  return res.status(500).json({\n    status: 'error',\n    message: err.message,\n    stack: err.stack,\n    error: err\n  });\n};\n```\n\n## Usage in Routes\n\n```javascript\nimport { NotFoundError, ValidationError } from '../utils/errors.js';\n\n// Throw errors (Express catches them)\napp.get('/users/:id', async (req, res, next) => {\n  const user = await User.findById(req.params.id);\n  \n  if (!user) {\n    throw new NotFoundError('User');\n  }\n  \n  res.json(user);\n});\n\n// Or with next()\napp.post('/users', (req, res, next) => {\n  if (!req.body.email) {\n    return next(new ValidationError('Email is required'));\n  }\n  // ...\n});\n```\n\n## Async Error Handling\n\n```javascript\n// Option 1: Wrapper\nconst catchAsync = (fn) => {\n  return (req, res, next) => {\n    fn(req, res, next).catch(next);\n  };\n};\n\napp.get('/users', catchAsync(async (req, res) => {\n  const users = await User.findAll();\n  res.json(users);\n}));\n\n// Option 2: Try/catch\napp.get('/users', async (req, res, next) => {\n  try {\n    const users = await User.findAll();\n    res.json(users);\n  } catch (err) {\n    next(err);  // Pass to error handler\n  }\n});\n```\n\n## 404 Handler\n\n```javascript\n// Place after all routes\napp.all('*', (req, res, next) => {\n  next(new NotFoundError(`Route ${req.originalUrl} not found`));\n});\n\n// Then error handler\napp.use(errorHandler);\n```\n\n## Complete Error Handling Setup\n\n```javascript\n// app.js\nimport express from 'express';\nimport { errorHandler } from './middleware/errorHandler.js';\nimport { NotFoundError } from './utils/errors.js';\nimport routes from './routes/index.js';\n\nconst app = express();\n\n// Middlewares...\napp.use(express.json());\n\n// Routes\napp.use('/api', routes);\n\n// 404 - Must be after all routes\napp.all('*', (req, res, next) => {\n  next(new NotFoundError(`Route ${req.originalUrl} not found`));\n});\n\n// Global error handler - Must be last!\napp.use(errorHandler);\n\nexport default app;\n```"
    }
  ],
  "exercises": []
}
