{
  "module": {
    "id": "auth-oauth",
    "title": "Auth: OAuth and Social Login",
    "description": "Implement authentication with Google, GitHub and other OAuth providers",
    "icon": "LogIn",
    "requiredXp": 1300,
    "color": "from-blue-500 to-cyan-500",
    "courseId": "auth-security"
  },
  "lessons": [
    {
      "id": "oauth-flow",
      "moduleId": "auth-oauth",
      "title": "OAuth 2.0 Flow",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- OAuth 2.0 = authorization protocol (not authentication)\n- Authorization Code Flow = most secure flow for server-side apps\n- PKCE (Proof Key for Code Exchange) for mobile apps and SPAs\n- OpenID Connect (OIDC) adds authentication layer on top of OAuth\n- Redirect URIs must be registered and exact-match for security\n- Access tokens are short-lived; refresh tokens are long-lived\n\n---\n\n# Understanding OAuth 2.0\n\n## The Problem OAuth Solves\n\nHow do you let a third-party application access user data WITHOUT sharing passwords?\n\n**Example**: A fitness app wants to access your Google Calendar to schedule workouts.\n❌ You don't want to give your Google password to the fitness app!\n\n## OAuth 2.0 Authorization Code Flow\n\nThis is the most secure flow for server-side applications:\n\n```\nStep 1: User clicks \"Login with Google\" on your app\nStep 2: Your app redirects to Google: /oauth/authorize?client_id=...\nStep 3: User authenticates with Google and approves permissions\nStep 4: Google redirects back to your app with an authorization CODE\nStep 5: Your server exchanges the CODE for TOKENS (server-to-server)\nStep 6: You receive access_token and optionally refresh_token\nStep 7: Use access_token to fetch user info or make API calls\n```\n\n## Key Components\n\n| Component | Purpose | Example |\n|-----------|---------|---------|\n| Client ID | Public identifier for your app | `123456.apps.googleusercontent.com` |\n| Client Secret | Private key for token exchange | Keep this secret! |\n| Authorization Code | Temporary code (valid ~10 min) | `4/0Ab...` |\n| Access Token | Short-lived token for API calls | Valid 1 hour |\n| Refresh Token | Long-lived token to get new access tokens | Valid until revoked |\n| Redirect URI | Where provider sends the user back | `https://myapp.com/auth/callback` |\n\n## Security: Redirect URI Validation\n\nThe redirect URI is critical for security. OAuth providers validate it exactly:\n\n```javascript\n// Registered: https://myapp.com/auth/callback\n// These will FAIL:\nhttps://myapp.com/auth/callback?extra=param    // Query params differ\nhttps://myapp.com/auth/callback/               // Trailing slash\nhttp://myapp.com/auth/callback                 // HTTP instead of HTTPS\n\n// These will SUCCEED:\nhttps://myapp.com/auth/callback\n```\n\n## Authorization URL Parameters\n\n```javascript\nconst authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');\n\nauthUrl.searchParams.set('client_id', CLIENT_ID);\nauthUrl.searchParams.set('redirect_uri', 'https://myapp.com/auth/callback');\nauthUrl.searchParams.set('response_type', 'code');  // Request authorization code\nauthUrl.searchParams.set('scope', 'openid email profile');  // What you want access to\nauthUrl.searchParams.set('state', generateRandomState());  // CSRF protection\nauthUrl.searchParams.set('access_type', 'offline');  // Request refresh token\n\n// Redirect user to authUrl.toString()\n```\n\n## Exchanging the Code for Tokens\n\n```javascript\n// Server-side only - never do this in browser!\nconst response = await fetch('https://oauth2.googleapis.com/token', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n  body: new URLSearchParams({\n    code: authorizationCode,\n    client_id: CLIENT_ID,\n    client_secret: CLIENT_SECRET,  // Never expose this client-side\n    redirect_uri: 'https://myapp.com/auth/callback',\n    grant_type: 'authorization_code'\n  })\n});\n\nconst tokens = await response.json();\n// { access_token, refresh_token, expires_in, token_type }\n```\n\n## PKCE for SPAs and Mobile Apps\n\nPKCE (Proof Key for Code Exchange) prevents authorization code interception attacks:\n\n```javascript\n// 1. Generate PKCE parameters (client-side)\nconst codeVerifier = generateRandomString(128);  // Store this!\nconst codeChallenge = base64UrlEncode(sha256(codeVerifier));\n\n// 2. Include in authorization request\nauthUrl.searchParams.set('code_challenge', codeChallenge);\nauthUrl.searchParams.set('code_challenge_method', 'S256');\n\n// 3. When exchanging code, include verifier\nbody: new URLSearchParams({\n  code: authorizationCode,\n  client_id: CLIENT_ID,\n  code_verifier: codeVerifier,  // Proves you initiated the flow\n  grant_type: 'authorization_code'\n})\n```",
      "codeExample": {
        "language": "javascript",
        "code": "// Complete OAuth 2.0 flow implementation\nimport crypto from 'crypto';\n\n// Step 1: Generate authorization URL\nfunction getGoogleAuthUrl() {\n  const state = crypto.randomBytes(32).toString('hex');\n  \n  const params = new URLSearchParams({\n    client_id: process.env.GOOGLE_CLIENT_ID,\n    redirect_uri: `${process.env.APP_URL}/auth/google/callback`,\n    response_type: 'code',\n    scope: 'openid email profile',\n    state: state,\n    access_type: 'offline',\n    prompt: 'consent'  // Force consent screen to get refresh token\n  });\n  \n  // Store state in session for CSRF protection\n  session.oauthState = state;\n  \n  return `https://accounts.google.com/o/oauth2/v2/auth?${params}`;\n}\n\n// Step 2: Handle callback and exchange code\nasync function handleGoogleCallback(code, state) {\n  // Verify state to prevent CSRF\n  if (state !== session.oauthState) {\n    throw new Error('Invalid state parameter');\n  }\n  \n  // Exchange code for tokens\n  const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({\n      code,\n      client_id: process.env.GOOGLE_CLIENT_ID,\n      client_secret: process.env.GOOGLE_CLIENT_SECRET,\n      redirect_uri: `${process.env.APP_URL}/auth/google/callback`,\n      grant_type: 'authorization_code'\n    })\n  });\n  \n  if (!tokenResponse.ok) {\n    throw new Error('Failed to exchange code for tokens');\n  }\n  \n  const tokens = await tokenResponse.json();\n  \n  // Step 3: Fetch user info with access token\n  const userResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {\n    headers: { Authorization: `Bearer ${tokens.access_token}` }\n  });\n  \n  const userInfo = await userResponse.json();\n  \n  return {\n    user: userInfo,\n    accessToken: tokens.access_token,\n    refreshToken: tokens.refresh_token,  // May be null if already authorized\n    expiresAt: Date.now() + (tokens.expires_in * 1000)\n  };\n}"
      }
    },
    {
      "id": "social-login-implementation",
      "moduleId": "auth-oauth",
      "title": "Implementing Social Login",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Each provider (Google, GitHub, Discord) has slightly different OAuth implementations\n- Callback handling is critical - must verify state and handle errors\n- Account linking: connect OAuth to existing email accounts\n- Handle edge cases: denied permissions, revoked access, expired tokens\n- Always implement proper logout that revokes sessions\n\n---\n\n# Setting Up OAuth with Popular Providers\n\n## Google OAuth Setup\n\n**1. Create credentials in Google Cloud Console:**\n- Go to APIs & Services → Credentials\n- Create OAuth 2.0 Client ID\n- Add authorized redirect URIs (e.g., `http://localhost:3000/auth/google/callback`)\n\n**2. Configure consent screen:**\n- App name, user support email\n- Authorized domains\n- Scopes (openid, email, profile)\n\n**3. Implementation:**\n```javascript\n// Google returns standardized OpenID Connect claims\nconst googleUser = {\n  id: '123456789',\n  email: 'user@gmail.com',\n  name: 'John Doe',\n  picture: 'https://lh3.googleusercontent.com/...',\n  verified_email: true\n};\n```\n\n## GitHub OAuth Setup\n\n**1. Register application:**\n- Go to Settings → Developer settings → OAuth Apps\n- Set Homepage URL and Authorization callback URL\n\n**2. Key differences from Google:**\n- GitHub uses a different authorization endpoint\n- Scopes are comma-separated (not space-separated)\n- Does not support OpenID Connect (no id_token)\n\n```javascript\n// GitHub OAuth URLs\nconst GITHUB_AUTH_URL = 'https://github.com/login/oauth/authorize';\nconst GITHUB_TOKEN_URL = 'https://github.com/login/oauth/access_token';\nconst GITHUB_API_URL = 'https://api.github.com';\n\n// Authorization request\nconst params = new URLSearchParams({\n  client_id: GITHUB_CLIENT_ID,\n  redirect_uri: 'http://localhost:3000/auth/github/callback',\n  scope: 'read:user,user:email',  // Comma-separated!\n  state: generateState()\n});\n\n// Fetch user info (requires separate API call)\nconst userResponse = await fetch(`${GITHUB_API_URL}/user`, {\n  headers: {\n    Authorization: `Bearer ${accessToken}`,\n    Accept: 'application/vnd.github.v3+json'\n  }\n});\n```\n\n## Discord OAuth Setup\n\n```javascript\nconst DISCORD_AUTH_URL = 'https://discord.com/api/oauth2/authorize';\nconst DISCORD_TOKEN_URL = 'https://discord.com/api/oauth2/token';\nconst DISCORD_API_URL = 'https://discord.com/api/v10';\n\n// Authorization\nconst params = new URLSearchParams({\n  client_id: DISCORD_CLIENT_ID,\n  redirect_uri: 'http://localhost:3000/auth/discord/callback',\n  response_type: 'code',\n  scope: 'identify email',\n  state: generateState()\n});\n\n// User info\nconst userResponse = await fetch(`${DISCORD_API_URL}/users/@me`, {\n  headers: { Authorization: `Bearer ${accessToken}` }\n});\n```\n\n## Handling OAuth Callbacks\n\nYour callback handler must handle multiple scenarios:\n\n```javascript\napp.get('/auth/:provider/callback', async (req, res) => {\n  const { provider } = req.params;\n  const { code, state, error, error_description } = req.query;\n  \n  // 1. Handle user denial\n  if (error === 'access_denied') {\n    return res.redirect('/login?error=user_denied');\n  }\n  \n  // 2. Handle other errors\n  if (error) {\n    console.error('OAuth error:', error_description);\n    return res.redirect('/login?error=oauth_failed');\n  }\n  \n  // 3. Validate state parameter (CSRF protection)\n  if (state !== req.session.oauthState) {\n    return res.status(403).send('Invalid state parameter');\n  }\n  \n  // 4. Exchange code for tokens\n  try {\n    const tokens = await exchangeCodeForTokens(provider, code);\n    const userInfo = await fetchUserInfo(provider, tokens.access_token);\n    \n    // 5. Link or create user account\n    const user = await findOrCreateUser(provider, userInfo);\n    \n    // 6. Create session\n    req.session.userId = user.id;\n    res.redirect('/dashboard');\n    \n  } catch (err) {\n    console.error('OAuth callback error:', err);\n    res.redirect('/login?error=authentication_failed');\n  }\n});\n```\n\n## Account Linking Strategy\n\nWhen a user with an existing account logs in via OAuth:\n\n```javascript\nasync function findOrCreateUser(provider, oauthUser) {\n  // Strategy 1: Link by OAuth provider ID\n  let user = await db.findUserByOAuthId(provider, oauthUser.id);\n  if (user) return user;\n  \n  // Strategy 2: Link by verified email\n  if (oauthUser.verified_email || oauthUser.verified) {\n    user = await db.findUserByEmail(oauthUser.email);\n    if (user) {\n      // Link OAuth to existing account\n      await db.linkOAuthAccount(user.id, {\n        provider,\n        providerId: oauthUser.id,\n        email: oauthUser.email\n      });\n      return user;\n    }\n  }\n  \n  // Strategy 3: Create new account\n  return await db.createUser({\n    email: oauthUser.email,\n    name: oauthUser.name,\n    avatar: oauthUser.picture || oauthUser.avatar_url,\n    oauthAccounts: [{\n      provider,\n      providerId: oauthUser.id,\n      email: oauthUser.email\n    }]\n  });\n}\n```\n\n## Multiple OAuth Providers\n\nAllow users to connect multiple OAuth accounts to one profile:\n\n```sql\n-- OAuth accounts table\nCREATE TABLE oauth_accounts (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\n  provider VARCHAR(50) NOT NULL,  -- 'google', 'github', 'discord'\n  provider_id VARCHAR(255) NOT NULL,\n  email VARCHAR(255),\n  created_at TIMESTAMP DEFAULT NOW(),\n  UNIQUE(provider, provider_id)\n);\n```",
      "codeExample": {
        "language": "javascript",
        "code": "// Multi-provider OAuth implementation\nclass OAuthManager {\n  constructor() {\n    this.providers = {\n      google: {\n        authUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n        tokenUrl: 'https://oauth2.googleapis.com/token',\n        userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',\n        scopes: 'openid email profile'\n      },\n      github: {\n        authUrl: 'https://github.com/login/oauth/authorize',\n        tokenUrl: 'https://github.com/login/oauth/access_token',\n        userInfoUrl: 'https://api.github.com/user',\n        scopes: 'read:user user:email'\n      },\n      discord: {\n        authUrl: 'https://discord.com/api/oauth2/authorize',\n        tokenUrl: 'https://discord.com/api/oauth2/token',\n        userInfoUrl: 'https://discord.com/api/v10/users/@me',\n        scopes: 'identify email'\n      }\n    };\n  }\n  \n  getAuthUrl(provider, redirectUri) {\n    const config = this.providers[provider];\n    const state = crypto.randomBytes(32).toString('hex');\n    \n    const params = new URLSearchParams({\n      client_id: process.env[`${provider.toUpperCase()}_CLIENT_ID`],\n      redirect_uri: redirectUri,\n      response_type: 'code',\n      scope: config.scopes,\n      state: state\n    });\n    \n    // Google-specific: request refresh token\n    if (provider === 'google') {\n      params.set('access_type', 'offline');\n      params.set('prompt', 'consent');\n    }\n    \n    return { url: `${config.authUrl}?${params}`, state };\n  }\n  \n  async exchangeCode(provider, code, redirectUri) {\n    const config = this.providers[provider];\n    const clientId = process.env[`${provider.toUpperCase()}_CLIENT_ID`];\n    const clientSecret = process.env[`${provider.toUpperCase()}_CLIENT_SECRET`];\n    \n    const response = await fetch(config.tokenUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      body: new URLSearchParams({\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n        redirect_uri: redirectUri,\n        grant_type: 'authorization_code'\n      })\n    });\n    \n    return await response.json();\n  }\n  \n  normalizeUserInfo(provider, rawInfo) {\n    // Normalize different provider formats to consistent structure\n    const normalizers = {\n      google: (info) => ({\n        id: info.id,\n        email: info.email,\n        name: info.name,\n        avatar: info.picture,\n        verified: info.verified_email\n      }),\n      github: (info) => ({\n        id: info.id.toString(),\n        email: info.email,\n        name: info.name || info.login,\n        avatar: info.avatar_url,\n        verified: true  // GitHub requires verified email for OAuth\n      }),\n      discord: (info) => ({\n        id: info.id,\n        email: info.email,\n        name: info.global_name || info.username,\n        avatar: info.avatar \n          ? `https://cdn.discordapp.com/avatars/${info.id}/${info.avatar}.png`\n          : null,\n        verified: info.verified\n      })\n    };\n    \n    return normalizers[provider](rawInfo);\n  }\n}"
      }
    },
    {
      "id": "token-management",
      "moduleId": "auth-oauth",
      "title": "Token Management",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Access tokens are short-lived (typically 1 hour) for security\n- Refresh tokens are long-lived and must be stored securely\n- Never store tokens in localStorage - use httpOnly cookies\n- Silent refresh allows seamless user experience without re-authentication\n- Token revocation happens when users disconnect OAuth apps\n- Monitor token expiration and refresh proactively\n\n---\n\n# Access Tokens vs Refresh Tokens\n\n## Access Tokens\n\n```javascript\n// Characteristics\n- Short-lived: 15 minutes to 1 hour\n- Used for API calls: Authorization: Bearer <token>\n- Contains user permissions/scopes\n- JWT format (can be decoded client-side)\n\n// Example JWT payload\n{\n  \"sub\": \"1234567890\",\n  \"email\": \"user@example.com\",\n  \"scope\": \"openid email profile\",\n  \"iat\": 1516239022,\n  \"exp\": 1516242622  // Expires in 1 hour\n}\n```\n\n## Refresh Tokens\n\n```javascript\n// Characteristics\n- Long-lived: days, months, or until revoked\n- Used only to get new access tokens\n- Must be stored securely (database, encrypted)\n- Single-use or rotating (security best practice)\n- Can be revoked by user or provider\n\n// Token rotation (recommended)\nWhen you use refresh_token to get new tokens:\n- Receive NEW access_token + NEW refresh_token\n- Invalidate old refresh_token\n- Store new refresh_token\n// This limits damage if a token is stolen\n```\n\n## Token Storage Security\n\n### ❌ Never Do This\n\n```javascript\n// NEVER store in localStorage or sessionStorage\nlocalStorage.setItem('access_token', token);  // XSS vulnerable!\nlocalStorage.setItem('refresh_token', token); // Very dangerous\n\n// NEVER return tokens to client in API responses\nres.json({ accessToken, refreshToken });  // Wrong!\n```\n\n### ✅ Do This Instead\n\n```javascript\n// Server-side: Store in database\nawait db.updateUser(userId, {\n  oauth_refresh_token: encrypt(refreshToken),\n  token_expires_at: new Date(Date.now() + expiresIn * 1000)\n});\n\n// Server-side: Set access token in httpOnly cookie\nres.cookie('session', accessToken, {\n  httpOnly: true,      // Not accessible via JavaScript\n  secure: true,        // HTTPS only\n  sameSite: 'strict',  // CSRF protection\n  maxAge: 3600000      // 1 hour\n});\n\n// Or use session-based auth\nreq.session.userId = user.id;\n// Session ID in cookie, tokens stored server-side\n```\n\n## Refreshing Access Tokens\n\n```javascript\nasync function refreshAccessToken(userId) {\n  const user = await db.getUser(userId);\n  const refreshToken = decrypt(user.oauth_refresh_token);\n  \n  const response = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({\n      refresh_token: refreshToken,\n      client_id: process.env.GOOGLE_CLIENT_ID,\n      client_secret: process.env.GOOGLE_CLIENT_SECRET,\n      grant_type: 'refresh_token'\n    })\n  });\n  \n  if (!response.ok) {\n    // Refresh token revoked or expired\n    if (response.status === 400) {\n      // Force re-authentication\n      throw new Error('REFRESH_TOKEN_INVALID');\n    }\n    throw new Error('Token refresh failed');\n  }\n  \n  const tokens = await response.json();\n  \n  // Google may return new refresh token (rotation)\n  if (tokens.refresh_token) {\n    await db.updateUser(userId, {\n      oauth_refresh_token: encrypt(tokens.refresh_token)\n    });\n  }\n  \n  // Update access token expiration\n  await db.updateUser(userId, {\n    access_token_expires_at: new Date(Date.now() + tokens.expires_in * 1000)\n  });\n  \n  return tokens.access_token;\n}\n```\n\n## Silent Refresh (Automatic Token Refresh)\n\nKeep users logged in without interruptions:\n\n```javascript\n// Middleware: Auto-refresh expiring tokens\nasync function tokenRefreshMiddleware(req, res, next) {\n  const userId = req.session.userId;\n  if (!userId) return next();\n  \n  const user = await db.getUser(userId);\n  const expiresAt = user.access_token_expires_at;\n  const fiveMinutes = 5 * 60 * 1000;\n  \n  // Refresh if expiring in less than 5 minutes\n  if (expiresAt && Date.now() > expiresAt - fiveMinutes) {\n    try {\n      await refreshAccessToken(userId);\n      console.log('Token refreshed automatically');\n    } catch (error) {\n      if (error.message === 'REFRESH_TOKEN_INVALID') {\n        // Clear session, force re-login\n        req.session.destroy();\n        return res.status(401).json({ error: 'Session expired' });\n      }\n    }\n  }\n  \n  next();\n}\n\n// Apply to all protected routes\napp.use('/api', tokenRefreshMiddleware);\n```\n\n## Token Revocation\n\nHandle when users revoke access:\n\n```javascript\n// Revoke on logout\nasync function revokeToken(token) {\n  await fetch('https://oauth2.googleapis.com/revoke', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({ token })\n  });\n}\n\napp.post('/logout', async (req, res) => {\n  const userId = req.session.userId;\n  \n  if (userId) {\n    const user = await db.getUser(userId);\n    \n    // Revoke refresh token with provider\n    if (user.oauth_refresh_token) {\n      try {\n        await revokeToken(decrypt(user.oauth_refresh_token));\n      } catch (e) {\n        console.error('Failed to revoke token:', e);\n      }\n    }\n    \n    // Clear from database\n    await db.updateUser(userId, {\n      oauth_refresh_token: null,\n      access_token_expires_at: null\n    });\n  }\n  \n  req.session.destroy();\n  res.clearCookie('session');\n  res.json({ success: true });\n});\n\n// Handle provider-initiated revocation\n// Some providers send webhook notifications\napp.post('/webhooks/token-revoked', async (req, res) => {\n  const { user_id, provider } = req.body;\n  \n  // Clear tokens for this user\n  await db.updateUserByProviderId(provider, user_id, {\n    oauth_refresh_token: null\n  });\n  \n  res.json({ success: true });\n});\n```\n\n## Making Authenticated API Calls\n\n```javascript\nclass OAuthApiClient {\n  constructor(userId) {\n    this.userId = userId;\n  }\n  \n  async request(url, options = {}) {\n    const user = await db.getUser(this.userId);\n    \n    // Check if token needs refresh\n    if (Date.now() > user.access_token_expires_at - 60000) {\n      await refreshAccessToken(this.userId);\n    }\n    \n    // Get fresh token\n    const freshUser = await db.getUser(this.userId);\n    const accessToken = freshUser.oauth_access_token;\n    \n    const response = await fetch(url, {\n      ...options,\n      headers: {\n        ...options.headers,\n        Authorization: `Bearer ${accessToken}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    \n    // Handle token expiration during request\n    if (response.status === 401) {\n      try {\n        await refreshAccessToken(this.userId);\n        // Retry request...\n      } catch {\n        throw new Error('Authentication failed');\n      }\n    }\n    \n    return response;\n  }\n}\n\n// Usage\nconst client = new OAuthApiClient(userId);\nconst response = await client.request('https://api.github.com/user/repos');\n```",
      "codeExample": {
        "language": "javascript",
        "code": "// Complete token management system\nimport crypto from 'crypto';\n\nclass TokenManager {\n  constructor(db, encryptionKey) {\n    this.db = db;\n    this.encryptionKey = encryptionKey;\n  }\n  \n  encrypt(text) {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipher('aes-256-gcm', this.encryptionKey);\n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    const authTag = cipher.getAuthTag();\n    return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;\n  }\n  \n  decrypt(encryptedData) {\n    const [ivHex, authTagHex, encrypted] = encryptedData.split(':');\n    const decipher = crypto.createDecipher('aes-256-gcm', this.encryptionKey);\n    decipher.setAuthTag(Buffer.from(authTagHex, 'hex'));\n    let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n  }\n  \n  async storeTokens(userId, tokens) {\n    const updates = {\n      oauth_access_token: tokens.access_token ? this.encrypt(tokens.access_token) : undefined,\n      oauth_refresh_token: tokens.refresh_token ? this.encrypt(tokens.refresh_token) : undefined,\n      token_expires_at: tokens.expires_in \n        ? new Date(Date.now() + tokens.expires_in * 1000)\n        : undefined\n    };\n    \n    await this.db.updateUser(userId, updates);\n  }\n  \n  async getValidAccessToken(userId) {\n    const user = await this.db.getUser(userId);\n    \n    if (!user.oauth_access_token) {\n      throw new Error('No access token found');\n    }\n    \n    const expiresAt = new Date(user.token_expires_at).getTime();\n    const fiveMinutes = 5 * 60 * 1000;\n    \n    // Refresh if expiring soon\n    if (Date.now() > expiresAt - fiveMinutes) {\n      return await this.refreshToken(userId);\n    }\n    \n    return this.decrypt(user.oauth_access_token);\n  }\n  \n  async refreshToken(userId, provider = 'google') {\n    const user = await this.db.getUser(userId);\n    \n    if (!user.oauth_refresh_token) {\n      throw new Error('REFRESH_TOKEN_INVALID');\n    }\n    \n    const refreshToken = this.decrypt(user.oauth_refresh_token);\n    const urls = {\n      google: 'https://oauth2.googleapis.com/token',\n      github: 'https://github.com/login/oauth/access_token',\n      discord: 'https://discord.com/api/oauth2/token'\n    };\n    \n    const response = await fetch(urls[provider], {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      body: new URLSearchParams({\n        refresh_token: refreshToken,\n        client_id: process.env[`${provider.toUpperCase()}_CLIENT_ID`],\n        client_secret: process.env[`${provider.toUpperCase()}_CLIENT_SECRET`],\n        grant_type: 'refresh_token'\n      })\n    });\n    \n    if (!response.ok) {\n      if (response.status === 400) {\n        // Clear invalid tokens\n        await this.clearTokens(userId);\n        throw new Error('REFRESH_TOKEN_INVALID');\n      }\n      throw new Error('Token refresh failed');\n    }\n    \n    const newTokens = await response.json();\n    await this.storeTokens(userId, newTokens);\n    \n    return newTokens.access_token;\n  }\n  \n  async clearTokens(userId) {\n    await this.db.updateUser(userId, {\n      oauth_access_token: null,\n      oauth_refresh_token: null,\n      token_expires_at: null\n    });\n  }\n}\n\n// Express middleware for automatic token refresh\nexport function createTokenRefreshMiddleware(tokenManager) {\n  return async (req, res, next) => {\n    if (!req.session?.userId) return next();\n    \n    try {\n      await tokenManager.getValidAccessToken(req.session.userId);\n      next();\n    } catch (error) {\n      if (error.message === 'REFRESH_TOKEN_INVALID') {\n        req.session.destroy();\n        res.clearCookie('session');\n        return res.status(401).json({ \n          error: 'Session expired',\n          code: 'REAUTHENTICATION_REQUIRED'\n        });\n      }\n      next(error);\n    }\n  };\n}"
      }
    }
  ],
  "exercises": [
    {
      "id": "oauth-flow-quiz",
      "moduleId": "auth-oauth",
      "lessonId": "oauth-flow",
      "title": "OAuth 2.0 Flow Quiz",
      "type": "quiz",
      "order": 1,
      "difficulty": "intermediate",
      "xpReward": 50,
      "content": "Test your understanding of OAuth 2.0 authorization code flow.",
      "questions": [
        {
          "question": "In the Authorization Code Flow, where should the client secret be used?",
          "options": [
            "In the browser when redirecting to the authorization server",
            "When exchanging the authorization code for tokens on the server",
            "In the URL parameters when requesting authorization",
            "In localStorage for quick access"
          ],
          "correctAnswer": 1,
          "explanation": "The client secret must never be exposed client-side. It's only used server-side when exchanging the authorization code for tokens."
        },
        {
          "question": "What is the purpose of the 'state' parameter in OAuth?",
          "options": [
            "To store user preferences",
            "To prevent CSRF attacks by maintaining state between request and callback",
            "To specify which OAuth provider to use",
            "To encrypt the authorization code"
          ],
          "correctAnswer": 1,
          "explanation": "The state parameter is a random value generated by your app that must be verified when the user returns. This prevents CSRF attacks where an attacker could trick a user into authenticating."
        },
        {
          "question": "What is PKCE used for?",
          "options": [
            "To make OAuth work faster",
            "To secure the Authorization Code Flow for public clients like SPAs and mobile apps",
            "To encrypt the access token",
            "To remember user login state"
          ],
          "correctAnswer": 1,
          "explanation": "PKCE (Proof Key for Code Exchange) prevents authorization code interception attacks by requiring a code verifier that only the legitimate client possesses."
        }
      ]
    },
    {
      "id": "implement-social-login",
      "moduleId": "auth-oauth",
      "lessonId": "social-login-implementation",
      "title": "Implement GitHub OAuth Login",
      "type": "code",
      "order": 2,
      "difficulty": "intermediate",
      "xpReward": 100,
      "content": "Implement a complete GitHub OAuth login flow. Create routes to initiate OAuth, handle the callback, and manage user sessions. Handle edge cases like denied permissions and errors.",
      "starterCode": "const express = require('express');\nconst session = require('express-session');\nconst crypto = require('crypto');\n\nconst app = express();\n\n// TODO: Configure session middleware\n\n// TODO: Implement /auth/github route to initiate OAuth\n// - Generate state parameter\n// - Store state in session\n// - Redirect to GitHub authorization URL\n\n// TODO: Implement /auth/github/callback route\n// - Verify state parameter\n// - Handle error cases (user denied, etc.)\n// - Exchange code for access token\n// - Fetch user info from GitHub API\n// - Create or link user account\n// - Create session and redirect to dashboard\n\nconst CLIENT_ID = process.env.GITHUB_CLIENT_ID;\nconst CLIENT_SECRET = process.env.GITHUB_CLIENT_SECRET;\nconst REDIRECT_URI = 'http://localhost:3000/auth/github/callback';\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
      "solution": "const express = require('express');\nconst session = require('express-session');\nconst crypto = require('crypto');\n\nconst app = express();\n\napp.use(session({\n  secret: 'your-secret-key',\n  resave: false,\n  saveUninitialized: false\n}));\n\nconst CLIENT_ID = process.env.GITHUB_CLIENT_ID;\nconst CLIENT_SECRET = process.env.GITHUB_CLIENT_SECRET;\nconst REDIRECT_URI = 'http://localhost:3000/auth/github/callback';\n\n// Initiate OAuth flow\napp.get('/auth/github', (req, res) => {\n  const state = crypto.randomBytes(32).toString('hex');\n  req.session.oauthState = state;\n  \n  const params = new URLSearchParams({\n    client_id: CLIENT_ID,\n    redirect_uri: REDIRECT_URI,\n    scope: 'read:user user:email',\n    state: state\n  });\n  \n  res.redirect(`https://github.com/login/oauth/authorize?${params}`);\n});\n\n// Handle OAuth callback\napp.get('/auth/github/callback', async (req, res) => {\n  const { code, state, error } = req.query;\n  \n  // Handle user denial or errors\n  if (error === 'access_denied') {\n    return res.redirect('/login?error=denied');\n  }\n  if (error) {\n    return res.redirect('/login?error=oauth_failed');\n  }\n  \n  // Verify state parameter (CSRF protection)\n  if (state !== req.session.oauthState) {\n    return res.status(403).send('Invalid state parameter');\n  }\n  \n  try {\n    // Exchange code for access token\n    const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Accept: 'application/json'\n      },\n      body: JSON.stringify({\n        client_id: CLIENT_ID,\n        client_secret: CLIENT_SECRET,\n        code: code,\n        redirect_uri: REDIRECT_URI\n      })\n    });\n    \n    const tokenData = await tokenResponse.json();\n    \n    if (tokenData.error) {\n      throw new Error(tokenData.error_description);\n    }\n    \n    // Fetch user info\n    const userResponse = await fetch('https://api.github.com/user', {\n      headers: {\n        Authorization: `Bearer ${tokenData.access_token}`,\n        Accept: 'application/vnd.github.v3+json'\n      }\n    });\n    \n    const userData = await userResponse.json();\n    \n    // Create session\n    req.session.userId = userData.id;\n    req.session.userEmail = userData.email;\n    \n    // Clear OAuth state\n    delete req.session.oauthState;\n    \n    res.redirect('/dashboard');\n  } catch (error) {\n    console.error('OAuth error:', error);\n    res.redirect('/login?error=auth_failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
      "hints": [
        "Remember to store the state parameter in the session and verify it in the callback",
        "GitHub's token endpoint expects JSON with Accept: application/json header",
        "Handle all error cases: user denied access, invalid state, token exchange failure"
      ],
      "validationPrompt": "Check if the implementation:\n1. Generates and stores a random state parameter\n2. Constructs the GitHub authorization URL with correct parameters\n3. Verifies the state parameter in the callback (CSRF protection)\n4. Handles error cases (access_denied, other errors)\n5. Exchanges the authorization code for an access token\n6. Fetches user info from GitHub API using the token\n7. Creates a user session and redirects appropriately"
    },
    {
      "id": "token-refresh",
      "moduleId": "auth-oauth",
      "lessonId": "token-management",
      "title": "Implement Token Refresh",
      "type": "code",
      "order": 3,
      "difficulty": "intermediate",
      "xpReward": 100,
      "content": "Implement a token refresh mechanism that automatically refreshes expiring access tokens. Create a middleware that checks token expiration and refreshes if needed before processing requests.",
      "starterCode": "// TODO: Implement refreshAccessToken function\n// - Get refresh token from database\n// - Make request to Google token endpoint\n// - Store new tokens in database\n// - Handle refresh token failure\n\n// TODO: Implement tokenRefreshMiddleware\n// - Check if current access token is expiring soon (within 5 minutes)\n// - Call refreshAccessToken if needed\n// - Handle case where refresh token is invalid (force re-login)\n\nconst db = {\n  getUser: async (userId) => { /* mock */ },\n  updateUser: async (userId, data) => { /* mock */ }\n};\n\nasync function refreshAccessToken(userId) {\n  // Your implementation here\n}\n\nfunction tokenRefreshMiddleware(req, res, next) {\n  // Your implementation here\n}\n\nmodule.exports = { refreshAccessToken, tokenRefreshMiddleware };",
      "solution": "const db = {\n  getUser: async (userId) => { /* mock */ },\n  updateUser: async (userId, data) => { /* mock */ }\n};\n\nasync function refreshAccessToken(userId) {\n  const user = await db.getUser(userId);\n  \n  if (!user.refreshToken) {\n    throw new Error('REFRESH_TOKEN_INVALID');\n  }\n  \n  const response = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({\n      refresh_token: user.refreshToken,\n      client_id: process.env.GOOGLE_CLIENT_ID,\n      client_secret: process.env.GOOGLE_CLIENT_SECRET,\n      grant_type: 'refresh_token'\n    })\n  });\n  \n  if (!response.ok) {\n    if (response.status === 400) {\n      // Token revoked or expired\n      await db.updateUser(userId, {\n        refreshToken: null,\n        accessToken: null,\n        tokenExpiresAt: null\n      });\n      throw new Error('REFRESH_TOKEN_INVALID');\n    }\n    throw new Error('Token refresh failed');\n  }\n  \n  const tokens = await response.json();\n  \n  // Update database with new tokens\n  await db.updateUser(userId, {\n    accessToken: tokens.access_token,\n    tokenExpiresAt: new Date(Date.now() + tokens.expires_in * 1000),\n    // Google may return a new refresh token\n    ...(tokens.refresh_token && { refreshToken: tokens.refresh_token })\n  });\n  \n  return tokens.access_token;\n}\n\nfunction tokenRefreshMiddleware(req, res, next) {\n  const userId = req.session?.userId;\n  if (!userId) return next();\n  \n  db.getUser(userId).then(user => {\n    if (!user || !user.tokenExpiresAt) return next();\n    \n    const expiresAt = new Date(user.tokenExpiresAt).getTime();\n    const fiveMinutes = 5 * 60 * 1000;\n    \n    // Refresh if expiring in less than 5 minutes\n    if (Date.now() > expiresAt - fiveMinutes) {\n      return refreshAccessToken(userId)\n        .then(() => next())\n        .catch(error => {\n          if (error.message === 'REFRESH_TOKEN_INVALID') {\n            req.session.destroy();\n            res.clearCookie('session');\n            return res.status(401).json({\n              error: 'Session expired',\n              code: 'REAUTHENTICATION_REQUIRED'\n            });\n          }\n          next(error);\n        });\n    }\n    \n    next();\n  }).catch(next);\n}\n\nmodule.exports = { refreshAccessToken, tokenRefreshMiddleware };",
      "hints": [
        "Check if the token expires within 5 minutes (300,000 milliseconds)",
        "If the refresh token is invalid (400 error from Google), clear all tokens and force re-authentication",
        "Google may return a new refresh token - store it if provided",
        "Always update the expiration time when refreshing"
      ],
      "validationPrompt": "Check if the implementation:\n1. Retrieves the user and their refresh token from the database\n2. Makes a POST request to Google's token endpoint with the refresh token\n3. Handles 400 errors by clearing tokens and throwing REFRESH_TOKEN_INVALID\n4. Updates the database with the new access token and expiration time\n5. Optionally updates the refresh token if a new one is returned\n6. In middleware, checks if token expires within 5 minutes and refreshes if needed\n7. Handles invalid refresh tokens by destroying the session and returning 401"
    }
  ]
}
