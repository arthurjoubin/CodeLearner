{
  "module": {
    "id": "error-messages",
    "title": "Error Messages & Debugging",
    "description": "Master reading error messages, understanding stack traces, and fixing common errors in AI-generated code",
    "icon": "Bug",
    "requiredXp": 100,
    "color": "from-red-500 to-orange-600",
    "courseId": "internet-tools"
  },
  "lessons": [
    {
      "id": "reading-errors",
      "moduleId": "error-messages",
      "title": "Reading Error Messages & Stack Traces",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Error messages tell you WHAT went wrong\n- Stack traces tell you WHERE it happened\n- Read errors from top to bottom\n- The first error is usually the real problem\n\n---\n\n# Reading Error Messages\n\n## Anatomy of an Error Message\n\nWhen code breaks, the error message has three parts:\n\n```\nUncaught TypeError: Cannot read property 'name' of undefined\n    at getUserName (app.js:15:25)\n    at handleClick (app.js:42:10)\n    at HTMLButtonElement.<anonymous> (app.js:50:5)\n```\n\n**Parts:**\n1. **Error Type**: `TypeError` - tells you what kind of error\n2. **Error Message**: `Cannot read property 'name' of undefined` - what went wrong\n3. **Stack Trace**: the chain of function calls that led to the error\n\n## Understanding the Stack Trace\n\nStack traces read **bottom to top** (oldest to newest):\n\n```\nat getUserName (app.js:15:25)     ← Error happened here (line 15, column 25)\nat handleClick (app.js:42:10)     ← Called by this function\nat HTMLButtonElement (app.js:50:5) ← Which was called by this\n```\n\n**Reading it:**\n- Start at the TOP line (where the error occurred)\n- `app.js:15:25` means file `app.js`, line 15, column 25\n- Look at that line first - that's where the problem is\n\n## Example: Debugging a Real Error\n\n```javascript\nfunction getUserName(user) {\n  return user.name.toUpperCase(); // Line 15\n}\n\nfunction handleClick() {\n  const name = getUserName(currentUser); // Line 42\n  console.log(name);\n}\n\nbutton.addEventListener('click', handleClick); // Line 50\n```\n\n**Error:**\n```\nUncaught TypeError: Cannot read property 'name' of undefined\n    at getUserName (app.js:15:25)\n```\n\n**What it means:**\n- At line 15, we tried to access `.name` on `user`\n- But `user` is `undefined`\n- So we can't read its `name` property\n\n**Fix:** Check if `user` exists before accessing it:\n```javascript\nfunction getUserName(user) {\n  if (!user) return 'Guest';\n  return user.name.toUpperCase();\n}\n```\n\n## Common Error Patterns\n\n### \"Cannot read property X of undefined\"\n\n```javascript\n// Problem\nconst userName = user.name; // user is undefined\n\n// Fix\nconst userName = user?.name; // Optional chaining\n```\n\n### \"X is not a function\"\n\n```javascript\n// Problem\nconst result = data.map(); // data is not an array\n\n// Fix\nif (Array.isArray(data)) {\n  const result = data.map(...);\n}\n```\n\n### \"Unexpected token\"\n\n```javascript\n// Problem - missing closing brace\nfunction test() {\n  console.log('hello');\n// Missing }\n\n// Fix\nfunction test() {\n  console.log('hello');\n}\n```\n\n## Browser vs Node.js Errors\n\n### Browser Console\n\n```\nUncaught TypeError: Cannot read property 'name' of undefined\n    at app.js:15\n```\n\n- Errors show in the DevTools Console (F12)\n- Click the filename to jump to the line\n- Red text = error, yellow = warning\n\n### Node.js Terminal\n\n```\nTypeError: Cannot read property 'name' of undefined\n    at getUserName (/home/user/app.js:15:25)\n    at Object.<anonymous> (/home/user/app.js:42:10)\n```\n\n- Errors print to the terminal\n- Full file paths shown\n- Process exits on uncaught errors\n\n## Tips for Reading Errors\n\n1. **Don't panic** - errors are normal and helpful\n2. **Read the first line** - it tells you what went wrong\n3. **Check the first line of the stack trace** - that's where to look\n4. **Google the error message** - you're not the first person to see it\n5. **Look for typos** - missing brackets, quotes, semicolons\n6. **Check variable names** - undefined usually means typo or wrong scope\n\n## Quick Reference\n\n```javascript\n// Error format\nErrorType: Error message\n    at functionName (file.js:line:column)\n\n// What to do\n1. Read the error type and message\n2. Look at the file and line number\n3. Understand what the error means\n4. Fix the root cause\n```\n\n**Remember:**\n- ✅ Read error messages carefully - they tell you exactly what's wrong\n- ✅ Stack traces show WHERE the error happened\n- ✅ Start debugging at the first line of the stack trace\n- ✅ Google error messages if unclear\n- ❌ Don't ignore warnings - they often become errors later\n- ❌ Don't just comment out broken code - fix it"
    },
    {
      "id": "common-js-errors",
      "moduleId": "error-messages",
      "title": "Common JavaScript Errors",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- TypeError: wrong type (undefined.name, \"hello\"())\n- ReferenceError: variable doesn't exist\n- SyntaxError: invalid JavaScript syntax\n- RangeError: number out of bounds\n\n---\n\n# Common JavaScript Errors\n\n## 1. TypeError\n\n**What it means:** You're using a value as the wrong type.\n\n### \"Cannot read property X of undefined\"\n\n```javascript\n// Problem\nconst user = undefined;\nconsole.log(user.name); // TypeError!\n\n// Why: user is undefined, can't access .name\n\n// Fix 1: Check if exists\nif (user) {\n  console.log(user.name);\n}\n\n// Fix 2: Optional chaining (modern)\nconsole.log(user?.name); // undefined instead of error\n\n// Fix 3: Default value\nconst user = getUser() || { name: 'Guest' };\n```\n\n### \"Cannot read property X of null\"\n\n```javascript\n// Problem\nconst element = document.getElementById('missing');\nelement.classList.add('active'); // TypeError!\n\n// Why: element is null (doesn't exist)\n\n// Fix: Check before using\nconst element = document.getElementById('missing');\nif (element) {\n  element.classList.add('active');\n}\n```\n\n### \"X is not a function\"\n\n```javascript\n// Problem 1: Variable is not a function\nconst num = 42;\nnum(); // TypeError: num is not a function\n\n// Problem 2: Method doesn't exist\nconst obj = {};\nobj.map(); // TypeError: obj.map is not a function\n\n// Problem 3: Typo\nconst arr = [1, 2, 3];\narr.maap(x => x * 2); // TypeError: arr.maap is not a function\n//    ^^^ typo!\n\n// Fix: Check type\nif (typeof num === 'function') {\n  num();\n}\n\n// Fix: Check if method exists\nif (Array.isArray(arr)) {\n  arr.map(x => x * 2);\n}\n```\n\n### \"Cannot set property X of undefined\"\n\n```javascript\n// Problem\nlet user;\nuser.name = 'Alice'; // TypeError!\n\n// Fix: Initialize object first\nlet user = {};\nuser.name = 'Alice';\n```\n\n## 2. ReferenceError\n\n**What it means:** Variable doesn't exist or isn't accessible.\n\n### \"X is not defined\"\n\n```javascript\n// Problem 1: Typo\nconsole.log(usreName); // ReferenceError: usreName is not defined\n//          ^^^^^^^^ typo! should be userName\n\n// Problem 2: Variable doesn't exist\nconsole.log(myVariable); // ReferenceError\n\n// Fix: Declare the variable\nconst myVariable = 'hello';\nconsole.log(myVariable);\n```\n\n### \"Cannot access X before initialization\"\n\n```javascript\n// Problem: Using let/const before declaration\nconsole.log(name); // ReferenceError!\nconst name = 'Alice';\n\n// Why: Temporal Dead Zone (TDZ)\n// const/let can't be used before declaration\n\n// Fix: Declare first, use second\nconst name = 'Alice';\nconsole.log(name); // 'Alice'\n```\n\n## 3. SyntaxError\n\n**What it means:** Invalid JavaScript code - won't even run.\n\n### \"Unexpected token\"\n\n```javascript\n// Problem 1: Missing closing bracket\nfunction test() {\n  console.log('hello');\n// SyntaxError: Unexpected end of input\n\n// Fix: Add closing brace\nfunction test() {\n  console.log('hello');\n}\n\n// Problem 2: Unexpected character\nconst obj = { name: 'Alice', }; // Trailing comma OK\nconst arr = [1, 2, 3,]; // OK in modern JS\n\n// But this is wrong:\nconst x = ,5; // SyntaxError: Unexpected token ','\n```\n\n### \"Unexpected string\"\n\n```javascript\n// Problem: Missing quote or comma\nconst obj = {\n  name: 'Alice'\n  age: 25 // SyntaxError: missing comma\n};\n\n// Fix: Add comma\nconst obj = {\n  name: 'Alice',\n  age: 25\n};\n```\n\n### \"Invalid or unexpected token\"\n\n```javascript\n// Problem: Unclosed string\nconst message = 'Hello world; // SyntaxError!\n//              ^^^ missing closing quote\n\n// Fix: Close the string\nconst message = 'Hello world';\n```\n\n## 4. RangeError\n\n**What it means:** Number is outside valid range.\n\n```javascript\n// Problem: Invalid array length\nconst arr = new Array(-1); // RangeError: Invalid array length\n\n// Problem: Too much recursion\nfunction infinite() {\n  infinite(); // RangeError: Maximum call stack size exceeded\n}\ninfinite();\n\n// Fix: Add base case\nfunction countdown(n) {\n  if (n <= 0) return; // Base case\n  console.log(n);\n  countdown(n - 1);\n}\n```\n\n## 5. Common React Errors (Bonus)\n\n### \"Cannot read property 'map' of undefined\"\n\n```javascript\n// Problem: Data not loaded yet\nfunction UserList({ users }) {\n  return users.map(user => <div>{user.name}</div>);\n  // TypeError if users is undefined\n}\n\n// Fix: Provide default value\nfunction UserList({ users = [] }) {\n  return users.map(user => <div>{user.name}</div>);\n}\n\n// Or check before mapping\nfunction UserList({ users }) {\n  if (!users) return <div>Loading...</div>;\n  return users.map(user => <div>{user.name}</div>);\n}\n```\n\n### \"Objects are not valid as a React child\"\n\n```javascript\n// Problem: Trying to render an object\nconst user = { name: 'Alice', age: 25 };\nreturn <div>{user}</div>; // Error!\n\n// Fix: Render specific properties\nreturn <div>{user.name}</div>;\n\n// Or convert to string\nreturn <div>{JSON.stringify(user)}</div>;\n```\n\n## Debugging Workflow\n\n1. **Read the error type** - what kind of problem?\n2. **Read the error message** - what specifically went wrong?\n3. **Check the line number** - where did it happen?\n4. **Understand the cause** - why did it happen?\n5. **Fix the root cause** - don't just hide the symptom\n\n## Quick Reference\n\n```javascript\n// TypeError: wrong type\nundefined.name           // Cannot read property\n\"hello\"()               // X is not a function\nnull.style.color         // Cannot read property of null\n\n// ReferenceError: doesn't exist\nconsole.log(notDefined)  // X is not defined\nconsole.log(x); const x  // Cannot access before init\n\n// SyntaxError: invalid code\nconst x = { a: 1 b: 2 }  // Unexpected token (missing comma)\nfunction test() {         // Unexpected end (missing })\n\n// RangeError: out of bounds\nnew Array(-1)            // Invalid array length\nfunction f() { f() }     // Maximum call stack exceeded\n```\n\n**Remember:**\n- ✅ TypeError = using wrong type (undefined.x, \"hi\"())\n- ✅ ReferenceError = variable doesn't exist\n- ✅ SyntaxError = invalid JavaScript\n- ✅ Always read the full error message\n- ❌ Don't just try random fixes - understand the error first"
    },
    {
      "id": "runtime-vs-compile",
      "moduleId": "error-messages",
      "title": "Runtime vs Syntax Errors",
      "order": 3,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Syntax errors: code won't run at all (missing brackets, typos)\n- Runtime errors: code runs but breaks during execution\n- TypeScript catches many errors before runtime\n- Linters (ESLint) catch errors as you type\n\n---\n\n# Runtime vs Syntax Errors\n\n## Understanding Error Timing\n\nErrors happen at different times:\n\n1. **Syntax Errors** - Before code runs (parse time)\n2. **Runtime Errors** - While code is running (execution time)\n3. **Logic Errors** - Code runs but does wrong thing\n\n## Syntax Errors (Parse Time)\n\n**When they happen:** Before any code executes.\n\n**What they mean:** Your JavaScript is invalid - can't even be understood.\n\n### Examples\n\n```javascript\n// Missing closing brace\nfunction greet() {\n  console.log('Hello')\n// SyntaxError: Unexpected end of input\n\n// Extra closing brace\nfunction greet() {\n  console.log('Hello');\n}}\n// SyntaxError: Unexpected token '}'\n\n// Missing comma\nconst obj = {\n  name: 'Alice'\n  age: 25\n};\n// SyntaxError: Unexpected identifier 'age'\n\n// Invalid assignment\n5 = x;\n// SyntaxError: Invalid left-hand side in assignment\n```\n\n**Key point:** The entire file won't run if there's a syntax error.\n\n```javascript\nconsole.log('This will never print');\n\nfunction broken() {\n  return // SyntaxError here\n}\n\nconsole.log('This also never prints');\n// Nothing runs because of the syntax error\n```\n\n## Runtime Errors (Execution Time)\n\n**When they happen:** While code is running.\n\n**What they mean:** Syntax is valid, but something went wrong during execution.\n\n### Examples\n\n```javascript\n// Valid syntax, but error at runtime\nfunction divide(a, b) {\n  return a / b;\n}\n\nconsole.log(divide(10, 2)); // Works: 5\nconsole.log(divide(10, 0)); // Works: Infinity (not an error!)\n\nfunction getUser(id) {\n  const users = null;\n  return users.find(u => u.id === id);\n  // TypeError at runtime: Cannot read property 'find' of null\n}\n\ngetUser(1); // Error happens here, when function is called\n```\n\n**Key point:** Code before the error runs successfully.\n\n```javascript\nconsole.log('This prints'); // Runs ✅\n\nconst user = null;\nconsole.log(user.name); // TypeError! ❌\n\nconsole.log('This never prints'); // Doesn't run\n```\n\n## Comparing the Two\n\n### Syntax Error Example\n\n```javascript\n// File: app.js\nconsole.log('Starting app...'); // Won't print\n\nfunction getData() {\n  return {\n    name: 'Alice'\n    age: 25 // Missing comma - SyntaxError!\n  };\n}\n\nconsole.log('App ready'); // Won't print\n\n// Result: NOTHING runs, entire file invalid\n```\n\n### Runtime Error Example\n\n```javascript\n// File: app.js\nconsole.log('Starting app...'); // Prints ✅\n\nfunction getData() {\n  const data = null;\n  return data.name; // TypeError at runtime ❌\n}\n\nconsole.log('App ready'); // Prints ✅\ngetData(); // Error happens here\nconsole.log('Done'); // Never reached\n\n// Result: Code runs until the error is triggered\n```\n\n## Logic Errors (Silent Bugs)\n\n**When they happen:** Code runs without errors.\n\n**What they mean:** The code does the wrong thing.\n\n```javascript\n// No errors, but wrong logic\nfunction getDiscount(price) {\n  if (price > 100) {\n    return price * 0.9; // 10% off\n  }\n  return price * 1.1; // BUG: Should be no discount, not 110%!\n}\n\nconsole.log(getDiscount(50)); // Returns 55 (wrong!)\n// No error thrown, but result is incorrect\n```\n\n## Catching Errors Early\n\n### 1. Use a Linter (ESLint)\n\nLinters catch errors **as you type** in your editor:\n\n```javascript\n// ESLint catches these immediately:\nconst x = 5\nconst y = 10 // Missing semicolon warning\n\nif (x = 5) { } // Warning: Assignment in condition\n\nfunction test() {\n  var x = 1; // Warning: Use const/let, not var\n}\n```\n\n### 2. Use TypeScript\n\nTypeScript catches type errors **before running**:\n\n```typescript\n// TypeScript catches this before runtime\nfunction greet(name: string) {\n  console.log('Hello ' + name);\n}\n\ngreet(42); // Error: Argument of type 'number' not assignable to 'string'\n```\n\n```javascript\n// Plain JavaScript - error only at runtime\nfunction greet(name) {\n  console.log('Hello ' + name.toUpperCase());\n}\n\ngreet(42); // TypeError: name.toUpperCase is not a function\n```\n\n### 3. Use Strict Mode\n\n```javascript\n'use strict';\n\n// Strict mode catches more errors\nx = 10; // ReferenceError: x is not defined\n// Without strict mode, this creates a global variable (bad!)\n\nfunction test(a, a) { } // SyntaxError: Duplicate parameter\n// Without strict mode, this is allowed\n\ndelete Object.prototype; // TypeError\n// Without strict mode, silently fails\n```\n\n## Error Prevention Strategies\n\n### 1. Check Types\n\n```javascript\nfunction processData(data) {\n  // Check type before using\n  if (!Array.isArray(data)) {\n    throw new Error('data must be an array');\n  }\n  return data.map(x => x * 2);\n}\n```\n\n### 2. Validate Input\n\n```javascript\nfunction divide(a, b) {\n  if (b === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n  return a / b;\n}\n```\n\n### 3. Use Optional Chaining\n\n```javascript\n// Old way - crashes if user is null\nconst name = user.profile.name;\n\n// New way - returns undefined instead\nconst name = user?.profile?.name;\n```\n\n### 4. Provide Defaults\n\n```javascript\n// Crash if users is undefined\nfunction UserList({ users }) {\n  return users.map(u => <div>{u.name}</div>);\n}\n\n// Safe with default\nfunction UserList({ users = [] }) {\n  return users.map(u => <div>{u.name}</div>);\n}\n```\n\n## Quick Reference\n\n| Error Type | When | Example |\n|------------|------|----------|\n| **Syntax** | Before running | `function test() {` (missing `}`) |\n| **Runtime** | During execution | `null.name` (TypeError) |\n| **Logic** | No error thrown | `return price * 1.1` (wrong math) |\n\n**Tools to catch errors early:**\n- ✅ ESLint (as you type)\n- ✅ TypeScript (before running)\n- ✅ `'use strict'` (more runtime checks)\n- ✅ Good tests (catch logic errors)\n\n**Remember:**\n- ✅ Syntax errors = invalid JavaScript (won't run)\n- ✅ Runtime errors = valid code, fails during execution\n- ✅ Logic errors = code works, but does wrong thing\n- ✅ Use tools to catch errors early\n- ❌ Don't ignore linter warnings - fix them"
    },
    {
      "id": "async-errors",
      "moduleId": "error-messages",
      "title": "Debugging Async Errors",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Async errors don't appear in normal stack traces\n- Unhandled promise rejections crash Node.js\n- Use try/catch with async/await\n- Always handle .catch() on promises\n\n---\n\n# Debugging Async Errors\n\n## The Problem with Async Errors\n\nAsync code runs **later**, so errors happen in a different context:\n\n```javascript\n// Synchronous - easy to debug\nfunction getUser() {\n  throw new Error('User not found');\n}\n\ntry {\n  getUser(); // Error caught here\n} catch (error) {\n  console.error(error); // Works!\n}\n\n// Asynchronous - try/catch doesn't work!\nfunction getUserAsync() {\n  setTimeout(() => {\n    throw new Error('User not found'); // ❌ Uncaught!\n  }, 1000);\n}\n\ntry {\n  getUserAsync(); // Returns immediately\n} catch (error) {\n  console.error(error); // Never runs!\n}\n// Error happens 1 second later, outside the try/catch\n```\n\n## Promise Errors\n\n### Unhandled Promise Rejection\n\n```javascript\n// BAD - no error handling\nfetch('/api/users')\n  .then(res => res.json())\n  .then(users => console.log(users));\n// If fetch fails, unhandled rejection!\n\n// GOOD - handle errors\nfetch('/api/users')\n  .then(res => res.json())\n  .then(users => console.log(users))\n  .catch(error => {\n    console.error('Failed to fetch users:', error);\n  });\n```\n\n**In Node.js**, unhandled rejections crash your app:\n\n```\nUnhandledPromiseRejectionWarning: Error: ECONNREFUSED\n(node:12345) UnhandledPromiseRejectionWarning: Unhandled promise rejection.\nThis error originated either by throwing inside of an async function\nwithout a catch block, or by rejecting a promise which was not handled\nwith .catch().\n```\n\n### Common Promise Mistakes\n\n```javascript\n// Mistake 1: Forgetting to return\nfunction getUser(id) {\n  fetch(`/api/users/${id}`) // Missing return!\n    .then(res => res.json());\n}\n\nconst user = await getUser(1); // user is undefined!\n\n// Fix: Return the promise\nfunction getUser(id) {\n  return fetch(`/api/users/${id}`)\n    .then(res => res.json());\n}\n\n// Mistake 2: Not handling errors in chains\nfetch('/api/users')\n  .then(res => res.json())\n  .then(users => users.map(u => u.name)) // What if users is undefined?\n  .catch(error => console.error(error)); // Only catches fetch error\n\n// Fix: Handle errors at each step\nfetch('/api/users')\n  .then(res => {\n    if (!res.ok) throw new Error('Network error');\n    return res.json();\n  })\n  .then(users => {\n    if (!Array.isArray(users)) throw new Error('Invalid data');\n    return users.map(u => u.name);\n  })\n  .catch(error => console.error('Error:', error));\n```\n\n## Async/Await Errors\n\n### Using Try/Catch\n\n```javascript\n// GOOD - proper error handling\nasync function getUsers() {\n  try {\n    const response = await fetch('/api/users');\n    const users = await response.json();\n    return users;\n  } catch (error) {\n    console.error('Failed to get users:', error);\n    return []; // Return fallback value\n  }\n}\n\n// Multiple awaits - one try/catch\nasync function getData() {\n  try {\n    const users = await fetch('/api/users').then(r => r.json());\n    const posts = await fetch('/api/posts').then(r => r.json());\n    const comments = await fetch('/api/comments').then(r => r.json());\n    return { users, posts, comments };\n  } catch (error) {\n    console.error('Failed to fetch data:', error);\n    throw error; // Re-throw if caller should handle it\n  }\n}\n```\n\n### Common Async/Await Mistakes\n\n```javascript\n// Mistake 1: Forgetting await\nasync function getUser(id) {\n  const user = fetch(`/api/users/${id}`); // Missing await!\n  return user.name; // user is a Promise, not an object!\n}\n\n// Fix: Add await\nasync function getUser(id) {\n  const response = await fetch(`/api/users/${id}`);\n  const user = await response.json();\n  return user.name;\n}\n\n// Mistake 2: Sequential instead of parallel\nasync function getAllData() {\n  const users = await fetch('/api/users'); // Waits\n  const posts = await fetch('/api/posts'); // Then waits\n  const comments = await fetch('/api/comments'); // Then waits\n  // Total: 3 seconds if each takes 1 second\n}\n\n// Fix: Parallel with Promise.all\nasync function getAllData() {\n  const [users, posts, comments] = await Promise.all([\n    fetch('/api/users'),\n    fetch('/api/posts'),\n    fetch('/api/comments')\n  ]);\n  // Total: 1 second (all requests at once)\n}\n\n// Mistake 3: Not catching errors in forEach\nasync function processUsers(users) {\n  users.forEach(async (user) => {\n    await updateUser(user); // Errors not caught!\n  });\n}\n\n// Fix: Use for...of or Promise.all\nasync function processUsers(users) {\n  // Sequential\n  for (const user of users) {\n    try {\n      await updateUser(user);\n    } catch (error) {\n      console.error(`Failed to update ${user.id}:`, error);\n    }\n  }\n\n  // Or parallel\n  await Promise.all(\n    users.map(user => \n      updateUser(user).catch(error => \n        console.error(`Failed to update ${user.id}:`, error)\n      )\n    )\n  );\n}\n```\n\n## Debugging Async Stack Traces\n\n### The Problem\n\n```javascript\nasync function a() {\n  await b();\n}\n\nasync function b() {\n  await c();\n}\n\nasync function c() {\n  throw new Error('Something broke');\n}\n\na();\n\n// Stack trace:\n// Error: Something broke\n//     at c (app.js:10)\n//     at async b (app.js:6)\n//     at async a (app.js:2)\n// Good! Shows full chain\n```\n\nBut without `await`, the chain is lost:\n\n```javascript\nfunction a() {\n  b(); // Missing await\n}\n\nfunction b() {\n  c(); // Missing await\n}\n\nasync function c() {\n  throw new Error('Something broke');\n}\n\na();\n\n// Stack trace:\n// UnhandledPromiseRejectionWarning: Error: Something broke\n//     at c (app.js:10)\n// Lost context of where c() was called from!\n```\n\n## Error Handling Patterns\n\n### Pattern 1: Wrapper Function\n\n```javascript\n// Wrap async functions to catch errors\nfunction asyncHandler(fn) {\n  return async (req, res, next) => {\n    try {\n      await fn(req, res, next);\n    } catch (error) {\n      next(error); // Pass to error handler\n    }\n  };\n}\n\n// Use it\napp.get('/users', asyncHandler(async (req, res) => {\n  const users = await User.findAll();\n  res.json(users);\n}));\n// Errors automatically caught and passed to error handler\n```\n\n### Pattern 2: Safe Await\n\n```javascript\n// Returns [error, data] instead of throwing\nfunction safeAwait(promise) {\n  return promise\n    .then(data => [null, data])\n    .catch(error => [error, null]);\n}\n\n// Use it\nconst [error, users] = await safeAwait(fetch('/api/users'));\nif (error) {\n  console.error('Failed:', error);\n  return;\n}\nconsole.log(users);\n```\n\n### Pattern 3: Retry Logic\n\n```javascript\nasync function retry(fn, retries = 3) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === retries - 1) throw error; // Last attempt\n      console.log(`Retry ${i + 1}/${retries}`);\n      await new Promise(r => setTimeout(r, 1000 * (i + 1))); // Exponential backoff\n    }\n  }\n}\n\n// Use it\nconst data = await retry(() => fetch('/api/unstable'));\n```\n\n## Quick Reference\n\n```javascript\n// ❌ BAD - No error handling\nasync function getData() {\n  const res = await fetch('/api');\n  return res.json();\n}\n\n// ✅ GOOD - Try/catch\nasync function getData() {\n  try {\n    const res = await fetch('/api');\n    return await res.json();\n  } catch (error) {\n    console.error('Error:', error);\n    return null;\n  }\n}\n\n// ❌ BAD - Sequential\nconst a = await fetchA();\nconst b = await fetchB();\n\n// ✅ GOOD - Parallel\nconst [a, b] = await Promise.all([fetchA(), fetchB()]);\n\n// ❌ BAD - forEach with async\nusers.forEach(async (u) => await update(u));\n\n// ✅ GOOD - for...of or Promise.all\nfor (const u of users) await update(u);\n// or\nawait Promise.all(users.map(u => update(u)));\n```\n\n**Remember:**\n- ✅ Always use try/catch with async/await\n- ✅ Always add .catch() to promises\n- ✅ Don't forget await (check your linter)\n- ✅ Use Promise.all for parallel operations\n- ❌ Never ignore unhandled promise rejections\n- ❌ Don't use forEach with async functions"
    }
  ],
  "exercises": [
    {
      "id": "ex-fix-undefined-error",
      "lessonId": "reading-errors",
      "moduleId": "error-messages",
      "title": "Fix the Undefined Property Error",
      "difficulty": "easy",
      "type": "code",
      "description": "ChatGPT wrote this code to display user info, but it crashes with `Cannot read property 'name' of undefined`. Read the error message and fix it!",
      "instructions": "The code tries to access `user.name`, but `user` is undefined. Fix it by checking if the user exists before accessing properties.",
      "starterCode": "function displayUser(user) {\n  // ChatGPT's code - crashes if user is undefined!\n  const name = user.name;\n  const email = user.email;\n  \n  return `${name} (${email})`;\n}\n\n// Test cases\nconsole.log(displayUser({ name: 'Alice', email: 'alice@example.com' }));\nconsole.log(displayUser(undefined)); // ERROR: Cannot read property 'name' of undefined",
      "solution": "function displayUser(user) {\n  // Fix: Check if user exists first\n  if (!user) {\n    return 'No user provided';\n  }\n  \n  const name = user.name;\n  const email = user.email;\n  \n  return `${name} (${email})`;\n}\n\n// Test cases\nconsole.log(displayUser({ name: 'Alice', email: 'alice@example.com' }));\nconsole.log(displayUser(undefined)); // Now returns: 'No user provided'",
      "hints": [
        "Read the error: 'Cannot read property 'name' of undefined' - what is undefined?",
        "Add an if statement to check if user exists before using it",
        "Return a default message when user is undefined"
      ],
      "validationPrompt": "Check that the code:\n1. Has an if statement checking if user is falsy (!user or user === undefined)\n2. Returns a fallback value when user is undefined (like 'No user provided', 'Guest', or similar)\n3. Only accesses user.name and user.email when user exists\n4. Still works correctly when user is provided\nThe exact return value for undefined doesn't matter, as long as it doesn't crash."
    },
    {
      "id": "ex-fix-not-function",
      "lessonId": "common-js-errors",
      "moduleId": "error-messages",
      "title": "Fix the 'Not a Function' Error",
      "difficulty": "easy",
      "type": "code",
      "description": "Copilot generated this code to process user data, but it throws `TypeError: users.map is not a function`. Debug and fix it!",
      "instructions": "The code assumes `users` is an array, but it might not be. Check if it's an array before calling `.map()`.",
      "starterCode": "function getUserNames(users) {\n  // Copilot's code - crashes if users isn't an array!\n  return users.map(user => user.name);\n}\n\n// Test cases\nconsole.log(getUserNames([{ name: 'Alice' }, { name: 'Bob' }]));\nconsole.log(getUserNames(null)); // ERROR: users.map is not a function\nconsole.log(getUserNames({ name: 'Charlie' })); // ERROR: users.map is not a function",
      "solution": "function getUserNames(users) {\n  // Fix: Check if users is an array first\n  if (!Array.isArray(users)) {\n    return [];\n  }\n  \n  return users.map(user => user.name);\n}\n\n// Test cases\nconsole.log(getUserNames([{ name: 'Alice' }, { name: 'Bob' }]));\nconsole.log(getUserNames(null)); // Returns: []\nconsole.log(getUserNames({ name: 'Charlie' })); // Returns: []",
      "hints": [
        "The error says 'users.map is not a function' - what does that mean?",
        ".map() only exists on arrays - is users always an array?",
        "Use Array.isArray(users) to check if it's an array",
        "Return an empty array [] when users is not an array"
      ],
      "validationPrompt": "Verify:\n1. Code uses Array.isArray(users) to check if users is an array\n2. Returns a safe fallback (empty array []) when users is not an array\n3. Still calls .map() and works correctly when users IS an array\n4. Handles null, undefined, objects, and other non-array values"
    },
    {
      "id": "ex-fix-syntax-error",
      "lessonId": "runtime-vs-compile",
      "moduleId": "error-messages",
      "title": "Fix the Syntax Errors",
      "difficulty": "easy",
      "type": "code",
      "description": "v0 generated this React component, but it has multiple syntax errors. Read the error messages and fix all the issues!",
      "instructions": "Fix ALL syntax errors: missing closing braces, missing commas in objects, and unclosed strings.",
      "starterCode": "function UserCard({ user }) {\n  // v0's broken code - multiple syntax errors!\n  const styles = {\n    card: { padding: '20px', border: '1px solid #ccc' }\n    title: { fontSize: '24px', color: '#333' }  // Missing comma\n  };\n  \n  return (\n    <div style={styles.card}>\n      <h2 style={styles.title}>{user.name}</h2>\n      <p>{user.email}</p>\n    </div>\n  // Missing closing )\n// Missing closing }",
      "solution": "function UserCard({ user }) {\n  // Fixed: Added missing comma, closing parenthesis, and closing brace\n  const styles = {\n    card: { padding: '20px', border: '1px solid #ccc' },\n    title: { fontSize: '24px', color: '#333' }  // Added comma\n  };\n  \n  return (\n    <div style={styles.card}>\n      <h2 style={styles.title}>{user.name}</h2>\n      <p>{user.email}</p>\n    </div>\n  );  // Added closing parenthesis\n}  // Added closing brace",
      "hints": [
        "Read the first error message - it points to the exact line",
        "Look for missing commas between object properties",
        "Count your opening and closing brackets - do they match?",
        "JSX return statements need closing parentheses",
        "Functions need closing braces"
      ],
      "validationPrompt": "Check:\n1. Object 'styles' has a comma after the 'card' property\n2. The return statement has a closing parenthesis after </div>\n3. The function has a closing brace at the end\n4. No SyntaxError would be thrown\n5. The code structure is valid JavaScript/JSX"
    },
    {
      "id": "ex-fix-async-error",
      "lessonId": "async-errors",
      "moduleId": "error-messages",
      "title": "Handle the Async Error",
      "difficulty": "medium",
      "type": "code",
      "description": "ChatGPT wrote this async function to fetch user data, but it has an unhandled promise rejection. Add proper error handling!",
      "instructions": "Wrap the async code in a try/catch block and handle errors gracefully by returning null and logging the error.",
      "starterCode": "async function fetchUser(id) {\n  // ChatGPT's code - no error handling!\n  const response = await fetch(`https://api.example.com/users/${id}`);\n  const user = await response.json();\n  return user;\n}\n\n// If the fetch fails, you get:\n// UnhandledPromiseRejectionWarning!\n\nfetchUser(999).then(user => console.log(user));",
      "solution": "async function fetchUser(id) {\n  // Fixed: Added try/catch for error handling\n  try {\n    const response = await fetch(`https://api.example.com/users/${id}`);\n    \n    // Also check if response is ok\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const user = await response.json();\n    return user;\n  } catch (error) {\n    console.error('Failed to fetch user:', error.message);\n    return null;  // Return null instead of crashing\n  }\n}\n\n// Now handles errors gracefully\nfetchUser(999).then(user => console.log(user || 'User not found'));",
      "hints": [
        "Async errors need try/catch blocks, not regular error handling",
        "Put the await statements inside a try block",
        "Add a catch block to handle the error",
        "Return a safe fallback value (like null) in the catch block",
        "Log the error so you know what went wrong"
      ],
      "validationPrompt": "Verify:\n1. Function body is wrapped in try/catch\n2. Both await statements are inside the try block\n3. catch block logs the error with console.error()\n4. catch block returns a fallback value (null, {}, or similar)\n5. No unhandled promise rejections would occur"
    }
  ]
}
