{
  "module": {
    "id": "pwa-basics",
    "title": "Progressive Web Apps (PWA)",
    "description": "Create web applications that work offline, install like native apps, and offer a smooth user experience",
    "icon": "Smartphone",
    "requiredXp": 1500,
    "color": "from-indigo-500 to-purple-600",
    "courseId": "web-stack"
  },
  "lessons": [
    {
      "id": "pwa-introduction",
      "moduleId": "pwa-basics",
      "title": "Introduction to PWAs",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- PWA = Progressive Web App\n- Work offline thanks to Service Workers\n- Install on home screen like native apps\n- Use manifest.json to define appearance\n- Responsive and cross-platform\n\n---\n\n# What is a PWA?\n\n## Definition\n\nA **Progressive Web App** is a web application that uses modern technologies to offer a user experience similar to native mobile applications.\n\n## The 3 Pillars of a PWA\n\n### 1. Capable\n- Works offline or on weak network\n- Access to native features (camera, geolocation, notifications)\n- Optimal performance through caching\n\n### 2. Reliable\n- Loads instantly, regardless of connection\n- Always responds, even offline\n- No \"white page\" loading\n\n### 3. Engaging\n- Installs on home screen\n- Push notifications\n- Immersive experience (fullscreen)\n\n## Why choose a PWA?\n\n**Advantages vs Native Apps:**\n- No store to manage (App Store, Play Store)\n- Instant updates\n- Reduced size\n- Single code for all platforms\n- Better SEO (search engine optimization)\n- No installation friction\n\n**Famous PWA examples:**\n- Twitter\n- Pinterest\n- Starbucks\n- Spotify\n- Uber\n\n## Key Technologies\n\n1. **Service Workers**: Scripts that run in the background\n2. **Web App Manifest**: JSON file defining the app\n3. **HTTPS**: Required for Service Workers\n4. **Cache API**: Resource storage\n5. **IndexedDB**: Client-side database",
      "codeExample": "// Minimal PWA structure\n\n// 1. index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>My PWA</title>\n  \n  <!-- Link to manifest -->\n  <link rel=\"manifest\" href=\"/manifest.json\">\n  \n  <!-- Theme for mobile -->\n  <meta name=\"theme-color\" content=\"#6366f1\">\n  \n  <!-- Icons -->\n  <link rel=\"icon\" type=\"image/png\" sizes=\"192x192\" href=\"/icon-192.png\">\n  <link rel=\"apple-touch-icon\" href=\"/icon-192.png\">\n</head>\n<body>\n  <div id=\"app\">\n    <h1>My Progressive Web App</h1>\n    <p id=\"status\">Status: <span>Online</span></p>\n  </div>\n  \n  <!-- Service Worker registration -->\n  <script>\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.register('/sw.js')\n        .then(reg => console.log('SW registered'))\n        .catch(err => console.log('SW error', err));\n    }\n  </script>\n</body>\n</html>\n\n// 2. manifest.json\n{\n  \"name\": \"My Super PWA\",\n  \"short_name\": \"PWA\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#6366f1\",\n  \"orientation\": \"portrait\",\n  \"icons\": [\n    {\n      \"src\": \"/icon-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/icon-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}"
    },
    {
      "id": "service-workers",
      "moduleId": "pwa-basics",
      "title": "Service Workers",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Service Worker = JavaScript script that runs in the background\n- Acts as a proxy between browser and network\n- Enables caching, offline management, notifications\n- Lifecycle: install → activate → fetch\n- Must be registered in the main file\n- Works only over HTTPS\n\n---\n\n# Service Workers: The Brain of the PWA\n\n## What is a Service Worker?\n\nA **Service Worker** is a JavaScript script that runs in the background, independently of the web page. It acts as a proxy between your application and the network.\n\n**What it can do:**\n- Intercept network requests\n- Cache resources\n- Serve content offline\n- Receive push notifications\n- Background sync\n\n**What it CANNOT do:**\n- Access DOM directly\n- Use localStorage (but can use Cache API and IndexedDB)\n- Work on localhost without HTTPS (except 127.0.0.1)\n\n## Service Worker Lifecycle\n\n```\nRegister → Install → Activate → Idle → Terminate\n                        ↓\n                  Fetch / Message / Push / Sync\n```\n\n### 1. Registration\n\nIn your main file (index.html or app.js):\n\n```javascript\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker\n    .register('/sw.js')\n    .then(registration => {\n      console.log('SW registered successfully!');\n      console.log('Scope:', registration.scope);\n    })\n    .catch(error => {\n      console.log('Registration error:', error);\n    });\n}\n```\n\n### 2. Installation\n\nThe Service Worker installs once, then stays registered:\n\n```javascript\n// sw.js\nconst CACHE_NAME = 'my-app-v1';\nconst urlsToCache = [\n  '/',\n  '/index.html',\n  '/styles.css',\n  '/app.js',\n  '/icon.png'\n];\n\n// Install event: triggers once\nself.addEventListener('install', event => {\n  console.log('Service Worker installing...');\n  \n  // Wait until cache is ready\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => {\n        console.log('Cache opened');\n        return cache.addAll(urlsToCache);\n      })\n  );\n});\n```\n\n### 3. Activation\n\n```javascript\n// Activate event: cleanup old caches\nself.addEventListener('activate', event => {\n  console.log('Service Worker activating...');\n  \n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames\n          .filter(name => name !== CACHE_NAME)\n          .map(name => caches.delete(name))\n      );\n    })\n  );\n});\n```\n\n### 4. Fetch (Interception)\n\n```javascript\n// Intercept all requests\nself.addEventListener('fetch', event => {\n  console.log('Fetching:', event.request.url);\n  \n  event.respondWith(\n    // Try cache first\n    caches.match(event.request)\n      .then(response => {\n        // Return from cache if found\n        if (response) {\n          return response;\n        }\n        \n        // Otherwise fetch from network\n        return fetch(event.request);\n      })\n  );\n});\n```\n\n## Caching Strategies\n\n### 1. Cache First (default)\n\n```javascript\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      return response || fetch(event.request);\n    })\n  );\n});\n```\n\n### 2. Network First\n\n```javascript\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    fetch(event.request).catch(() => {\n      return caches.match(event.request);\n    })\n  );\n});\n```\n\n### 3. Stale While Revalidate\n\n```javascript\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      // Return cache immediately\n      const fetchPromise = fetch(event.request).then(networkResponse => {\n        // Update cache in background\n        caches.open(CACHE_NAME).then(cache => {\n          cache.put(event.request, networkResponse.clone());\n        });\n        return networkResponse;\n      });\n      \n      return response || fetchPromise;\n    })\n  );\n});\n```\n\n## DevTools Debugging\n\nChrome DevTools → Application tab → Service Workers\n\n- See registered SWs\n- Simulate offline\n- Update on reload\n- Bypass for network\n- Unregister\n\n## Common Mistakes\n\n❌ **Wrong path**\n```javascript\n// Wrong - relative path\nnavigator.serviceWorker.register('sw.js')\n\n// Correct - absolute path\nnavigator.serviceWorker.register('/sw.js')\n```\n\n❌ **Not handling fetch**\nAlways respond to fetch events\n\n❌ **Cache too large**\nDon't cache everything - be selective",
      "codeExample": "// Complete Service Worker - sw.js\n\nconst CACHE_NAME = 'my-pwa-v1';\nconst STATIC_ASSETS = [\n  '/',\n  '/index.html',\n  '/styles.css',\n  '/app.js',\n  '/offline.html',\n  '/icon-192.png'\n];\n\n// Installation: cache static resources\nself.addEventListener('install', event => {\n  console.log('[SW] Installing...');\n  \n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => {\n        console.log('[SW] Caching resources');\n        return cache.addAll(STATIC_ASSETS);\n      })\n      .catch(err => console.error('[SW] Cache error:', err))\n  );\n  \n  // Force immediate activation\n  self.skipWaiting();\n});\n\n// Activation: clean old caches\nself.addEventListener('activate', event => {\n  console.log('[SW] Activating...');\n  \n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames\n          .filter(name => name !== CACHE_NAME)\n          .map(name => {\n            console.log('[SW] Deleting cache:', name);\n            return caches.delete(name);\n          })\n      );\n    })\n  );\n  \n  // Take control immediately\n  self.clients.claim();\n});\n\n// Fetch: intercept requests\nself.addEventListener('fetch', event => {\n  console.log('[SW] Fetch:', event.request.url);\n  \n  event.respondWith(\n    caches.match(event.request)\n      .then(cachedResponse => {\n        // If in cache, return\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n        \n        // Otherwise fetch from network\n        return fetch(event.request)\n          .then(networkResponse => {\n            // Don't cache if not valid\n            if (!networkResponse || networkResponse.status !== 200) {\n              return networkResponse;\n            }\n            \n            // Clone and cache\n            const responseToCache = networkResponse.clone();\n            caches.open(CACHE_NAME).then(cache => {\n              cache.put(event.request, responseToCache);\n            });\n            \n            return networkResponse;\n          })\n          .catch(() => {\n            // Offline fallback\n            if (event.request.mode === 'navigate') {\n              return caches.match('/offline.html');\n            }\n          });\n      })\n  );\n});\n\n// Background sync\nself.addEventListener('sync', event => {\n  if (event.tag === 'sync-data') {\n    event.waitUntil(syncData());\n  }\n});\n\n// Push notifications\nself.addEventListener('push', event => {\n  const options = {\n    body: event.data.text(),\n    icon: '/icon-192.png',\n    badge: '/badge-72.png'\n  };\n  \n  event.waitUntil(\n    self.registration.showNotification('My PWA', options)\n  );\n});"
    },
    {
      "id": "web-app-manifest",
      "moduleId": "pwa-basics",
      "title": "Web App Manifest",
      "order": 3,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Manifest.json = JSON file that describes your application\n- Defines: name, icons, colors, display mode\n- Enables installation on home screen\n- Must be linked in the <head> of HTML\n- Icons must be in PNG format\n- Recommended: 192x192 and 512x512 minimum\n\n---\n\n# Web App Manifest: The Identity Card\n\n## What is the Manifest?\n\nThe **Web App Manifest** is a JSON file that describes your application to the browser: its name, icons, colors, how it should display...\n\n**Without manifest**: The browser doesn't know it's a PWA.\n**With manifest**: The user can install the app on their home screen!\n\n## Manifest Structure\n\n```json\n{\n  \"name\": \"My Super Application\",\n  \"short_name\": \"MyApp\",\n  \"description\": \"An incredible PWA to manage your tasks\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#6366f1\",\n  \"orientation\": \"portrait\",\n  \"scope\": \"/\",\n  \"lang\": \"en\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-72x72.png\",\n      \"sizes\": \"72x72\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/icons/icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ],\n  \"screenshots\": [\n    {\n      \"src\": \"/screenshots/home.png\",\n      \"sizes\": \"1280x720\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n```\n\n## Important Fields\n\n### Identity\n\n- **name**: Full app name (displayed on splash screen)\n- **short_name**: Short name (max 12 characters, displayed under icon)\n- **description**: Application description\n\n### Display\n\n- **start_url**: Start URL when opening app (often \"/\")\n- **display**: Display mode\n  - `browser`: Like a normal browser\n  - `standalone`: Like a native app (no address bar)\n  - `fullscreen`: Full screen, no system UI\n  - `minimal-ui`: Minimal browser controls\n\n- **orientation**: Screen orientation\n  - `portrait`: Portrait (vertical)\n  - `landscape`: Landscape (horizontal)\n  - `any`: Auto-rotate\n\n### Appearance\n\n- **background_color**: Background during loading (splash screen)\n- **theme_color**: Browser theme color (status bar, toolbar)\n\n### Icons\n\n```json\n\"icons\": [\n  {\n    \"src\": \"/icon-192.png\",\n    \"sizes\": \"192x192\",\n    \"type\": \"image/png\",\n    \"purpose\": \"any maskable\"\n  }\n]\n```\n\n**Purpose:**\n- `any`: Standard icon\n- `maskable`: Icon that adapts to shapes (Android)\n- `monochrome`: Icon for monochrome mode\n\n## Linking the Manifest\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <!-- Link to manifest -->\n  <link rel=\"manifest\" href=\"/manifest.json\">\n  \n  <!-- Theme color for mobile browsers -->\n  <meta name=\"theme-color\" content=\"#6366f1\">\n  \n  <!-- Apple Touch Icon -->\n  <link rel=\"apple-touch-icon\" href=\"/icon-192.png\">\n  \n  <!-- Status bar style (iOS) -->\n  <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\">\n  \n  <title>My PWA</title>\n</head>\n<body>\n  <!-- Content -->\n</body>\n</html>\n```\n\n## Icon Sizes\n\n| Size | Usage |\n|------|-------|\n| 72x72 | Android low-res |\n| 96x96 | Android |\n| 128x128 | Chrome Web Store |\n| 144x144 | Microsoft |\n| 152x152 | iPad |\n| 192x192 | Android/Chrome (required)|\n| 384x384 | Android |\n| 512x512 | Android/Chrome (required)|\n\n## Testing the Manifest\n\nChrome DevTools → Application → Manifest\n\n- See if manifest is detected\n- Check all fields\n- Test \"Add to home screen\"\n\n## Common Mistakes\n\n❌ **Wrong icon path**\n```json\n// Wrong\n\"src\": \"icon.png\"\n\n// Correct\n\"src\": \"/icon.png\"\n```\n\n❌ **Missing sizes**\nAlways include 192x192 and 512x512\n\n❌ **Wrong MIME type**\nIcons must be PNG (not JPG or SVG for compatibility)",
      "codeExample": "// Complete manifest.json\n{\n  \"name\": \"TaskMaster - Task Manager\",\n  \"short_name\": \"TaskMaster\",\n  \"description\": \"Organize your daily tasks with a fast and intuitive PWA\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#f8fafc\",\n  \"theme_color\": \"#4f46e5\",\n  \"orientation\": \"portrait\",\n  \"scope\": \"/\",\n  \"lang\": \"en\",\n  \"dir\": \"ltr\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-72x72.png\",\n      \"sizes\": \"72x72\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    },\n    {\n      \"src\": \"/icons/icon-96x96.png\",\n      \"sizes\": \"96x96\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    },\n    {\n      \"src\": \"/icons/icon-128x128.png\",\n      \"sizes\": \"128x128\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    },\n    {\n      \"src\": \"/icons/icon-144x144.png\",\n      \"sizes\": \"144x144\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    },\n    {\n      \"src\": \"/icons/icon-152x152.png\",\n      \"sizes\": \"152x152\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    },\n    {\n      \"src\": \"/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any maskable\"\n    },\n    {\n      \"src\": \"/icons/icon-384x384.png\",\n      \"sizes\": \"384x384\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    },\n    {\n      \"src\": \"/icons/icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    }\n  ],\n  \"screenshots\": [\n    {\n      \"src\": \"/screenshots/home.png\",\n      \"sizes\": \"1280x720\",\n      \"type\": \"image/png\",\n      \"form_factor\": \"wide\"\n    },\n    {\n      \"src\": \"/screenshots/mobile.png\",\n      \"sizes\": \"750x1334\",\n      \"type\": \"image/png\",\n      \"form_factor\": \"narrow\"\n    }\n  ],\n  \"categories\": [\"productivity\", \"utilities\"],\n  \"shortcuts\": [\n    {\n      \"name\": \"New Task\",\n      \"short_name\": \"New\",\n      \"description\": \"Create a new task\",\n      \"url\": \"/new-task\",\n      \"icons\": [{ \"src\": \"/icons/new-task.png\", \"sizes\": \"96x96\" }]\n    }\n  ]\n}\n\n// index.html - Linking the manifest\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <!-- PWA -->\n  <link rel=\"manifest\" href=\"/manifest.json\">\n  <meta name=\"theme-color\" content=\"#4f46e5\">\n  \n  <!-- iOS -->\n  <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n  <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\">\n  <meta name=\"apple-mobile-web-app-title\" content=\"TaskMaster\">\n  <link rel=\"apple-touch-icon\" href=\"/icons/icon-192x192.png\">\n  \n  <!-- Icons -->\n  <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/icons/icon-32x32.png\">\n  <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/icons/icon-16x16.png\">\n  \n  <title>TaskMaster</title>\n</head>\n<body>\n  <div id=\"app\"></div>\n</body>\n</html>"
    },
    {
      "id": "offline-strategies",
      "moduleId": "pwa-basics",
      "title": "Offline Strategies",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Multiple caching strategies depending on resource type\n- Cache First: fast, for static assets\n- Network First: fresh, for dynamic data\n- Stale While Revalidate: performance/freshness compromise\n- Offline page: fallback when everything fails\n- Background Sync: deferred synchronization\n\n---\n\n# Offline Strategies: The Art of Caching\n\n## Why Different Strategies?\n\nNot all resources have the same needs:\n- **CSS/JS**: Can be cached long-term\n- **API/Data**: Need freshness\n- **Images**: Size/performance compromise\n\n## The 5 Main Strategies\n\n### 1. Cache Only\n\nNever go to the network. Useful for versioned static assets.\n\n```javascript\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request)\n  );\n});\n```\n\n**Usage:**\n- Immutable resources with hash (app.abc123.js)\n\n---\n\n### 2. Network Only\n\nAlways fetch from network. No cache.\n\n```javascript\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    fetch(event.request)\n  );\n});\n```\n\n**Usage:**\n- Real-time data\n- Analytics\n\n---\n\n### 3. Cache First (Cache Falling Back to Network)\n\n**Most common strategy for PWAs.**\n\n```javascript\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      // Return from cache if available\n      if (response) {\n        return response;\n      }\n      \n      // Otherwise fetch and cache\n      return fetch(event.request).then(networkResponse => {\n        return caches.open(CACHE_NAME).then(cache => {\n          cache.put(event.request, networkResponse.clone());\n          return networkResponse;\n        });\n      });\n    })\n  );\n});\n```\n\n**Usage:**\n- Images\n- Fonts\n- Static JS/CSS files\n- Complete pages\n\n**Advantages:** Fast, works offline\n**Disadvantages:** Can serve stale content\n\n---\n\n### 4. Network First (Network Falling Back to Cache)\n\nTry network first, then cache.\n\n```javascript\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    fetch(event.request)\n      .then(networkResponse => {\n        // Update cache\n        const clone = networkResponse.clone();\n        caches.open(CACHE_NAME).then(cache => {\n          cache.put(event.request, clone);\n        });\n        return networkResponse;\n      })\n      .catch(() => {\n        // Offline: return from cache\n        return caches.match(event.request);\n      })\n  );\n});\n```\n\n**Usage:**\n- API calls\n- Dynamic content\n- User data\n\n**Advantages:** Always fresh when online\n**Disadvantages:** Slower when offline\n\n---\n\n### 5. Stale While Revalidate\n\n**Best compromise for most use cases.**\n\n```javascript\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request).then(cachedResponse => {\n      // Return cache immediately (fast)\n      const fetchPromise = fetch(event.request).then(networkResponse => {\n        // Update cache in background\n        caches.open(CACHE_NAME).then(cache => {\n          cache.put(event.request, networkResponse.clone());\n        });\n        return networkResponse;\n      });\n      \n      // Return cache or wait for network\n      return cachedResponse || fetchPromise;\n    })\n  );\n});\n```\n\n**How it works:**\n1. Return cache immediately (instant)\n2. Fetch from network in background\n3. Update cache for next time\n\n**Usage:**\n- Articles, content\n- Product pages\n- Anything that can be slightly outdated\n\n---\n\n## Offline Fallback Page\n\n```javascript\nconst CACHE_NAME = 'my-app-v1';\n\n// Precache offline page\nconst urlsToCache = [\n  '/',\n  '/offline.html',\n  '/styles.css'\n];\n\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(urlsToCache))\n  );\n});\n\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    fetch(event.request)\n      .catch(() => {\n        // Network failed\n        return caches.match(event.request)\n          .then(response => {\n            // Return cache or offline page\n            return response || caches.match('/offline.html');\n          });\n      })\n  );\n});\n```\n\n## Background Sync\n\nDefer actions when offline:\n\n```javascript\n// In your app\nasync function saveData(data) {\n  try {\n    await fetch('/api/save', {\n      method: 'POST',\n      body: JSON.stringify(data)\n    });\n  } catch (error) {\n    // Register for background sync\n    const registration = await navigator.serviceWorker.ready;\n    await registration.sync.register('sync-data');\n    \n    // Save locally\n    localStorage.setItem('pending-data', JSON.stringify(data));\n  }\n}\n\n// In service worker\nself.addEventListener('sync', event => {\n  if (event.tag === 'sync-data') {\n    event.waitUntil(syncPendingData());\n  }\n});\n\nasync function syncPendingData() {\n  const data = localStorage.getItem('pending-data');\n  if (data) {\n    await fetch('/api/save', {\n      method: 'POST',\n      body: data\n    });\n    localStorage.removeItem('pending-data');\n  }\n}\n```\n\n## Strategy Selection Guide\n\n| Resource Type | Strategy | Why |\n|--------------|----------|-----|\n| Static assets (JS, CSS) | Cache First | Rarely change |\n| API calls | Network First | Need fresh data |\n| Images | Cache First | Large, don't change |\n| User content | Stale While Revalidate | Balance |\n| Real-time data | Network Only | Must be fresh |\n\n## Testing Offline\n\nChrome DevTools → Network tab → \"Offline\" checkbox\n\nOr in console:\n```javascript\n// Simulate offline\nnavigator.connection.saveData = true;\n\n// Check connection\nif (!navigator.onLine) {\n  console.log('Offline mode');\n}\n\n// Listen for changes\nwindow.addEventListener('online', () => console.log('Back online'));\nwindow.addEventListener('offline', () => console.log('Gone offline'));\n```",
      "codeExample": "// Service Worker with differentiated strategies\n\nconst CACHE_NAME = 'my-app-v2';\nconst STATIC_CACHE = 'static-v2';\nconst DYNAMIC_CACHE = 'dynamic-v2';\n\nconst STATIC_ASSETS = [\n  '/',\n  '/index.html',\n  '/offline.html',\n  '/styles.css',\n  '/app.js',\n  '/icons/icon-192.png'\n];\n\n// Installation\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then(cache => cache.addAll(STATIC_ASSETS))\n  );\n  self.skipWaiting();\n});\n\n// Activation\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames\n          .filter(name => !name.startsWith('static') && !name.startsWith('dynamic'))\n          .map(name => caches.delete(name))\n      );\n    })\n  );\n  self.clients.claim();\n});\n\n// Fetch with intelligent routing\nself.addEventListener('fetch', event => {\n  const { request } = event;\n  const url = new URL(request.url);\n  \n  // HTML pages - Network First with offline fallback\n  if (request.mode === 'navigate') {\n    event.respondWith(\n      fetch(request)\n        .catch(() => caches.match(request) || caches.match('/offline.html'))\n    );\n    return;\n  }\n  \n  // API calls - Network First\n  if (url.pathname.startsWith('/api/')) {\n    event.respondWith(\n      fetch(request)\n        .then(response => {\n          const clone = response.clone();\n          caches.open(DYNAMIC_CACHE).then(cache => cache.put(request, clone));\n          return response;\n        })\n        .catch(() => caches.match(request))\n    );\n    return;\n  }\n  \n  // Static assets (JS, CSS) - Cache First\n  if (url.pathname.match(/\\.(js|css)$/)) {\n    event.respondWith(\n      caches.match(request).then(cached => {\n        if (cached) return cached;\n        \n        return fetch(request).then(response => {\n          const clone = response.clone();\n          caches.open(STATIC_CACHE).then(cache => cache.put(request, clone));\n          return response;\n        });\n      })\n    );\n    return;\n  }\n  \n  // Images - Stale While Revalidate\n  if (url.pathname.match(/\\.(png|jpg|jpeg|gif|webp|svg)$/)) {\n    event.respondWith(\n      caches.match(request).then(cached => {\n        const fetchPromise = fetch(request).then(networkResponse => {\n          caches.open(DYNAMIC_CACHE).then(cache => {\n            cache.put(request, networkResponse.clone());\n          });\n          return networkResponse;\n        }).catch(() => cached);\n        \n        return cached || fetchPromise;\n      })\n    );\n    return;\n  }\n  \n  // Default: Network First\n  event.respondWith(\n    fetch(request).catch(() => caches.match(request))\n  );\n});\n\n// Background sync\nself.addEventListener('sync', event => {\n  if (event.tag === 'background-sync') {\n    event.waitUntil(doBackgroundSync());\n  }\n});\n\nasync function doBackgroundSync() {\n  // Sync pending data\n  const db = await openDB('sync-store', 1);\n  const pending = await db.getAll('pending');\n  \n  for (const item of pending) {\n    try {\n      await fetch(item.url, {\n        method: item.method,\n        body: item.body\n      });\n      await db.delete('pending', item.id);\n    } catch (error) {\n      console.error('Sync failed for', item.id);\n    }\n  }\n}"
    }
  ],
  "exercises": [
    {
      "id": "pwa-ex-1",
      "lessonId": "service-workers",
      "moduleId": "pwa-basics",
      "title": "Service Workers Quiz",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "What is a Service Worker?",
          "options": [
            "A local web server",
            "A JavaScript script that runs in the background",
            "A new type of browser",
            "A client-side database"
          ],
          "correctAnswer": 1,
          "explanation": "A Service Worker is a JavaScript script that runs in the background, independently of the web page, and can intercept network requests."
        },
        {
          "question": "Which event triggers during Service Worker installation?",
          "options": [
            "'setup'",
            "'install'",
            "'activate'",
            "'ready'"
          ],
          "correctAnswer": 1,
          "explanation": "The 'install' event triggers during Service Worker installation. This is the right time to cache static resources."
        },
        {
          "question": "Why do Service Workers require HTTPS?",
          "options": [
            "For performance reasons",
            "For security and to prevent man-in-the-middle attacks",
            "Because it's an Apple requirement",
            "To enable offline mode"
          ],
          "correctAnswer": 1,
          "explanation": "HTTPS is mandatory because Service Workers have significant power (intercepting all requests). Without HTTPS, an attacker could inject a malicious SW."
        }
      ]
    },
    {
      "id": "pwa-ex-2",
      "lessonId": "offline-strategies",
      "moduleId": "pwa-basics",
      "title": "Cache Strategies Quiz",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "Which strategy is recommended for static assets (CSS, JS)?",
          "options": [
            "Network First",
            "Cache First",
            "Network Only",
            "No Cache"
          ],
          "correctAnswer": 1,
          "explanation": "Cache First is ideal for static assets because they don't change often. Cache them once and serve quickly."
        },
        {
          "question": "Which strategy guarantees the freshest data?",
          "options": [
            "Cache First",
            "Stale While Revalidate",
            "Network First",
            "Cache Only"
          ],
          "correctAnswer": 2,
          "explanation": "Network First tries the network first. If it fails, only then does it use the cache. This is perfect for data that needs to be fresh."
        },
        {
          "question": "In 'Stale While Revalidate', what happens?",
          "options": [
            "Wait for network before displaying",
            "Display from cache and update in background",
            "Delete cache on every request",
            "Disable cache"
          ],
          "correctAnswer": 1,
          "explanation": "Stale While Revalidate immediately displays content from cache (fast), then updates the cache in the background with the fresh version from the network."
        }
      ]
    },
    {
      "id": "pwa-ex-3",
      "lessonId": "web-app-manifest",
      "moduleId": "pwa-basics",
      "title": "Web App Manifest Quiz",
      "difficulty": "easy",
      "type": "quiz",
      "questions": [
        {
          "question": "What is the manifest.json file used for?",
          "options": [
            "To configure the Service Worker",
            "To describe the application (name, icons, colors)",
            "To store user data",
            "To compile JavaScript code"
          ],
          "correctAnswer": 1,
          "explanation": "The manifest.json describes the application to the browser: its name, icons, colors, how it should display, etc."
        },
        {
          "question": "Which 'display' value gives the most native appearance (no address bar)?",
          "options": [
            "'browser'",
            "'standalone'",
            "'window'",
            "'app'"
          ],
          "correctAnswer": 1,
          "explanation": "'standalone' removes the address bar and gives the app a native appearance, like a real mobile application."
        },
        {
          "question": "What is the minimum recommended icon size for a PWA?",
          "options": [
            "64x64",
            "192x192",
            "512x512",
            "1024x1024"
          ],
          "correctAnswer": 1,
          "explanation": "192x192 is the minimum recommended size for the PWA to be installable on the home screen. 512x512 is recommended for the splash screen."
        }
      ]
    }
  ]
}