{
  "module": {
    "id": "nextjs-server-components",
    "title": "Server Components",
    "description": "Master React Server Components in Next.js App Router",
    "icon": "Server",
    "requiredXp": 8000,
    "color": "from-gray-700 to-gray-900",
    "courseId": "nextjs"
  },
  "lessons": [
    {
      "id": "rsc-intro",
      "moduleId": "nextjs-server-components",
      "title": "What are Server Components?",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Server Components run on the server, never in browser\n- Zero JavaScript bundle size for Server Components\n- Can access server-side resources directly (DB, filesystem)\n- Can't use useState, useEffect, or browser APIs\n- Client Components are traditional React components\n\n---\n\n# Understanding React Server Components\n\n## The Problem They Solve\n\nTraditional React apps send all component code to the browser:\n\n```javascript\n// Client Component (old way)\nimport { useState, useEffect } from 'react';\nimport { heavyLibrary } from 'heavy-library'; // Sent to browser!\n\nfunction ProductList() {\n  const [products, setProducts] = useState([]);\n  \n  useEffect(() => {\n    fetch('/api/products')\n      .then(res => res.json())\n      .then(data => setProducts(data));\n  }, []);\n  \n  return (...);\n}\n```\n\n**Problems:**\n- JavaScript bundle includes heavy libraries\n- Loading states while fetching data\n- Waterfall requests\n- SEO challenges\n\n## Server Components Solution\n\n```javascript\n// Server Component (runs only on server)\nimport { heavyLibrary } from 'heavy-library'; // Never sent to browser!\nimport { db } from './db'; // Direct database access\n\nasync function ProductList() {\n  // Runs on server - zero bundle impact!\n  const products = await db.products.findMany();\n  \n  return (\n    <div>\n      {products.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  );\n}\n```\n\n**Benefits:**\n- Zero bundle size impact\n- Direct backend access\n- No loading states needed\n- Automatic code splitting\n- Better SEO (HTML rendered on server)\n\n## Server vs Client Components\n\n### Server Components (Default in App Router)\n\n‚úÖ **Can do:**\n- Access databases/filesystems directly\n- Call private APIs\n- Render large dependencies without bundle cost\n- Keep sensitive data on server\n\n‚ùå **Cannot do:**\n- Use React hooks (useState, useEffect, etc.)\n- Use browser APIs (window, document, localStorage)\n- Use event handlers (onClick, onSubmit)\n- Use context providers\n\n### Client Components\n\n‚úÖ **Can do:**\n- Use all React hooks\n- Use browser APIs\n- Add event handlers\n- Use context\n\n‚ùå **Limitations:**\n- JavaScript sent to browser\n- Must 'use client' directive\n- Can't access server-only resources\n\n## The 'use client' Directive\n\nMark a component as client-side:\n\n```javascript\n'use client';\n\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <button onClick={() => setCount(count + 1)}>\n      Count: {count}\n    </button>\n  );\n}\n```\n\n**Rules:**\n- Place at the very top of the file\n- Only needed once - child components automatically become client components\n- Without it, component is a Server Component\n\n## Interleaving Pattern\n\nServer Components can import and render Client Components:\n\n```javascript\n// Server Component (page.js)\nimport { db } from './db';\nimport { LikeButton } from './LikeButton'; // Client Component\n\nexport default async function ProductPage({ params }) {\n  // Runs on server\n  const product = await db.products.findById(params.id);\n  \n  return (\n    <article>\n      <h1>{product.name}</h1>\n      <p>{product.description}</p>\n      \n      {/* Client Component - interactivity in server-rendered page */}\n      <LikeButton productId={product.id} />\n    </article>\n  );\n}\n```\n\n```javascript\n// Client Component (LikeButton.js)\n'use client';\n\nimport { useState } from 'react';\n\nexport function LikeButton({ productId }) {\n  const [liked, setLiked] = useState(false);\n  \n  return (\n    <button onClick={() => setLiked(!liked)}>\n      {liked ? '‚ù§Ô∏è' : 'ü§ç'}\n    </button>\n  );\n}\n```\n\n## Common Patterns\n\n**1. Server Component fetches data, passes to Client Component:**\n```javascript\n// Server Component\nasync function Page() {\n  const data = await fetchData(); // Server-side\n  return <ClientComponent data={data} />;\n}\n\n// Client Component\n'use client';\nfunction ClientComponent({ data }) {\n  const [filter, setFilter] = useState('');\n  // Interactivity with server-fetched data\n}\n```\n\n**2. Lift client behavior up:**\n```javascript\n// Keep as much as possible server-side\nfunction ProductPage() {\n  const product = await getProduct(); // Server Component\n  \n  return (\n    <div>\n      <ProductInfo product={product} /> {/* Server */}\n      <AddToCartButton productId={product.id} /> {/* Client */}\n    </div>\n  );\n}\n```"
    },
    {
      "id": "rsc-data-fetching",
      "moduleId": "nextjs-server-components",
      "title": "Data Fetching Patterns",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Fetch directly in Server Components\n- fetch() is automatically cached and deduplicated\n- Can use async/await in components\n- Multiple fetches run in parallel by default\n- Loading UI with loading.js files\n\n---\n\n# Data Fetching in Server Components\n\n## Basic Fetching\n\n```javascript\n// app/users/page.js\nasync function UsersPage() {\n  // Runs on server during render\n  const response = await fetch('https://api.example.com/users');\n  const users = await response.json();\n  \n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n## Fetching with Database\n\n```javascript\nimport { db } from '@/lib/db';\n\nasync function PostsPage() {\n  // Direct database access - no API needed!\n  const posts = await db.post.findMany({\n    include: { author: true },\n    orderBy: { createdAt: 'desc' },\n    take: 10\n  });\n  \n  return (\n    <div>\n      {posts.map(post => (\n        <article key={post.id}>\n          <h2>{post.title}</h2>\n          <p>By {post.author.name}</p>\n        </article>\n      ))}\n    </div>\n  );\n}\n```\n\n## Request Deduplication\n\nMultiple fetches to the same URL are automatically deduplicated:\n\n```javascript\nasync function Page() {\n  // These two fetches share the same promise!\n  const artistData = getArtist('tom');\n  const albumsData = getAlbums('tom');\n  \n  // Both start fetching immediately\n  const [artist, albums] = await Promise.all([artistData, albumsData]);\n  \n  return (...);\n}\n\n// Even if getArtist is called multiple times,\n// the fetch is only executed once per request\nasync function getArtist(username) {\n  const res = await fetch(`https://api.example.com/artist/${username}`);\n  return res.json();\n}\n```\n\n## Caching Strategies\n\n### Default Caching\n\n```javascript\n// Cached indefinitely (static data)\nconst data = await fetch('https://api.example.com/data');\n```\n\n### Time-based Revalidation\n\n```javascript\n// Revalidate every 60 seconds\nconst data = await fetch('https://api.example.com/data', {\n  next: { revalidate: 60 }\n});\n```\n\n### On-demand Revalidation\n\n```javascript\n// Revalidate using tags\nconst data = await fetch('https://api.example.com/data', {\n  next: { tags: ['posts'] }\n});\n\n// Later, trigger revalidation\n// app/api/revalidate/route.js\nimport { revalidateTag } from 'next/cache';\n\nexport async function POST() {\n  revalidateTag('posts');\n  return Response.json({ revalidated: true });\n}\n```\n\n### No Caching (Dynamic)\n\n```javascript\n// Never cache\nconst data = await fetch('https://api.example.com/data', {\n  cache: 'no-store'\n});\n\n// Or make entire route dynamic\nexport const dynamic = 'force-dynamic';\n```\n\n## Loading States\n\n### Loading.js Convention\n\n```javascript\n// app/blog/loading.js\nexport default function Loading() {\n  return (\n    <div className=\"loading\">\n      <div className=\"spinner\"></div>\n      <p>Loading posts...</p>\n    </div>\n  );\n}\n```\n\n### React Suspense\n\n```javascript\nimport { Suspense } from 'react';\n\nasync function Page() {\n  return (\n    <div>\n      <header>My Blog</header>\n      \n      <Suspense fallback={<PostsSkeleton />}>\n        <Posts />\n      </Suspense>\n    </div>\n  );\n}\n\nasync function Posts() {\n  const posts = await fetchPosts();\n  return (...);\n}\n```\n\n## Error Handling\n\n### Error.js Convention\n\n```javascript\n// app/blog/error.js\n'use client';\n\nexport default function Error({ error, reset }) {\n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <button onClick={() => reset()}>Try again</button>\n    </div>\n  );\n}\n```\n\n### Try-Catch in Components\n\n```javascript\nasync function ProductPage({ params }) {\n  try {\n    const product = await fetchProduct(params.id);\n    \n    if (!product) {\n      notFound(); // Show 404 page\n    }\n    \n    return (...);\n  } catch (error) {\n    return <ErrorMessage error={error} />;\n  }\n}\n```\n\n## Parallel vs Sequential Fetching\n\n### Sequential (Waterfall - Slower)\n\n```javascript\nasync function Page() {\n  const artist = await fetchArtist(); // Wait...\n  const albums = await fetchAlbums(); // Wait...\n  const songs = await fetchSongs();   // Wait...\n  return (...);\n}\n```\n\n### Parallel (Faster)\n\n```javascript\nasync function Page() {\n  // Start all fetches immediately\n  const artistPromise = fetchArtist();\n  const albumsPromise = fetchAlbums();\n  const songsPromise = fetchSongs();\n  \n  // Wait for all to complete\n  const [artist, albums, songs] = await Promise.all([\n    artistPromise,\n    albumsPromise,\n    songsPromise\n  ]);\n  \n  return (...);\n}\n```\n\n### Pattern for Dependencies\n\n```javascript\nasync function Page() {\n  // Independent fetches - parallel\n  const userPromise = fetchUser();\n  const postsPromise = fetchPosts();\n  \n  const user = await userPromise;\n  \n  // Dependent fetch - sequential after user\n  const settingsPromise = fetchSettings(user.id);\n  \n  const [posts, settings] = await Promise.all([\n    postsPromise,\n    settingsPromise\n  ]);\n  \n  return (...);\n}\n```"
    },
    {
      "id": "rsc-patterns",
      "moduleId": "nextjs-server-components",
      "title": "Server Component Patterns",
      "order": 3,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Keep Client Components as small as possible\n- Pass server data to client components via props\n- Use Server Actions for mutations\n- Compose patterns for optimal performance\n- Server Components can be async\n\n---\n\n# Server Component Design Patterns\n\n## 1. The Leaves Pattern\n\nPush client interactivity to the \"leaves\" of your component tree:\n\n```javascript\n// Server Component (page.js)\nasync function ProductPage({ params }) {\n  const product = await getProduct(params.id);\n  const reviews = await getReviews(params.id);\n  \n  return (\n    <div>\n      <ProductInfo product={product} /> {/* Server */}\n      <ProductGallery images={product.images} /> {/* Server */}\n      <ReviewsList reviews={reviews} /> {/* Server */}\n      \n      {/* Only the interactive parts are client components */}\n      <AddToCartButton productId={product.id} /> {/* Client */}\n      <ReviewForm productId={product.id} /> {/* Client */}\n    </div>\n  );\n}\n```\n\n## 2. Component Composition\n\nServer Components compose with Client Components:\n\n```javascript\n// Server Component wrapper\nfunction ProductLayout({ children }) {\n  return (\n    <div className=\"product-layout\">\n      <Sidebar /> {/* Server */}\n      <MainContent>{children}</MainContent>\n    </div>\n  );\n}\n\n// Client Component inside\n'use client';\nfunction ProductTabs({ children }) {\n  const [activeTab, setActiveTab] = useState('details');\n  \n  return (\n    <div>\n      <TabList activeTab={activeTab} onChange={setActiveTab} />\n      <TabContent>{children}</TabContent>\n    </div>\n  );\n}\n```\n\n## 3. The Provider Pattern\n\nLift providers to the root, use children:\n\n```javascript\n// app/layout.js (Server Component)\nimport { ThemeProvider } from './ThemeProvider';\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        <ThemeProvider>\n          {children} {/* Server Components can be children */}\n        </ThemeProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n```javascript\n// ThemeProvider.js\n'use client';\n\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext();\n\nexport function ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n## 4. Server Actions\n\nHandle mutations on the server:\n\n```javascript\n// app/actions.js\n'use server';\n\nimport { db } from '@/lib/db';\nimport { revalidatePath } from 'next/cache';\n\nexport async function createPost(formData) {\n  'use server';\n  \n  const title = formData.get('title');\n  const content = formData.get('content');\n  \n  await db.post.create({\n    data: { title, content }\n  });\n  \n  revalidatePath('/posts');\n}\n```\n\n```javascript\n// Client Component\n'use client';\n\nimport { createPost } from './actions';\n\nexport function CreatePostForm() {\n  return (\n    <form action={createPost}>\n      <input name=\"title\" placeholder=\"Title\" />\n      <textarea name=\"content\" placeholder=\"Content\" />\n      <button type=\"submit\">Create Post</button>\n    </form>\n  );\n}\n```\n\n## 5. Dynamic Imports for Client Components\n\nLoad client components only when needed:\n\n```javascript\nimport dynamic from 'next/dynamic';\n\n// Heavy chart component loaded on demand\nconst Chart = dynamic(() => import('./Chart'), {\n  loading: () => <p>Loading chart...</p>,\n  ssr: false // Don't render on server\n});\n\nasync function Dashboard() {\n  const data = await fetchData();\n  \n  return (\n    <div>\n      <Summary data={data} /> {/* Server */}\n      <Chart data={data} /> {/* Client - loaded dynamically */}\n    </div>\n  );\n}\n```\n\n## 6. Form Handling Pattern\n\nServer-rendered forms with client enhancements:\n\n```javascript\n// Server Component\nasync function ContactPage() {\n  return (\n    <form action={submitContact}\n      {/* Fallback for no JavaScript */}\n      <input name=\"email\" type=\"email\" required />\n      <textarea name=\"message\" required />\n      <button type=\"submit\">Send</button>\n      \n      {/* Client enhancement */}\n      <FormStatus />\n    </form>\n  );\n}\n\n// Client Component for status\n'use client';\nfunction FormStatus() {\n  const { pending } = useFormStatus();\n  \n  return pending ? <Spinner /> : null;\n}\n```\n\n## 7. SearchParams Pattern\n\nHandle URL search params server-side:\n\n```javascript\nasync function SearchPage({ searchParams }) {\n  // Access URL query parameters\n  const query = searchParams.q || '';\n  const page = parseInt(searchParams.page) || 1;\n  \n  const results = await searchProducts(query, page);\n  \n  return (\n    <div>\n      <SearchForm initialQuery={query} />\n      <Results products={results} />\n      <Pagination page={page} />\n    </div>\n  );\n}\n```\n\n## 8. Route Handlers (API Routes)\n\nCreate API endpoints in App Router:\n\n```javascript\n// app/api/users/route.js\nimport { NextResponse } from 'next/server';\n\nexport async function GET() {\n  const users = await db.user.findMany();\n  return NextResponse.json(users);\n}\n\nexport async function POST(request) {\n  const body = await request.json();\n  const user = await db.user.create({ data: body });\n  return NextResponse.json(user, { status: 201 });\n}\n```\n\n## Common Mistakes to Avoid\n\n‚ùå Importing Server Components into Client Components\n```javascript\n// BAD\n'use client';\nimport { ServerComponent } from './ServerComponent'; // Won't work!\n```\n\n‚úÖ Pass as children instead:\n```javascript\n// GOOD\n'use client';\nexport function ClientWrapper({ children }) {\n  return <div>{children}</div>;\n}\n\n// Usage\n<ClientWrapper>\n  <ServerComponent />\n</ClientWrapper>\n```\n\n‚ùå Using async in Client Components\n```javascript\n// BAD\n'use client';\nasync function ClientComponent() { // Error!\n  const data = await fetchData();\n}\n```\n\n‚úÖ Use useEffect or Server Components:\n```javascript\n// GOOD\n'use client';\nfunction ClientComponent() {\n  useEffect(() => {\n    fetchData().then(setData);\n  }, []);\n}\n```"
    }
  ],
  "exercises": [
    {
      "id": "rsc-ex-1",
      "type": "quiz",
      "lessonId": "rsc-intro",
      "moduleId": "nextjs-server-components",
      "title": "Server Components Basics",
      "difficulty": "easy",
      "questions": [
        {
          "question": "What happens to code in Server Components?",
          "options": [
            "It's sent to the browser and executed there",
            "It runs only on the server and never reaches the browser",
            "It's compiled to WebAssembly",
            "It's cached in localStorage"
          ],
          "correctAnswer": 1,
          "explanation": "Server Components run exclusively on the server. Their code and any server-side imports never reach the browser, resulting in zero JavaScript bundle size."
        },
        {
          "question": "Which of these CANNOT be used in a Server Component?",
          "options": [
            "Direct database queries",
            "useState hook",
            "File system access",
            "Private API calls"
          ],
          "correctAnswer": 1,
          "explanation": "Server Components cannot use React hooks like useState or useEffect. These require client-side interactivity and must be used in Client Components (marked with 'use client')."
        }
      ]
    }
  ]
}
