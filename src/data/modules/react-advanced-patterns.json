{
  "module": {
    "id": "react-advanced-patterns",
    "title": "Advanced React Patterns",
    "description": "Master Error Boundaries, Code Splitting, and Portals for production-ready apps",
    "icon": "Layers",
    "requiredXp": 3000,
    "color": "from-indigo-400 to-indigo-600",
    "courseId": "react"
  },
  "lessons": [
    {
      "id": "error-boundaries",
      "moduleId": "react-advanced-patterns",
      "title": "Error Boundaries",
      "order": 1,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Error boundaries catch JavaScript errors anywhere in child component tree.\n- Display fallback UI instead of crashing the whole app.\n- Only class components can be error boundaries.\n- Doesn't catch errors in: event handlers, async code, server-side rendering.\n\n---\n\n# Error Boundaries: Graceful Error Handling\n\n## The Problem\n\nWithout error boundaries, one component crash breaks the entire app:\n\n```jsx\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <BuggyComponent />  {/* üí• Crash here */}\n      <Footer />          {/* Never renders */}\n    </div>\n  );\n}\n```\n\n## The Solution\n\nError boundaries catch errors and show fallback UI:\n\n```jsx\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <ErrorBoundary fallback={<p>Something went wrong!</p>}>\n        <BuggyComponent />  {/* Crash contained here */}\n      </ErrorBoundary>\n      <Footer />          {/* Still renders! */}\n    </div>\n  );\n}\n```\n\n## Creating an Error Boundary (Class Component)\n\n```jsx\nimport { Component } from 'react';\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  // Update state when error occurs\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  // Log error to service\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught:', error);\n    console.error('Component stack:', errorInfo.componentStack);\n    // Send to error tracking service (Sentry, etc.)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n```\n\n## Using Error Boundaries\n\n```jsx\nimport ErrorBoundary from './ErrorBoundary';\n\nfunction App() {\n  return (\n    <div>\n      {/* Each section wrapped independently */}\n      <ErrorBoundary fallback={<p>Header failed to load</p>}>\n        <Header />\n      </ErrorBoundary>\n      \n      <ErrorBoundary fallback={<p>Content failed to load</p>}>\n        <MainContent />\n      </ErrorBoundary>\n      \n      <ErrorBoundary>\n        <Footer />\n      </ErrorBoundary>\n    </div>\n  );\n}\n```\n\n## Modern React: react-error-boundary Package\n\n```bash\nnpm install react-error-boundary\n```\n\n```jsx\nimport { ErrorBoundary } from 'react-error-boundary';\n\nfunction ErrorFallback({ error, resetErrorBoundary }) {\n  return (\n    <div role=\"alert\">\n      <p>Something went wrong:</p>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>Try again</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onReset={() => {\n        // Reset app state here\n      }}\n    >\n      <MyComponent />\n    </ErrorBoundary>\n  );\n}\n```\n\n## What Error Boundaries DON'T Catch\n\n‚ùå Event handlers:\n```jsx\n<button onClick={() => { throw new Error('Not caught!') }}>\n  Click\n</button>\n```\n\n‚ùå Async code:\n```jsx\nuseEffect(() => {\n  fetch('/api').then(() => {\n    throw new Error('Not caught!');\n  });\n}, []);\n```\n\n‚ùå Server-side rendering\n\n‚úÖ Solution: Use try/catch for these cases.\n\n## Best Practices\n\n1. **Wrap major sections** independently\n2. **Provide meaningful fallback UI**\n3. **Log errors to monitoring service**\n4. **Allow users to retry** (resetErrorBoundary)\n5. **Don't wrap everything in one boundary**",
      "codeExample": "import { Component, useState } from 'react';\n\n// Error Boundary Component\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error);\n    // Send to error tracking service\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div style={{ padding: '20px', background: '#ffebee', borderRadius: '8px' }}>\n          <h2>‚ö†Ô∏è Something went wrong</h2>\n          <details>\n            <summary>Error details</summary>\n            <pre>{this.state.error?.toString()}</pre>\n          </details>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Component that might crash\nfunction BuggyCounter() {\n  const [count, setCount] = useState(0);\n\n  if (count > 5) {\n    throw new Error('Count is too high!');\n  }\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(c => c + 1)}>\n        Increment (crashes at 6)\n      </button>\n    </div>\n  );\n}\n\n// App using error boundary\nfunction App() {\n  return (\n    <div>\n      <h1>My App</h1>\n      <p>This content always shows</p>\n      \n      <ErrorBoundary>\n        <BuggyCounter />\n      </ErrorBoundary>\n      \n      <p>This content also shows even if counter crashes</p>\n    </div>\n  );\n}"
    },
    {
      "id": "code-splitting",
      "moduleId": "react-advanced-patterns",
      "title": "Code Splitting with lazy and Suspense",
      "order": 2,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Code splitting = Load code only when needed (smaller initial bundle).\n- `React.lazy()` dynamically imports components.\n- `Suspense` shows fallback UI while loading.\n- Improves initial page load time significantly.\n\n---\n\n# Code Splitting: Load Less, Faster\n\n## The Problem\n\n**Without code splitting:**\n```jsx\nimport HeavyChart from './HeavyChart';      // 100KB\nimport HeavyDashboard from './HeavyDashboard'; // 200KB\nimport HeavyMap from './HeavyMap';          // 150KB\n// Total: 450KB loaded upfront!\n```\n\nUser downloads everything even if they never visit dashboard.\n\n## The Solution\n\n**With code splitting:**\n```jsx\nconst HeavyChart = lazy(() => import('./HeavyChart'));\nconst HeavyDashboard = lazy(() => import('./HeavyDashboard'));\nconst HeavyMap = lazy(() => import('./HeavyMap'));\n// Only load what's needed!\n```\n\n## Basic Syntax\n\n### Step 1: Import lazy and Suspense\n```jsx\nimport { lazy, Suspense } from 'react';\n```\n\n### Step 2: Create Lazy Components\n```jsx\n// Instead of: import MyComponent from './MyComponent';\nconst MyComponent = lazy(() => import('./MyComponent'));\n```\n\n### Step 3: Wrap with Suspense\n```jsx\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <MyComponent />\n    </Suspense>\n  );\n}\n```\n\n## Real-World Example\n\n```jsx\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\n// Regular imports (small, needed immediately)\nimport Header from './Header';\nimport Home from './Home';\n\n// Lazy imports (heavy, load on demand)\nconst Dashboard = lazy(() => import('./Dashboard'));\nconst Analytics = lazy(() => import('./Analytics'));\nconst UserProfile = lazy(() => import('./UserProfile'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Header />\n      <Suspense fallback={<div>Loading page...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n          <Route path=\"/analytics\" element={<Analytics />} />\n          <Route path=\"/profile/:id\" element={<UserProfile />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n```\n\n## Better Loading States\n\n```jsx\nfunction LoadingSpinner() {\n  return (\n    <div className=\"loading-container\">\n      <div className=\"spinner\" />\n      <p>Loading...</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<LoadingSpinner />}>\n      <MyComponent />\n    </Suspense>\n  );\n}\n```\n\n## Nested Suspense\n\n```jsx\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading layout...</div>}>\n      <Layout>\n        <Suspense fallback={<div>Loading sidebar...</div>}>\n          <Sidebar />\n        </Suspense>\n        \n        <Suspense fallback={<div>Loading main content...</div>}>\n          <MainContent />\n        </Suspense>\n      </Layout>\n    </Suspense>\n  );\n}\n```\n\n## Code Splitting Tips\n\n### 1. Split by Route\nEach route = separate chunk\n\n### 2. Split Heavy Components\nCharts, maps, editors, data grids\n\n### 3. Don't Over-Split\n- Too many small chunks = HTTP overhead\n- Bundle size analyzer helps find balance\n\n### 4. Preload on Hover\n```jsx\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\n\nfunction Link() {\n  return (\n    <a\n      href=\"/heavy-page\"\n      onMouseEnter={() => import('./HeavyComponent') /* Preload! */}\n    >\n      Go to Heavy Page\n    </a>\n  );\n}\n```",
      "codeExample": "import { lazy, Suspense, useState } from 'react';\n\n// Lazy load heavy components\nconst HeavyChart = lazy(() => import('./HeavyChart'));\nconst HeavyMap = lazy(() => import('./HeavyMap'));\n\nfunction Loading() {\n  return (\n    <div style={{ padding: '20px', textAlign: 'center' }}>\n      <div style={{\n        width: '40px',\n        height: '40px',\n        border: '4px solid #f3f3f3',\n        borderTop: '4px solid #3498db',\n        borderRadius: '50%',\n        animation: 'spin 1s linear infinite',\n        margin: '0 auto'\n      }} />\n      <p>Loading component...</p>\n    </div>\n  );\n}\n\nfunction App() {\n  const [showChart, setShowChart] = useState(false);\n  const [showMap, setShowMap] = useState(false);\n\n  return (\n    <div>\n      <h1>Code Splitting Demo</h1>\n      \n      <button onClick={() => setShowChart(!showChart)}>\n        {showChart ? 'Hide' : 'Show'} Chart\n      </button>\n      \n      <button onClick={() => setShowMap(!showMap)}>\n        {showMap ? 'Hide' : 'Show'} Map\n      </button>\n      \n      {showChart && (\n        <Suspense fallback={<Loading />}>\n          <HeavyChart />\n        </Suspense>\n      )}\n      \n      {showMap && (\n        <Suspense fallback={<Loading />}>\n          <HeavyMap />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// Simulated HeavyChart component (HeavyChart.jsx)\n/*\nexport default function HeavyChart() {\n  // Imagine this imports a charting library\n  return <div>üìä Heavy Chart Component (100KB)</div>;\n}\n*/\n\n// Add this to your CSS for the spinner animation\n/*\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n*/"
    },
    {
      "id": "react-portals",
      "moduleId": "react-advanced-patterns",
      "title": "Portals: Rendering Outside the Tree",
      "order": 3,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Portals render children into a different DOM node (outside parent hierarchy).\n- Useful for: modals, tooltips, dropdowns, toasts.\n- Event bubbling still works (events propagate through React tree, not DOM).\n- Portal content can access React context from parent.\n\n---\n\n# Portals: Breaking Out of the DOM Tree\n\n## The Problem\n\nCSS constraints can limit where components render:\n\n```jsx\nfunction Parent() {\n  return (\n    <div style={{ overflow: 'hidden', position: 'relative' }}>\n      {/* This div clips overflow */}\n      <Modal />  {/* Modal gets clipped! */}\n    </div>\n  );\n}\n```\n\nModals, tooltips, and dropdowns need to escape their parent's CSS context.\n\n## The Solution: Portals\n\nPortals let you render a child into a different part of the DOM:\n\n```jsx\nimport { createPortal } from 'react-dom';\n\nfunction Modal({ children }) {\n  return createPortal(\n    <div className=\"modal\">{children}</div>,\n    document.body  // Render directly to body!\n  );\n}\n```\n\n## Portal Syntax\n\n```jsx\nimport { createPortal } from 'react-dom';\n\ncreatePortal(child, container);\n```\n\n- `child`: React element to render\n- `container`: DOM element to render into\n\n## Real-World Example: Modal\n\n**HTML:**\n```html\n<body>\n  <div id=\"root\"></div>\n  <div id=\"modal-root\"></div>  <!-- Portal target -->\n</body>\n```\n\n**Modal Component:**\n```jsx\nimport { useEffect } from 'react';\nimport { createPortal } from 'react-dom';\n\nfunction Modal({ isOpen, onClose, children }) {\n  if (!isOpen) return null;\n\n  useEffect(() => {\n    // Prevent body scroll when modal is open\n    document.body.style.overflow = 'hidden';\n    return () => {\n      document.body.style.overflow = 'unset';\n    };\n  }, []);\n\n  return createPortal(\n    <div className=\"modal-overlay\" onClick={onClose}>\n      <div className=\"modal-content\" onClick={e => e.stopPropagation()}>\n        <button className=\"close-btn\" onClick={onClose}>√ó</button>\n        {children}\n      </div>\n    </div>,\n    document.getElementById('modal-root')\n  );\n}\n\nexport default Modal;\n```\n\n**Using the Modal:**\n```jsx\nfunction App() {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setIsOpen(true)}>Open Modal</button>\n      \n      <Modal isOpen={isOpen} onClose={() => setIsOpen(false)}>\n        <h2>Modal Title</h2>\n        <p>This content is rendered in #modal-root!</p>\n      </Modal>\n    </div>\n  );\n}\n```\n\n## Why Portals Are Amazing\n\n### 1. Escape CSS Traps\n```jsx\n<div style={{ overflow: 'hidden' }}>\n  <Portal>  {/* Escapes overflow! */}\n    <Tooltip />\n  </Portal>\n</div>\n```\n\n### 2. Event Bubbling Still Works\n```jsx\nfunction App() {\n  return (\n    <div onClick={() => console.log('Parent clicked')}>\n      <Portal>\n        <button>Click me</button>\n      </Portal>\n    </div>\n  );\n}\n\n// Clicking button still logs 'Parent clicked'\n// Events bubble through React tree, not DOM!\n```\n\n### 3. Context Still Works\n```jsx\n<ThemeContext.Provider value=\"dark\">\n  <Portal>\n    <Modal />  {/* Can access ThemeContext! */}\n  </Portal>\n</ThemeContext.Provider>\n```\n\n## Common Use Cases\n\n- **Modals** - Escape parent CSS, prevent scroll\n- **Tooltips** - Position relative to viewport\n- **Dropdowns** - Escape overflow containers\n- **Toasts/Notifications** - Render in fixed position\n- **Full-screen overlays** - Cover entire page\n\n## Without a Separate DOM Node\n\n```jsx\n// Render directly to document.body\nfunction Toast({ message }) {\n  return createPortal(\n    <div className=\"toast\">{message}</div>,\n    document.body\n  );\n}\n```",
      "codeExample": "import { useState, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\n\n// Portal-based Modal\nfunction Modal({ isOpen, onClose, title, children }) {\n  if (!isOpen) return null;\n\n  useEffect(() => {\n    // Lock body scroll\n    document.body.style.overflow = 'hidden';\n    \n    // Close on Escape key\n    const handleEsc = (e) => {\n      if (e.key === 'Escape') onClose();\n    };\n    document.addEventListener('keydown', handleEsc);\n    \n    return () => {\n      document.body.style.overflow = 'unset';\n      document.removeEventListener('keydown', handleEsc);\n    };\n  }, [onClose]);\n\n  return createPortal(\n    <div\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        backgroundColor: 'rgba(0,0,0,0.5)',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        zIndex: 1000\n      }}\n      onClick={onClose}\n    >\n      <div\n        style={{\n          background: 'white',\n          padding: '20px',\n          borderRadius: '8px',\n          maxWidth: '500px',\n          width: '90%',\n          position: 'relative'\n        }}\n        onClick={e => e.stopPropagation()}\n      >\n        <button\n          onClick={onClose}\n          style={{\n            position: 'absolute',\n            top: '10px',\n            right: '10px',\n            fontSize: '20px',\n            border: 'none',\n            background: 'none',\n            cursor: 'pointer'\n          }}\n        >\n          √ó\n        </button>\n        <h2>{title}</h2>\n        {children}\n      </div>\n    </div>,\n    document.body  // Render directly to body!\n  );\n}\n\n// Portal-based Tooltip\nfunction Tooltip({ text, children }) {\n  const [show, setShow] = useState(false);\n\n  return (\n    <span\n      style={{ position: 'relative' }}\n      onMouseEnter={() => setShow(true)}\n      onMouseLeave={() => setShow(false)}\n    >\n      {children}\n      {show && createPortal(\n        <div\n          style={{\n            position: 'absolute',\n            background: 'black',\n            color: 'white',\n            padding: '5px 10px',\n            borderRadius: '4px',\n            fontSize: '14px',\n            zIndex: 1000\n          }}\n        >\n          {text}\n        </div>,\n        document.body\n      )}\n    </span>\n  );\n}\n\n// Example usage\nfunction App() {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Portals Demo</h1>\n      \n      <Tooltip text=\"This is helpful!\">\n        <span style={{ borderBottom: '1px dotted' }}>Hover me</span>\n      </Tooltip>\n      \n      <br /><br />\n      \n      <button onClick={() => setIsModalOpen(true)}>\n        Open Modal\n      </button>\n      \n      <Modal\n        isOpen={isModalOpen}\n        onClose={() => setIsModalOpen(false)}\n        title=\"Portal Modal\"\n      >\n        <p>This modal is rendered outside the React tree!</p>\n        <p>Check DevTools - it's a direct child of &lt;body&gt;</p>\n      </Modal>\n    </div>\n  );\n}"
    }
  ],
  "exercises": [
    {
      "id": "error-boundary-ex-1",
      "lessonId": "error-boundaries",
      "moduleId": "react-advanced-patterns",
      "title": "Create Error Boundary",
      "difficulty": "hard",
      "description": "Build a class component error boundary.",
      "instructions": "Create an `ErrorBoundary` class component that:\n1. Catches errors with componentDidCatch\n2. Shows fallback UI when error occurs\n3. Has a 'Try Again' button to reset\n4. Logs error to console",
      "starterCode": "import { Component } from 'react';\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    // Initialize state\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Log error\n  }\n\n  render() {\n    // Return fallback or children\n  }\n}\n\nexport default ErrorBoundary;",
      "solution": "import { Component } from 'react';\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div style={{ padding: '20px', background: '#fee' }}>\n          <h2>Something went wrong</h2>\n          <details>\n            <summary>Error details</summary>\n            <pre>{this.state.error?.toString()}</pre>\n          </details>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;",
      "hints": [
        "getDerivedStateFromError returns new state object",
        "componentDidCatch receives error and errorInfo",
        "this.props.children renders wrapped components"
      ],
      "validationPrompt": "Check if ErrorBoundary is a class component with proper error handling lifecycle methods"
    },
    {
      "id": "lazy-ex-1",
      "lessonId": "code-splitting",
      "moduleId": "react-advanced-patterns",
      "title": "Lazy Load Component",
      "difficulty": "medium",
      "description": "Implement code splitting with React.lazy.",
      "instructions": "Create a component that:\n1. Uses lazy() to import HeavyComponent\n2. Wraps it in Suspense with a loading fallback\n3. Has a button to toggle showing the component",
      "starterCode": "import { useState } from 'react';\n\nfunction App() {\n  const [show, setShow] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Hide' : 'Show'} Component\n      </button>\n      \n      {show && (\n        // Add lazy import and Suspense here\n      )}\n    </div>\n  );\n}",
      "solution": "import { useState, lazy, Suspense } from 'react';\n\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\n\nfunction App() {\n  const [show, setShow] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Hide' : 'Show'} Component\n      </button>\n      \n      {show && (\n        <Suspense fallback={<div>Loading...</div>}>\n          <HeavyComponent />\n        </Suspense>\n      )}\n    </div>\n  );\n}",
      "hints": [
        "Use lazy(() => import('./Component'))",
        "Wrap in <Suspense fallback={...}>",
        "fallback prop shows while loading"
      ],
      "validationPrompt": "Check if lazy() and Suspense are used correctly with proper fallback"
    },
    {
      "id": "portal-ex-1",
      "lessonId": "react-portals",
      "moduleId": "react-advanced-patterns",
      "title": "Create a Portal",
      "difficulty": "medium",
      "description": "Use createPortal to render outside the component tree.",
      "instructions": "Create a `Toast` component that:\n1. Uses createPortal to render to document.body\n2. Accepts message and duration props\n3. Auto-hides after duration\n4. Shows with fixed position at top-right",
      "starterCode": "import { useEffect } from 'react';\nimport { createPortal } from 'react-dom';\n\nfunction Toast({ message, duration, onClose }) {\n  useEffect(() => {\n    // Set timer to auto-hide\n  }, [duration, onClose]);\n\n  return createPortal(\n    // Toast UI here\n    document.body\n  );\n}",
      "solution": "import { useEffect } from 'react';\nimport { createPortal } from 'react-dom';\n\nfunction Toast({ message, duration, onClose }) {\n  useEffect(() => {\n    const timer = setTimeout(onClose, duration);\n    return () => clearTimeout(timer);\n  }, [duration, onClose]);\n\n  return createPortal(\n    <div\n      style={{\n        position: 'fixed',\n        top: '20px',\n        right: '20px',\n        background: '#333',\n        color: 'white',\n        padding: '15px 20px',\n        borderRadius: '4px',\n        zIndex: 1000\n      }}\n    >\n      {message}\n    </div>,\n    document.body\n  );\n}",
      "hints": [
        "createPortal takes (jsx, container)",
        "useEffect with setTimeout for auto-hide",
        "Fixed position for overlay UI"
      ],
      "validationPrompt": "Check if createPortal is used with document.body and proper styling"
    }
  ]
}
