{
  "module": {
    "id": "nodejs-modules",
    "title": "Node.js: Modules and File System",
    "description": "Master CommonJS and ES Modules, and manipulate the file system",
    "icon": "FolderTree",
    "requiredXp": 100,
    "color": "from-green-600 to-emerald-600",
    "courseId": "node-express"
  },
  "lessons": [
    {
      "id": "modules-commonjs",
      "moduleId": "nodejs-modules",
      "title": "CommonJS: require() and module.exports",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- CommonJS is the historical module system of Node.js\n- `require()` imports a module\n- `module.exports` exports functionality\n- Synchronous and executed at runtime\n\n---\n\n# The CommonJS System\n\nCommonJS (CJS) is Node.js's native module system since its creation. It's what you use when you see `require()` and `module.exports`.\n\n## Importing a Module\n\n### Node.js Built-in Modules\n```javascript\nconst fs = require('fs');\nconst path = require('path');\nconst http = require('http');\n```\n\n### Installed npm Modules\n```javascript\nconst express = require('express');\nconst lodash = require('lodash');\n```\n\n### Your Own Files\n```javascript\n// Imports ./utils.js or ./utils/index.js\nconst utils = require('./utils');\n\n// Imports specifically this file\nconst helpers = require('./helpers/math');\n\n// Imports from parent directory\nconst config = require('../config');\n```\n\n## Exporting from a Module\n\n### Export a Complete Object\n```javascript\n// math.js\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}\n\nmodule.exports = {\n  add,\n  multiply,\n  PI: 3.14159\n};\n```\n\n### Export a Single Function/Class\n```javascript\n// Logger.js\nclass Logger {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  log(message) {\n    console.log(`[${this.name}] ${message}`);\n  }\n}\n\nmodule.exports = Logger;\n```\n\nUsage:\n```javascript\nconst Logger = require('./Logger');\nconst logger = new Logger('App');\nlogger.log('Starting...');\n```\n\n## How require() Works\n\nWhen you do `require('module')`, Node.js:\n\n1. **Built-in modules**: Loads from Node.js (fs, path, http...)\n2. **Relative paths**: Resolves relative to the current file\n3. **node_modules**: Walks up the directory tree to find the package\n\n```javascript\nrequire('./local-file');     // Local file\nrequire('../parent-file');   // Parent directory\nrequire('express');          // node_modules\n```\n\n## Module Resolution\n\nFor `require('./utils')`, Node.js tries:\n1. `utils.js`\n2. `utils.json`\n3. `utils/index.js`\n4. `utils/index.json`\n5. `utils/package.json` with `main` field\n\n## Module Caching\n\nModules are cached after the first load:\n```javascript\n// Both get the same cached instance\nconst utils1 = require('./utils');\nconst utils2 = require('./utils');\nconsole.log(utils1 === utils2); // true\n```\n\n## require.resolve()\n\nFind where a module would be loaded from:\n```javascript\nconsole.log(require.resolve('express'));\n// /path/to/project/node_modules/express/index.js\n```\n\n## Best Practices\n\n1. **Use destructuring** for cleaner imports:\n   ```javascript\n   const { add, multiply } = require('./math');\n   ```\n\n2. **Export at the end** for clarity:\n   ```javascript\n   // All your code...\n   module.exports = { add, multiply };\n   ```\n\n3. **Use index.js** for clean directory imports:\n   ```javascript\n   // utils/index.js exports everything\n   const utils = require('./utils');\n   ```\n\n4. **Avoid circular dependencies** - they cause empty objects"
    },
    {
      "id": "modules-esm",
      "moduleId": "nodejs-modules",
      "title": "ES Modules: import/export",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- ES Modules (ESM) is the modern JavaScript standard\n- Uses `import` and `export` (like React/Vue)\n- Asynchronous and static (tree-shaking possible)\n- Enable with `\"type\": \"module\"` in package.json\n\n---\n\n# Why Switch to ES Modules?\n\nES Modules (ESM) are the official JavaScript standard (ES6+). They are:\n- **Universal**: same syntax frontend and backend\n- **Static**: imports are analyzed before execution (better optimizations)\n- **Tree-shakable**: bundlers can eliminate dead code\n- **Asynchronous**: allows dynamic loading\n\n## Enabling ES Modules\n\n### Option 1: package.json\n```json\n{\n  \"type\": \"module\"\n}\n```\nAll `.js` files are then treated as ESM.\n\n### Option 2: .mjs Extension\n```bash\nnode app.mjs  // Forces ESM even without \"type\": \"module\"\n```\n\n## Import/Export Syntax\n\n### Named Exports\n```javascript\n// math.js\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function multiply(a, b) {\n  return a * b;\n}\n\nexport const PI = 3.14159;\n```\n\n```javascript\n// app.js\nimport { add, multiply, PI } from './math.js';\n// Note: .js extension is required in ESM!\n\nconsole.log(add(2, 3));\n```\n\n### Default Export\n```javascript\n// Logger.js\nexport default class Logger {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  log(message) {\n    console.log(`[${this.name}] ${message}`);\n  }\n}\n```\n\n```javascript\n// app.js\nimport Logger from './Logger.js';\n// or: import MyLogger from './Logger.js'; (free naming)\n\nconst logger = new Logger('App');\n```\n\n### Imports with Aliases\n```javascript\nimport { add as addition } from './math.js';\nimport * as math from './math.js';  // Namespace import\n\nmath.add(2, 3);\nmath.multiply(4, 5);\n```\n\n## Key Differences: CommonJS vs ESM\n\n| Aspect | CommonJS | ES Modules |\n|--------|----------|------------|\n| Syntax | `require` / `module.exports` | `import` / `export` |\n| Loading | Synchronous | Asynchronous |\n| Analysis | Runtime | Static (build time) |\n| Tree-shaking | No | Yes |\n| Top-level await | No | Yes |\n| File extension | Optional | Required (usually) |\n| __dirname | Available | Not available |\n\n## Top-level await\n\nESM allows await at the module level:\n```javascript\n// config.js\nexport const config = await loadConfig();\n\n// app.js\nimport { config } from './config.js';\n// config is already loaded!\n```\n\n## Dynamic Imports\n\n```javascript\n// Load conditionally\nif (shouldLoadFeature) {\n  const { feature } = await import('./feature.js');\n  feature.run();\n}\n\n// Lazy loading\nconst heavyModule = await import('./heavy.js');\n```\n\n## __dirname in ESM\n\nESM doesn't have `__dirname`. Use this pattern:\n```javascript\nimport { fileURLToPath } from 'url';\nimport { dirname } from 'path';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n```\n\n## Mixing CommonJS and ESM\n\nYou can import CJS from ESM:\n```javascript\n// ESM file importing CJS\nimport lodash from 'lodash';  // Works!\n```\n\nBut not ESM from CJS easily:\n```javascript\n// CJS file trying to import ESM\nconst esm = await import('esm-package');  // Dynamic import only\n```\n\n## Recommendation\n\n**Use ES Modules for all new projects.** It's the future of JavaScript and works consistently across frontend and backend."
    },
    {
      "id": "nodejs-fs-sync",
      "moduleId": "nodejs-modules",
      "title": "File System: Synchronous Operations",
      "order": 3,
      "difficulty": "beginner",
      "content": "# Essential to know\n- `fs` module for File System (reading/writing files)\n- Synchronous methods (Sync) block the thread\n- Avoid in production except at startup\n- Useful for scripts and configuration\n\n---\n\n# The fs Module (File System)\n\nNode.js can read and write files via the `fs` module. This is essential for:\n- Reading configuration files\n- Saving logs\n- Handling uploads\n- Generating reports\n\n## Synchronous Methods (Avoid in Production)\n\nThe `*Sync` methods block the event loop until the operation completes.\n\n### Reading a File\n```javascript\nimport { readFileSync } from 'fs';\n\n// Read as UTF-8 (text)\nconst content = readFileSync('./data.txt', 'utf-8');\nconsole.log(content);\n\n// Read as Buffer (binary)\nconst buffer = readFileSync('./image.png');\nconsole.log(buffer.length);  // Size in bytes\n```\n\n### Writing a File\n```javascript\nimport { writeFileSync } from 'fs';\n\n// Overwrites file if it exists\nwriteFileSync('./output.txt', 'Hello World!');\n\n// Append to end\nimport { appendFileSync } from 'fs';\nappendFileSync('./log.txt', 'New line\\n');\n```\n\n### Directory Operations\n```javascript\nimport { mkdirSync, readdirSync, rmdirSync, existsSync } from 'fs';\n\n// Create directory\nmkdirSync('./uploads');\nmkdirSync('./nested/folder', { recursive: true });  // Creates parents if needed\n\n// List contents\nconst files = readdirSync('./');\nconsole.log(files);  // ['package.json', 'src', 'node_modules', ...]\n\n// Check existence\nif (existsSync('./config.json')) {\n  const config = readFileSync('./config.json', 'utf-8');\n}\n\n// Remove empty directory\nrmdirSync('./empty-folder');\n```\n\n### File Information\n```javascript\nimport { statSync } from 'fs';\n\nconst stats = statSync('./package.json');\n\nconsole.log(stats.isFile());       // true\nconsole.log(stats.isDirectory());  // false\nconsole.log(stats.size);           // Size in bytes\nconsole.log(stats.birthtime);      // Creation date\nconsole.log(stats.mtime);          // Modification date\n```\n\n## When to Use Sync Methods\n\nAcceptable use cases for Sync methods:\n\n**Startup only**:\n```javascript\n// Load configuration at boot (once)\nconst config = JSON.parse(readFileSync('./config.json', 'utf-8'));\n```\n\n**CLI scripts**:\n```javascript\n// Build script\nconst template = readFileSync('./template.html', 'utf-8');\n```\n\n**Never during request handling**:\n```javascript\n// HORROR - blocks all other users!\napp.get('/file', (req, res) => {\n  const data = readFileSync('./huge-file.zip');  // Wrong\n  res.send(data);\n});\n```"
    },
    {
      "id": "nodejs-fs-async",
      "moduleId": "nodejs-modules",
      "title": "File System: Asynchronous Operations",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Always use `fs/promises` for asynchronous code\n- `async/await` makes code readable\n- Callbacks are obsolete (callback hell)\n- Non-blocking = better performance\n\n---\n\n# fs/promises: The Modern Approach\n\nThe `fs/promises` submodule provides Promise-based file operations. This is the recommended method for all asynchronous operations.\n\n## async/await Syntax\n\n```javascript\nimport { readFile, writeFile, mkdir, readdir } from 'fs/promises';\n\nasync function processFiles() {\n  try {\n    // Read file\n    const data = await readFile('./data.json', 'utf-8');\n    const config = JSON.parse(data);\n    \n    // Modify\n    config.version = '2.0.0';\n    \n    // Write\n    await writeFile('./data.json', JSON.stringify(config, null, 2));\n    \n    console.log('File updated!');\n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}\n\nprocessFiles();\n```\n\n## Common Operations\n\n### Reading Multiple Files\n```javascript\nimport { readFile } from 'fs/promises';\n\nasync function loadTranslations() {\n  const [en, fr, es] = await Promise.all([\n    readFile('./locales/en.json', 'utf-8'),\n    readFile('./locales/fr.json', 'utf-8'),\n    readFile('./locales/es.json', 'utf-8')\n  ]);\n  \n  return {\n    en: JSON.parse(en),\n    fr: JSON.parse(fr),\n    es: JSON.parse(es)\n  };\n}\n```\n\n### Directory Management\n```javascript\nimport { mkdir, readdir, rmdir, stat } from 'fs/promises';\n\nasync function setupProject() {\n  // Create structure\n  await mkdir('./project/src/components', { recursive: true });\n  await mkdir('./project/src/utils', { recursive: true });\n  await mkdir('./project/public', { recursive: true });\n  \n  // List with details\n  const files = await readdir('./project', { withFileTypes: true });\n  \n  for (const file of files) {\n    console.log(\n      file.isDirectory() ? '[D]' : '[F]',\n      file.name\n    );\n  }\n}\n```\n\n### File Watching\n```javascript\nimport { watch } from 'fs/promises';\n\nasync function watchFile(filePath) {\n  const watcher = watch(filePath);\n  \n  for await (const event of watcher) {\n    console.log(`File ${event.eventType}: ${event.filename}`);\n  }\n}\n\nwatchFile('./config.json');\n```\n\n## Stream-based File Operations\n\nFor large files, use streams:\n```javascript\nimport { createReadStream, createWriteStream } from 'fs';\nimport { pipeline } from 'stream/promises';\n\nasync function copyLargeFile(src, dest) {\n  await pipeline(\n    createReadStream(src),\n    createWriteStream(dest)\n  );\n}\n```\n\n## Error Handling\n\n```javascript\nasync function safeRead(path) {\n  try {\n    return await readFile(path, 'utf-8');\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      console.log('File not found');\n      return null;\n    }\n    throw error;  // Re-throw unexpected errors\n  }\n}\n```\n\n## Common Error Codes\n\n| Code | Meaning |\n|------|---------|\n| ENOENT | File/directory doesn't exist |\n| EACCES | Permission denied |\n| EISDIR | Is a directory (expected file) |\n| ENOTDIR | Not a directory (expected dir) |\n| EEXIST | File already exists |\n\n## Best Practices\n\n1. **Always use fs/promises** for async operations\n2. **Handle errors** properly with try/catch\n3. **Use recursive: true** for directory creation\n4. **Check exists** before operations if needed\n5. **Use streams** for large files (>10MB)\n6. **Set proper encoding** (utf-8 for text, none for binary)"
    },
    {
      "id": "nodejs-path",
      "moduleId": "nodejs-modules",
      "title": "The path Module: File Paths",
      "order": 5,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- `path` allows cross-platform path manipulation\n- Windows uses `\\`, macOS/Linux use `/`\n- `path.join()` builds safe paths\n- `path.resolve()` gives absolute paths\n\n---\n\n# Why Use the path Module?\n\nFile paths differ across operating systems:\n- **Windows**: `C:\\Users\\John\\project\\file.txt`\n- **macOS/Linux**: `/Users/John/project/file.txt`\n\nIf you manually concatenate with `/` or `\\`, your code won't work everywhere!\n\n## Building Paths\n\n### path.join()\nConcatenates segments with the correct separator:\n```javascript\nimport { join } from 'path';\n\n// Works on all platforms\nconst filePath = join('src', 'components', 'Button.js');\n// Windows: src\\components\\Button.js\n// Unix: src/components/Button.js\n\n// Ignores extra slashes\njoin('/foo', 'bar', '../baz');  // /foo/baz\n```\n\n### path.resolve()\nGives absolute path from current directory:\n```javascript\nimport { resolve } from 'path';\n\nresolve('src', 'index.js');\n// /Users/john/project/src/index.js\n\n// Relative to specific directory\nresolve(__dirname, '../config.json');\n```\n\n## Path Information\n\n```javascript\nimport { parse, basename, dirname, extname } from 'path';\n\nconst filePath = '/home/user/project/src/app.js';\n\n// Parse path\nparse(filePath);\n// {\n//   root: '/',\n//   dir: '/home/user/project/src',\n//   base: 'app.js',\n//   ext: '.js',\n//   name: 'app'\n// }\n\n// Extract parts\nbasename(filePath);     // 'app.js'\nbasename(filePath, '.js');  // 'app'\ndirname(filePath);      // '/home/user/project/src'\nextname(filePath);      // '.js'\n```\n\n## Relative vs Absolute Paths\n\n```javascript\nimport { isAbsolute, relative } from 'path';\n\nisAbsolute('/home/user');     // true (Unix)\nisAbsolute('C:\\Users');       // true (Windows)\nisAbsolute('./file.txt');     // false\n\n// Get relative path\nrelative('/home/user/project', '/home/user/project/src/app.js');\n// 'src/app.js'\n```\n\n## __dirname Equivalent in ESM\n\n```javascript\nimport { join, dirname } from 'path';\nimport { fileURLToPath } from 'url';\n\n// Get __dirname in ESM\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// Build robust paths\nconst paths = {\n  root: join(__dirname, '..'),\n  src: join(__dirname, '../src'),\n  public: join(__dirname, '../public'),\n  uploads: join(__dirname, '../uploads'),\n  config: join(__dirname, '../config.json')\n};\n\n// Usage\nimport { readFile } from 'fs/promises';\nconst config = await readFile(paths.config, 'utf-8');\n```\n\n## Normalization\n\n```javascript\nimport { normalize } from 'path';\n\n// Clean up paths with // or ..\nnormalize('/foo/bar//baz/asdf/quux/..');\n// '/foo/bar/baz/asdf'\n```\n\n## path.sep\n\nAccess the current platform's separator:\n\n```javascript\nimport { sep } from 'path';\n\nconsole.log(sep);  // '/' on Unix, '\\\\' on Windows\n\n// Rarely needed since path.join() handles everything\n```\n\n## Best Practices\n\n1. **Always use path.join()** instead of string concatenation\n2. **Use path.resolve()** for absolute paths\n3. **Check isAbsolute()** when unsure\n4. **Use parse()** to extract filename/extension\n5. **Create a paths config** for your project\n6. **Handle __dirname** properly in ESM"
    }
  ],
  "exercises": []
}
