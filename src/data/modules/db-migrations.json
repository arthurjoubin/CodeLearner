{
  "module": {
    "id": "db-migrations",
    "title": "Database Migrations",
    "description": "Version control for your database: safely evolve your schema over time with migrations",
    "icon": "GitBranch",
    "requiredXp": 600,
    "color": "from-indigo-500 to-purple-600",
    "courseId": "databases"
  },
  "lessons": [
    {
      "id": "migration-basics",
      "moduleId": "db-migrations",
      "title": "Why Migrations?",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Migrations = version control for your database schema\n- Each migration is a file with \"up\" (apply) and \"down\" (rollback)\n- Never edit old migrations - create new ones\n- Run migrations in order on all environments\n\n---\n\n# Why Database Migrations?\n\n## The Problem Without Migrations\n\nImagine you're building an app with a team:\n\n**Developer A** adds a `users` table:\n```sql\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  email TEXT\n);\n```\n\n**Developer B** pulls the code and... their database doesn't have the table. They get errors.\n\n**In production**, you manually run SQL commands. But which ones? In what order? What if you make a mistake?\n\n**Result:** Database chaos.\n\n## The Solution: Migrations\n\nMigrations are **versioned scripts** that modify your database:\n\n```\nmigrations/\n  001_create_users.sql       ← First migration\n  002_add_username.sql       ← Second migration  \n  003_add_posts_table.sql    ← Third migration\n```\n\n**Each migration has:**\n1. **Up**: Apply the change\n2. **Down**: Undo the change\n\n```sql\n-- 002_add_username.sql\n\n-- Up: Add username column\nALTER TABLE users ADD COLUMN username TEXT;\n\n-- Down: Remove username column\nALTER TABLE users DROP COLUMN username;\n```\n\n## How Migrations Work\n\n1. **Track which migrations ran**: Database has a `migrations` table\n   ```sql\n   CREATE TABLE migrations (\n     id INTEGER PRIMARY KEY,\n     name TEXT,\n     applied_at TIMESTAMP\n   );\n   ```\n\n2. **Run pending migrations**: Tool checks which migrations haven't run yet\n   ```bash\n   # You: Run migrations\n   npm run migrate\n   \n   # Tool: Checks migrations table\n   # Already ran: 001_create_users.sql\n   # Pending: 002_add_username.sql, 003_add_posts_table.sql\n   # Runs pending migrations in order\n   ```\n\n3. **Record completion**: After each migration, record it\n   ```sql\n   INSERT INTO migrations (name, applied_at)\n   VALUES ('002_add_username.sql', NOW());\n   ```\n\n## Benefits\n\n### 1. Reproducible\nEvery developer runs the same migrations → same schema\n\n```bash\n# Developer A\ngit pull\nnpm run migrate  # Gets latest schema\n\n# Developer B  \ngit pull\nnpm run migrate  # Gets same schema\n\n# Production\ngit pull\nnpm run migrate  # Gets same schema\n```\n\n### 2. Versioned\nSchema changes are tracked in git alongside code\n\n```bash\ngit log migrations/\n# commit abc123: Add posts table\n# commit def456: Add username to users\n# commit ghi789: Create users table\n```\n\n### 3. Reversible\nRollback if something goes wrong\n\n```bash\n# Oh no, bad migration!\nnpm run migrate:rollback  # Undo last migration\n```\n\n### 4. Safe in Production\nNo manual SQL execution → fewer mistakes\n\n```bash\n# Bad: Manual SQL in production\n# You: Types SQL from memory, makes typo, breaks production\n\n# Good: Automated migrations\n# You: npm run migrate\n# Tool: Runs tested migrations exactly as written\n```\n\n## Migration Workflow\n\n### Development\n```bash\n# 1. Create migration\nnpm run migrate:create add_avatar_to_users\n# Creates: migrations/004_add_avatar_to_users.sql\n\n# 2. Write up/down SQL\n# Edit the file\n\n# 3. Run migration\nnpm run migrate\n\n# 4. Test it works\n# Check your app\n\n# 5. Commit to git\ngit add migrations/004_add_avatar_to_users.sql\ngit commit -m \"Add avatar column to users\"\n```\n\n### Team Member Pulls Changes\n```bash\ngit pull\nnpm run migrate  # Automatically runs new migration\n```\n\n### Deploy to Production\n```bash\ngit pull\nnpm run migrate  # Runs pending migrations\nnpm start        # Start app with new schema\n```\n\n## Common Migration Patterns\n\n### Add Column\n```sql\n-- Up\nALTER TABLE users ADD COLUMN avatar TEXT;\n\n-- Down\nALTER TABLE users DROP COLUMN avatar;\n```\n\n### Add Table\n```sql\n-- Up\nCREATE TABLE posts (\n  id INTEGER PRIMARY KEY,\n  user_id INTEGER REFERENCES users(id),\n  title TEXT,\n  content TEXT\n);\n\n-- Down\nDROP TABLE posts;\n```\n\n### Rename Column\n```sql\n-- Up\nALTER TABLE users RENAME COLUMN email TO email_address;\n\n-- Down  \nALTER TABLE users RENAME COLUMN email_address TO email;\n```\n\n### Add Index\n```sql\n-- Up\nCREATE INDEX idx_users_email ON users(email);\n\n-- Down\nDROP INDEX idx_users_email;\n```\n\n## Migration Tools\n\n### Node.js Tools\n- **Knex.js**: Migrations + query builder\n- **Prisma Migrate**: Migrations for Prisma ORM\n- **Sequelize**: Migrations for Sequelize ORM\n- **node-pg-migrate**: PostgreSQL migrations\n\n### Example: Knex Migration\n```javascript\n// migrations/20240101_create_users.js\nexports.up = function(knex) {\n  return knex.schema.createTable('users', table => {\n    table.increments('id').primary();\n    table.string('email').notNullable().unique();\n    table.timestamps(true, true);\n  });\n};\n\nexports.down = function(knex) {\n  return knex.schema.dropTable('users');\n};\n```\n\n## Quick Reference\n\n```bash\n# Create migration\nnpm run migrate:create <name>\n\n# Run pending migrations\nnpm run migrate\n\n# Rollback last migration\nnpm run migrate:rollback\n\n# Check migration status\nnpm run migrate:status\n```\n\n**Remember:**\n- ✅ Migrations are version control for your database\n- ✅ Always write both up and down\n- ✅ Run migrations in all environments (dev, staging, prod)\n- ✅ Commit migrations to git with your code\n- ✅ Never edit old migrations - create new ones\n- ❌ Don't run SQL manually in production\n- ❌ Don't skip migrations or run them out of order"
    },
    {
      "id": "creating-migrations",
      "moduleId": "db-migrations",
      "title": "Creating Migrations",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Migration files have timestamps in names (20240101_create_users.sql)\n- Write both up (apply) and down (rollback) for every migration\n- Test migrations locally before deploying\n- Keep migrations small and focused\n\n---\n\n# Creating Migrations\n\n## Migration File Structure\n\n### Naming Convention\n\n```\nTimestamp + Description\n\n20240101120000_create_users_table.sql\n└─────┬─────┘ └──────────┬─────────┘\n   Timestamp          Description\n   (YYYYMMDDHHMMSS)\n```\n\n**Why timestamps?**\n- Ensures migrations run in order\n- Avoids conflicts when multiple developers create migrations\n- Shows when migration was created\n\n### File Format\n\n```sql\n-- Migration: Add avatar column to users\n-- Created: 2024-01-15\n\n-- Up Migration\nALTER TABLE users ADD COLUMN avatar TEXT;\n\n-- Down Migration  \nALTER TABLE users DROP COLUMN avatar;\n```\n\n## Writing Good Migrations\n\n### Principle 1: Small and Focused\n\n```sql\n-- ❌ BAD: Multiple unrelated changes\nALTER TABLE users ADD COLUMN avatar TEXT;\nCREATE TABLE posts (...);\nALTER TABLE comments ADD COLUMN likes INTEGER;\n\n-- ✅ GOOD: One migration per change\n-- 001_add_avatar_to_users.sql\nALTER TABLE users ADD COLUMN avatar TEXT;\n\n-- 002_create_posts_table.sql  \nCREATE TABLE posts (...);\n\n-- 003_add_likes_to_comments.sql\nALTER TABLE comments ADD COLUMN likes INTEGER;\n```\n\n### Principle 2: Always Reversible\n\n```sql\n-- ✅ GOOD: Can undo\n-- Up\nALTER TABLE users ADD COLUMN bio TEXT;\n-- Down\nALTER TABLE users DROP COLUMN bio;\n\n-- ❌ BAD: Irreversible data loss\n-- Up\nDROP TABLE old_users;\n-- Down\n-- Can't recreate data that was deleted!\n```\n\n### Principle 3: Safe for Production\n\n```sql\n-- ❌ DANGEROUS: Drops column immediately\nALTER TABLE users DROP COLUMN old_field;\n-- If app code still uses old_field, it breaks!\n\n-- ✅ SAFE: Multi-step migration\n-- Step 1: Make column nullable (app still works)\nALTER TABLE users ALTER COLUMN old_field DROP NOT NULL;\n\n-- Deploy new code that doesn't use old_field\n\n-- Step 2: Drop column (safe now)\nALTER TABLE users DROP COLUMN old_field;\n```\n\n## Common Migration Patterns\n\n### Add Column with Default\n\n```sql\n-- Up\nALTER TABLE users \n  ADD COLUMN status TEXT DEFAULT 'active' NOT NULL;\n\n-- Down\nALTER TABLE users DROP COLUMN status;\n```\n\n### Rename Column (Safe)\n\n```sql\n-- PostgreSQL\nALTER TABLE users \n  RENAME COLUMN email TO email_address;\n\n-- SQLite (doesn't support RENAME COLUMN directly)\n-- Create new column, copy data, drop old\nALTER TABLE users ADD COLUMN email_address TEXT;\nUPDATE users SET email_address = email;\nALTER TABLE users DROP COLUMN email;\n```\n\n### Change Column Type\n\n```sql\n-- PostgreSQL\nALTER TABLE users \n  ALTER COLUMN age TYPE INTEGER USING age::INTEGER;\n\n-- SQLite (recreate table)\nCREATE TABLE users_new (\n  id INTEGER PRIMARY KEY,\n  age INTEGER  -- Changed from TEXT to INTEGER\n);\nINSERT INTO users_new SELECT id, CAST(age AS INTEGER) FROM users;\nDROP TABLE users;\nALTER TABLE users_new RENAME TO users;\n```\n\n### Add Foreign Key\n\n```sql\n-- Up\nALTER TABLE posts \n  ADD CONSTRAINT fk_posts_user_id \n  FOREIGN KEY (user_id) REFERENCES users(id)\n  ON DELETE CASCADE;\n\n-- Down\nALTER TABLE posts \n  DROP CONSTRAINT fk_posts_user_id;\n```\n\n### Add Index\n\n```sql\n-- Up\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_posts_user_id ON posts(user_id);\n\n-- Down\nDROP INDEX idx_users_email;\nDROP INDEX idx_posts_user_id;\n```\n\n### Seed Data\n\n```sql\n-- Up\nINSERT INTO roles (name) VALUES \n  ('admin'),\n  ('moderator'),\n  ('user');\n\n-- Down\nDELETE FROM roles WHERE name IN ('admin', 'moderator', 'user');\n```\n\n## Data Migrations\n\nSometimes you need to transform data:\n\n```sql\n-- Split full_name into first_name + last_name\n\n-- Up\n-- 1. Add new columns\nALTER TABLE users ADD COLUMN first_name TEXT;\nALTER TABLE users ADD COLUMN last_name TEXT;\n\n-- 2. Migrate data\nUPDATE users \nSET \n  first_name = SPLIT_PART(full_name, ' ', 1),\n  last_name = SPLIT_PART(full_name, ' ', 2)\nWHERE full_name IS NOT NULL;\n\n-- 3. Drop old column (in separate migration!)\n-- WAIT until app code updated first\n\n-- Down\nALTER TABLE users DROP COLUMN first_name;\nALTER TABLE users DROP COLUMN last_name;\n```\n\n## Migration with Knex.js\n\n### Create Migration\n\n```bash\nnpx knex migrate:make create_users_table\n# Creates: migrations/20240115120000_create_users_table.js\n```\n\n### Write Migration\n\n```javascript\n// migrations/20240115120000_create_users_table.js\n\nexports.up = async function(knex) {\n  await knex.schema.createTable('users', table => {\n    table.increments('id').primary();\n    table.string('email', 255).notNullable().unique();\n    table.string('username', 50).notNullable().unique();\n    table.text('bio').nullable();\n    table.timestamps(true, true); // created_at, updated_at\n  });\n};\n\nexports.down = async function(knex) {\n  await knex.schema.dropTable('users');\n};\n```\n\n### Run Migrations\n\n```bash\n# Run all pending migrations\nnpx knex migrate:latest\n\n# Rollback last batch\nnpx knex migrate:rollback\n\n# Check status\nnpx knex migrate:status\n```\n\n## Migration with Prisma\n\n### Create Migration\n\n```bash\n# 1. Edit schema.prisma\nmodel User {\n  id       Int    @id @default(autoincrement())\n  email    String @unique\n  username String @unique\n  bio      String?\n}\n\n# 2. Create migration\nnpx prisma migrate dev --name create_users_table\n# Generates SQL migration file automatically\n```\n\n### Migration File (Generated)\n\n```sql\n-- migrations/20240115120000_create_users_table/migration.sql\nCREATE TABLE \"User\" (\n    \"id\" SERIAL PRIMARY KEY,\n    \"email\" TEXT NOT NULL UNIQUE,\n    \"username\" TEXT NOT NULL UNIQUE,\n    \"bio\" TEXT\n);\n```\n\n## Testing Migrations\n\n### Before Committing\n\n```bash\n# 1. Run migration up\nnpm run migrate\n\n# 2. Check schema\npsql -d myapp -c \"\\d users\"\n\n# 3. Test app still works\nnpm run dev\n\n# 4. Test rollback\nnpm run migrate:rollback\n\n# 5. Check schema reverted\npsql -d myapp -c \"\\d users\"  # Column should be gone\n\n# 6. Re-apply\nnpm run migrate\n\n# 7. Commit if all good\ngit add migrations/\ngit commit -m \"Add avatar column to users\"\n```\n\n## Quick Reference\n\n```bash\n# Knex\nnpx knex migrate:make <name>    # Create\nnpx knex migrate:latest          # Run\nnpx knex migrate:rollback        # Undo\nnpx knex migrate:status          # Check\n\n# Prisma\nnpx prisma migrate dev --name <name>  # Create & run\nnpx prisma migrate deploy             # Production\nnpx prisma migrate status             # Check\n```\n\n**Remember:**\n- ✅ Small, focused migrations\n- ✅ Always write down migration\n- ✅ Test locally before deploying\n- ✅ Use timestamps in filenames\n- ✅ Keep data transformations separate\n- ❌ Don't edit old migrations\n- ❌ Don't combine unrelated changes\n- ❌ Don't drop data without backup"
    },
    {
      "id": "migration-best-practices",
      "moduleId": "db-migrations",
      "title": "Migration Best Practices",
      "order": 3,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Never edit migrations after they've run in production\n- Breaking changes need multi-step deployments\n- Always backup before running migrations in production\n- Test migrations on a copy of production data\n\n---\n\n# Migration Best Practices\n\n## Golden Rule: Never Edit Merged Migrations\n\nOnce a migration has run in any shared environment (production, staging, or even other developers' machines), **never edit it**.\n\n```bash\n# ❌ BAD\ngit commit migrations/001_create_users.sql\ngit push\n# Team runs migration\n# You: \"Oops, I forgot a column\"\n# You: Edit 001_create_users.sql and push again\n# Team: Migration already ran, won't re-run, inconsistent schemas!\n\n# ✅ GOOD\ngit commit migrations/001_create_users.sql\ngit push\n# Team runs migration\n# You: \"Oops, I forgot a column\"\n# You: Create 002_add_missing_column.sql\n# Team: Runs new migration, everyone has same schema\n```\n\n## Safe Schema Changes in Production\n\n### The Problem: Breaking Changes\n\n```sql\n-- This migration will break production!\nALTER TABLE users DROP COLUMN old_field;\n-- Running app still uses old_field → crashes!\n```\n\n### Solution: Multi-Step Deployments\n\n**Step 1: Make column optional (additive change)**\n```sql\n-- Migration 001: Make field nullable\nALTER TABLE users ALTER COLUMN old_field DROP NOT NULL;\n```\n```bash\n# Deploy migration (app still works)\nnpm run migrate\n```\n\n**Step 2: Update code to not use column**\n```javascript\n// Remove all references to old_field\n// const value = user.old_field; ❌ Remove this\n```\n```bash\n# Deploy code (app doesn't use old_field anymore)\ngit push\n```\n\n**Step 3: Drop column (safe now)**\n```sql\n-- Migration 002: Drop unused column\nALTER TABLE users DROP COLUMN old_field;\n```\n```bash\n# Deploy migration (safe, nothing uses it)\nnpm run migrate\n```\n\n### Expand-Contract Pattern\n\n**Expand**: Add new schema\n**Overlap**: Support both old and new\n**Contract**: Remove old schema\n\n```sql\n-- Example: Rename email → email_address\n\n-- EXPAND: Add new column\nALTER TABLE users ADD COLUMN email_address TEXT;\nUPDATE users SET email_address = email;\n-- Now both columns exist\n\n-- OVERLAP: Update code to write to both\nINSERT INTO users (email, email_address) VALUES (?, ?);\n-- Deploy this code\n\n-- OVERLAP: Update code to read from new column\nSELECT email_address FROM users;\n-- Deploy this code\n\n-- CONTRACT: Drop old column\nALTER TABLE users DROP COLUMN email;\n-- Deploy final migration\n```\n\n## Production Migration Checklist\n\n### Before Running\n\n- [ ] Backup database\n  ```bash\n  pg_dump myapp > backup-$(date +%Y%m%d).sql\n  ```\n\n- [ ] Test on production copy\n  ```bash\n  # Restore production data to staging\n  pg_restore backup.sql -d staging\n  # Run migration on staging\n  npm run migrate\n  # Test app on staging\n  ```\n\n- [ ] Review migration SQL\n  ```bash\n  cat migrations/latest.sql\n  # Does it look safe?\n  # Any DROP commands?\n  # Any data transformations?\n  ```\n\n- [ ] Estimate downtime\n  ```sql\n  -- Large table alteration might lock table\n  -- Check table size first:\n  SELECT pg_size_pretty(pg_total_relation_size('users'));\n  ```\n\n- [ ] Plan rollback\n  ```bash\n  # Know how to undo if needed\n  npm run migrate:rollback\n  # Or restore from backup\n  psql myapp < backup.sql\n  ```\n\n### During Migration\n\n```bash\n# 1. Enable maintenance mode (optional)\n# Prevent writes during migration\n\n# 2. Run migration\nnpm run migrate\n\n# 3. Verify it worked\npsql -d myapp -c \"SELECT * FROM migrations ORDER BY id DESC LIMIT 1;\"\n\n# 4. Test app\ncurl http://localhost:3000/health\n\n# 5. Disable maintenance mode\n```\n\n### After Migration\n\n- [ ] Monitor errors\n  ```bash\n  tail -f logs/error.log\n  ```\n\n- [ ] Check performance\n  ```sql\n  -- Did indexes get created?\n  SELECT * FROM pg_indexes WHERE tablename = 'users';\n  ```\n\n- [ ] Keep backup for 7 days\n  ```bash\n  # Don't delete backup immediately!\n  ```\n\n## Handling Large Tables\n\n### Problem: Table Locking\n\n```sql\n-- This locks the entire table!\nALTER TABLE huge_table ADD COLUMN new_field TEXT;\n-- Millions of rows = minutes of downtime\n```\n\n### Solution 1: Add Column with No Default\n\n```sql\n-- Fast: doesn't rewrite table\nALTER TABLE huge_table ADD COLUMN new_field TEXT;\n\n-- Then backfill in batches\nUPDATE huge_table SET new_field = 'default' WHERE id BETWEEN 1 AND 10000;\nUPDATE huge_table SET new_field = 'default' WHERE id BETWEEN 10001 AND 20000;\n-- etc.\n```\n\n### Solution 2: Create Index Concurrently (PostgreSQL)\n\n```sql\n-- Regular: locks table\nCREATE INDEX idx_users_email ON users(email);\n\n-- Concurrent: doesn't lock, takes longer\nCREATE INDEX CONCURRENTLY idx_users_email ON users(email);\n```\n\n### Solution 3: Online Schema Change Tools\n\n- **pt-online-schema-change** (MySQL)\n- **pg-osc** (PostgreSQL)\n- Creates shadow table, copies data, swaps\n\n## Migration Conflicts\n\n### Problem: Two Developers, Same Timestamp\n\n```\nDeveloper A creates: 20240115120000_add_avatar.sql\nDeveloper B creates: 20240115120000_add_bio.sql\n```\n\n### Solution: Rebase and Rename\n\n```bash\n# Developer B:\ngit pull\n# Sees A's migration already exists\n\n# Rename migration with new timestamp\nmv migrations/20240115120000_add_bio.sql \\\n   migrations/20240115120001_add_bio.sql\n\ngit add migrations/\ngit commit\n```\n\n## Migration Monitoring\n\n### Track Migration Duration\n\n```javascript\n// migrations/utils.js\nexport async function migrate(knex, up) {\n  const start = Date.now();\n  await up(knex);\n  const duration = Date.now() - start;\n  \n  console.log(`Migration completed in ${duration}ms`);\n  \n  // Alert if slow\n  if (duration > 60000) {\n    console.warn('⚠️  Migration took over 1 minute!');\n  }\n}\n```\n\n### Log Migration Errors\n\n```javascript\ntry {\n  await knex.migrate.latest();\n} catch (error) {\n  console.error('Migration failed:', error);\n  \n  // Send to error tracking\n  Sentry.captureException(error);\n  \n  // Rollback\n  await knex.migrate.rollback();\n  \n  throw error;\n}\n```\n\n## Common Mistakes\n\n### 1. Forgetting Foreign Keys\n\n```sql\n-- ❌ BAD: No foreign key\nCREATE TABLE posts (\n  user_id INTEGER\n);\n-- Can insert invalid user_id!\n\n-- ✅ GOOD: Foreign key enforced\nCREATE TABLE posts (\n  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE\n);\n```\n\n### 2. Missing Indexes\n\n```sql\n-- ❌ BAD: No index on foreign key\nALTER TABLE posts ADD COLUMN user_id INTEGER REFERENCES users(id);\n-- Queries like SELECT * FROM posts WHERE user_id = 1 are slow!\n\n-- ✅ GOOD: Add index\nALTER TABLE posts ADD COLUMN user_id INTEGER REFERENCES users(id);\nCREATE INDEX idx_posts_user_id ON posts(user_id);\n```\n\n### 3. Irreversible Migrations\n\n```sql\n-- ❌ BAD: Can't undo\nDROP TABLE old_data;\n-- Data is gone forever!\n\n-- ✅ GOOD: Rename first, drop later\nALTER TABLE old_data RENAME TO old_data_backup;\n-- Keep for 30 days, then drop in new migration\n```\n\n## Quick Reference\n\n**Multi-step deployment:**\n1. Make additive change (add column)\n2. Deploy code using new column\n3. Make destructive change (drop old column)\n\n**Production checklist:**\n- ✅ Backup database\n- ✅ Test on staging\n- ✅ Review SQL\n- ✅ Plan rollback\n- ✅ Monitor after deploy\n\n**Large tables:**\n- ✅ Add columns without defaults\n- ✅ Create indexes CONCURRENTLY\n- ✅ Backfill in batches\n\n**Remember:**\n- ✅ Never edit merged migrations\n- ✅ Multi-step for breaking changes\n- ✅ Always backup before production migrations\n- ✅ Test on production data copy\n- ❌ Don't lock tables unnecessarily\n- ❌ Don't skip testing\n- ❌ Don't drop data without backup"
    }
  ],
  "exercises": []
}
