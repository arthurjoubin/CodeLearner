{
  "module": {
    "id": "js-api-consumption",
    "courseId": "javascript-core",
    "title": "API Consumption with JavaScript",
    "description": "Master fetching data from APIs using fetch, handling JSON, HTTP methods, authentication, and error handling",
    "icon": "Globe",
    "requiredXp": 500,
    "color": "from-indigo-500 to-purple-600"
  },
  "lessons": [
    {
      "id": "fetch-api-basics",
      "moduleId": "js-api-consumption",
      "title": "The Fetch API",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- fetch() is the modern way to make HTTP requests in JavaScript\n- Returns a Promise that resolves to a Response object\n- Use async/await for cleaner asynchronous code\n- GET is the default HTTP method for fetching data\n\n---\n\n# The Fetch API\n\n## What is fetch()?\n\nThe fetch() API is a modern, promise-based way to make HTTP requests in the browser (and Node.js 18+). It replaces the older XMLHttpRequest.\n\n```javascript\n// Basic GET request\nfetch('https://api.example.com/users')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Error:', error));\n```\n\n## Using async/await\n\nModern JavaScript prefers async/await syntax:\n\n```javascript\nasync function getUsers() {\n  try {\n    const response = await fetch('https://api.example.com/users');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Failed to fetch users:', error);\n  }\n}\n```\n\n## The Response Object\n\nfetch() returns a Response object with useful properties:\n\n```javascript\nconst response = await fetch('https://api.example.com/users');\n\n// Check if request was successful\nconsole.log(response.ok);        // true if status 200-299\nconsole.log(response.status);    // HTTP status code (200, 404, etc.)\nconsole.log(response.statusText);// \"OK\", \"Not Found\", etc.\nconsole.log(response.headers);   // Response headers\n\n// Parse response body\nconst json = await response.json();      // Parse as JSON\nconst text = await response.text();      // Parse as text\nconst blob = await response.blob();      // Parse as Blob (images, files)\n```\n\n## Common Patterns\n\n**GET with query parameters:**\n```javascript\nconst params = new URLSearchParams({\n  page: '1',\n  limit: '10',\n  search: 'javascript'\n});\n\nconst response = await fetch(`https://api.example.com/users?${params}`);\nconst data = await response.json();\n```\n\n**Reusable fetch wrapper:**\n```javascript\nasync function fetchAPI(endpoint) {\n  const response = await fetch(`https://api.example.com${endpoint}`);\n  \n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  \n  return response.json();\n}\n\n// Usage\nconst users = await fetchAPI('/users');\nconst posts = await fetchAPI('/posts');\n```",
      "codeExample": "// Basic fetch example\nasync function fetchUsers() {\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/users');\n    \n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    \n    const users = await response.json();\n    console.log('Users:', users);\n    return users;\n  } catch (error) {\n    console.error('Fetch failed:', error.message);\n  }\n}\n\n// With query parameters\nasync function searchPosts(query) {\n  const params = new URLSearchParams({ q: query });\n  const response = await fetch(`https://api.example.com/posts?${params}`);\n  return response.json();\n}\n\n// Reusable API client\nconst API_BASE = 'https://jsonplaceholder.typicode.com';\n\nasync function api(endpoint) {\n  const res = await fetch(`${API_BASE}${endpoint}`);\n  if (!res.ok) throw new Error(res.statusText);\n  return res.json();\n}"
    },
    {
      "id": "working-with-json",
      "moduleId": "js-api-consumption",
      "title": "Working with JSON",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- JSON (JavaScript Object Notation) is the standard data format for APIs\n- JSON.parse() converts JSON strings to JavaScript objects\n- JSON.stringify() converts JavaScript objects to JSON strings\n- response.json() automatically parses JSON responses\n- API responses should be typed for better developer experience\n\n---\n\n# Working with JSON\n\n## What is JSON?\n\nJSON is a lightweight data format that's easy for humans to read and write, and easy for machines to parse and generate.\n\n```javascript\n// JavaScript object\nconst user = {\n  name: 'Alice',\n  age: 30,\n  isActive: true\n};\n\n// Convert to JSON string\nconst jsonString = JSON.stringify(user);\n// Result: '{\"name\":\"Alice\",\"age\":30,\"isActive\":true}'\n\n// Parse JSON back to object\nconst parsedUser = JSON.parse(jsonString);\n// Result: { name: 'Alice', age: 30, isActive: true }\n```\n\n## Fetch with JSON\n\nWhen fetching data from APIs:\n\n```javascript\n// Automatically parse JSON response\nconst response = await fetch('https://api.example.com/user/1');\nconst user = await response.json();\n\n// The user variable is now a JavaScript object\nconsole.log(user.name);  // 'Alice'\nconsole.log(user.email); // 'alice@example.com'\n```\n\n## Sending JSON Data\n\nWhen POSTing data, you need to stringify and set headers:\n\n```javascript\nconst newUser = {\n  name: 'Bob',\n  email: 'bob@example.com'\n};\n\nconst response = await fetch('https://api.example.com/users', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'  // Tell server we're sending JSON\n  },\n  body: JSON.stringify(newUser)  // Convert object to JSON string\n});\n\nconst createdUser = await response.json();\n```\n\n## Handling Complex JSON\n\n**Nested objects:**\n```javascript\nconst data = {\n  user: {\n    id: 1,\n    profile: {\n      name: 'Alice',\n      settings: {\n        theme: 'dark'\n      }\n    }\n  }\n};\n\n// Access nested data\nconst theme = data.user.profile.settings.theme;\n```\n\n**Arrays in JSON:**\n```javascript\nconst response = await fetch('https://api.example.com/posts');\nconst posts = await response.json();\n\n// posts is an array\nposts.forEach(post => {\n  console.log(post.title);\n});\n\n// Find specific item\nconst firstPost = posts[0];\nconst specificPost = posts.find(p => p.id === 5);\n```\n\n## JSON Safety\n\n```javascript\n// Safe parsing with try/catch\nfunction safeJSONParse(jsonString, defaultValue = null) {\n  try {\n    return JSON.parse(jsonString);\n  } catch (error) {\n    console.error('Invalid JSON:', error);\n    return defaultValue;\n  }\n}\n\n// Usage\nconst data = safeJSONParse(maybeJsonString, []);\n```\n\n## Common JSON API Patterns\n\n**Standard response wrapper:**\n```javascript\n// Many APIs wrap responses in a standard structure\n{\n  \"success\": true,\n  \"data\": { ... },\n  \"message\": \"User created successfully\"\n}\n\n// Or with errors\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Email is required\"\n  }\n}\n```",
      "codeExample": "// Parsing JSON responses\nasync function fetchAndDisplayUser(userId) {\n  try {\n  const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n  const user = await response.json();\n  \n    console.log('Name:', user.name);\n    console.log('Email:', user.email);\n    console.log('Company:', user.company.name);\n    \n    return user;\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\n// Stringifying data for POST\nasync function createPost(title, body) {\n  const postData = {\n    title,\n    body,\n    userId: 1\n  };\n  \n  const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(postData)\n  });\n  \n  return response.json();\n}\n\n// Safe JSON parsing\nfunction safeJSONParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch {\n    return null;\n  }\n}"
    },
    {
      "id": "http-methods",
      "moduleId": "js-api-consumption",
      "title": "HTTP Methods",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- GET: Retrieve data from server\n- POST: Create new resources\n- PUT: Replace entire resource\n- PATCH: Partial update to resource\n- DELETE: Remove resource\n- Always set appropriate Content-Type header when sending data\n\n---\n\n# HTTP Methods (Verbs)\n\nHTTP defines several methods (verbs) that indicate the desired action to be performed on a resource.\n\n## GET - Read\n\nRetrieves data from the server. Safe and idempotent (calling multiple times has same effect).\n\n```javascript\n// GET request (default method)\nconst response = await fetch('https://api.example.com/users');\nconst users = await response.json();\n```\n\n## POST - Create\n\nCreates a new resource on the server.\n\n```javascript\nconst newUser = {\n  name: 'Alice',\n  email: 'alice@example.com'\n};\n\nconst response = await fetch('https://api.example.com/users', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify(newUser)\n});\n\nconst createdUser = await response.json();\nconsole.log('Created:', createdUser.id);\n```\n\n## PUT - Replace\n\nReplaces an entire existing resource. Idempotent.\n\n```javascript\nconst updatedUser = {\n  id: 1,\n  name: 'Alice Smith',\n  email: 'alice.smith@example.com',\n  age: 31  // All fields must be included\n};\n\nconst response = await fetch('https://api.example.com/users/1', {\n  method: 'PUT',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify(updatedUser)\n});\n```\n\n## PATCH - Update\n\nPartially updates a resource. Only send fields that changed.\n\n```javascript\n// Only update the email\nconst partialUpdate = {\n  email: 'new.email@example.com'\n};\n\nconst response = await fetch('https://api.example.com/users/1', {\n  method: 'PATCH',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify(partialUpdate)\n});\n```\n\n## DELETE - Remove\n\nDeletes a resource. Idempotent.\n\n```javascript\nconst response = await fetch('https://api.example.com/users/1', {\n  method: 'DELETE'\n});\n\nif (response.ok) {\n  console.log('User deleted successfully');\n}\n```\n\n## Content-Type Header\n\nAlways set Content-Type when sending data in the body:\n\n```javascript\n// Sending JSON\nheaders: {\n  'Content-Type': 'application/json'\n}\n\n// Sending form data\nheaders: {\n  'Content-Type': 'application/x-www-form-urlencoded'\n}\n\n// Sending FormData (multipart/form-data is set automatically)\nconst formData = new FormData();\nformData.append('file', fileInput.files[0]);\n\nawait fetch('/upload', {\n  method: 'POST',\n  body: formData  // Don't set Content-Type - browser sets it with boundary\n});\n```\n\n## CRUD Operations\n\nHTTP methods map to CRUD operations:\n\n| Operation | HTTP Method | Example |\n|-----------|-------------|---------|\n| Create | POST | POST /users |\n| Read | GET | GET /users/1 |\n| Update | PUT/PATCH | PUT /users/1 |\n| Delete | DELETE | DELETE /users/1 |",
      "codeExample": "// Complete CRUD operations\nconst API_URL = 'https://jsonplaceholder.typicode.com/posts';\n\n// CREATE\nasync function createPost(title, body) {\n  const response = await fetch(API_URL, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ title, body, userId: 1 })\n  });\n  return response.json();\n}\n\n// READ\nasync function getPost(id) {\n  const response = await fetch(`${API_URL}/${id}`);\n  return response.json();\n}\n\n// UPDATE (PUT - full replacement)\nasync function replacePost(id, title, body) {\n  const response = await fetch(`${API_URL}/${id}`, {\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ id, title, body, userId: 1 })\n  });\n  return response.json();\n}\n\n// UPDATE (PATCH - partial)\nasync function updatePostTitle(id, newTitle) {\n  const response = await fetch(`${API_URL}/${id}`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ title: newTitle })\n  });\n  return response.json();\n}\n\n// DELETE\nasync function deletePost(id) {\n  const response = await fetch(`${API_URL}/${id}`, {\n    method: 'DELETE'\n  });\n  return response.ok;\n}"
    },
    {
      "id": "headers-authentication",
      "moduleId": "js-api-consumption",
      "title": "Headers & Authentication",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Headers provide metadata about the request/response\n- Authorization header is used for authentication (Bearer tokens, API keys)\n- Accept header tells server what format you want\n- Custom headers can be used for API versioning, tracking, etc.\n- Never expose API keys or tokens in client-side code for production APIs\n\n---\n\n# Headers & Authentication\n\n## HTTP Headers\n\nHeaders provide additional information about the request or response.\n\n### Common Request Headers\n\n```javascript\nconst headers = {\n  // Tell server what format we accept\n  'Accept': 'application/json',\n  \n  // Tell server what format we're sending\n  'Content-Type': 'application/json',\n  \n  // Authentication (various methods)\n  'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIs...',\n  \n  // API Key\n  'X-API-Key': 'your-api-key-here',\n  \n  // Custom headers (often prefixed with X-)\n  'X-Request-ID': 'uuid-123',\n  'X-Client-Version': '1.0.0'\n};\n\nconst response = await fetch('https://api.example.com/data', {\n  headers: headers\n});\n```\n\n## Authentication Methods\n\n### 1. Bearer Tokens (JWT)\n\nMost common for modern APIs. Token obtained via login/OAuth.\n\n```javascript\nconst token = localStorage.getItem('auth_token');\n\nconst response = await fetch('https://api.example.com/protected', {\n  headers: {\n    'Authorization': `Bearer ${token}`,\n    'Content-Type': 'application/json'\n  }\n});\n```\n\n### 2. API Keys\n\nSimple key-based authentication, often for public APIs.\n\n```javascript\n// Method 1: Header\nconst response = await fetch('https://api.example.com/data', {\n  headers: {\n    'X-API-Key': 'your-api-key-here'\n  }\n});\n\n// Method 2: Query parameter (less secure, easier to leak)\nconst response = await fetch('https://api.example.com/data?api_key=your-key');\n```\n\n### 3. Basic Authentication\n\nUsername:password encoded in Base64.\n\n```javascript\nconst credentials = btoa('username:password');\n\nconst response = await fetch('https://api.example.com/protected', {\n  headers: {\n    'Authorization': `Basic ${credentials}`\n  }\n});\n```\n\n## Creating a Reusable Auth Client\n\n```javascript\nclass APIClient {\n  constructor(baseURL, authToken = null) {\n    this.baseURL = baseURL;\n    this.authToken = authToken;\n  }\n  \n  setAuthToken(token) {\n    this.authToken = token;\n  }\n  \n  async request(endpoint, options = {}) {\n    const url = `${this.baseURL}${endpoint}`;\n    \n    // Default headers\n    const headers = {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      ...options.headers\n    };\n    \n    // Add auth header if token exists\n    if (this.authToken) {\n      headers['Authorization'] = `Bearer ${this.authToken}`;\n    }\n    \n    const response = await fetch(url, {\n      ...options,\n      headers\n    });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    \n    return response.json();\n  }\n  \n  // Convenience methods\n  get(endpoint) {\n    return this.request(endpoint);\n  }\n  \n  post(endpoint, data) {\n    return this.request(endpoint, {\n      method: 'POST',\n      body: JSON.stringify(data)\n    });\n  }\n}\n\n// Usage\nconst api = new APIClient('https://api.example.com');\napi.setAuthToken(localStorage.getItem('token'));\nconst user = await api.get('/user/profile');\n```\n\n## Security Best Practices\n\n```javascript\n// DON'T: Hardcode API keys in client code\nconst API_KEY = 'sk-live-123456789';  // BAD!\n\n// DO: Use environment variables (for server-side)\nconst API_KEY = process.env.API_KEY;\n\n// DO: For client-side, use proxy server or serverless functions\n// Client → Your Server → External API (with hidden key)\n```",
      "codeExample": "// API client with authentication\nclass AuthenticatedAPI {\n  constructor(baseURL) {\n    this.baseURL = baseURL;\n    this.token = null;\n  }\n  \n  setToken(token) {\n    this.token = token;\n  }\n  \n  getHeaders() {\n    const headers = {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    };\n    \n    if (this.token) {\n      headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    \n    return headers;\n  }\n  \n  async fetch(endpoint, options = {}) {\n    const response = await fetch(`${this.baseURL}${endpoint}`, {\n      ...options,\n      headers: {\n        ...this.getHeaders(),\n        ...options.headers\n      }\n    });\n    \n    if (response.status === 401) {\n      // Token expired or invalid\n      throw new Error('Unauthorized');\n    }\n    \n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    \n    return response.json();\n  }\n}\n\n// Usage example\nconst api = new AuthenticatedAPI('https://api.example.com');\napi.setToken(localStorage.getItem('auth_token'));\n\nasync function loadUserProfile() {\n  try {\n    const profile = await api.fetch('/user/profile');\n    return profile;\n  } catch (error) {\n    if (error.message === 'Unauthorized') {\n      // Redirect to login\n      window.location.href = '/login';\n    }\n  }\n}"
    },
    {
      "id": "api-error-handling",
      "moduleId": "js-api-consumption",
      "title": "Error Handling",
      "order": 5,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Network errors (no connection) are different from HTTP errors (4xx, 5xx)\n- Always check response.ok before parsing JSON\n- Use try/catch for network failures\n- Implement retry logic for transient failures\n- Provide user-friendly error messages\n\n---\n\n# Error Handling in API Calls\n\n## Types of Errors\n\n### 1. Network Errors\n\nConnection issues: no internet, DNS failure, timeout.\n\n```javascript\ntry {\n  const response = await fetch('https://api.example.com/data');\n} catch (networkError) {\n  // Network error: no connection, timeout, DNS failure\n  console.error('Network error:', networkError.message);\n  // Show: \"Please check your internet connection\"\n}\n```\n\n### 2. HTTP Errors\n\nServer responded with error status (4xx, 5xx).\n\n```javascript\nconst response = await fetch('https://api.example.com/users/999');\n\nif (!response.ok) {\n  // HTTP error: 404 Not Found, 500 Server Error, etc.\n  console.error('HTTP error:', response.status, response.statusText);\n  \n  if (response.status === 404) {\n    // User not found\n  } else if (response.status === 401) {\n    // Unauthorized - redirect to login\n  } else if (response.status >= 500) {\n    // Server error - retry might help\n  }\n}\n```\n\n### 3. JSON Parsing Errors\n\nServer returned invalid JSON.\n\n```javascript\ntry {\n  const data = await response.json();\n} catch (parseError) {\n  console.error('Invalid JSON response');\n}\n```\n\n## Comprehensive Error Handling\n\n```javascript\nasync function fetchWithErrorHandling(url, options = {}) {\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: AbortSignal.timeout(10000)  // 10 second timeout\n    });\n    \n    if (!response.ok) {\n      // Try to get error details from response body\n      let errorData;\n      try {\n        errorData = await response.json();\n      } catch {\n        errorData = { message: response.statusText };\n      }\n      \n      const error = new Error(errorData.message || `HTTP ${response.status}`);\n      error.status = response.status;\n      error.data = errorData;\n      throw error;\n    }\n    \n    return await response.json();\n    \n  } catch (error) {\n    if (error.name === 'AbortError') {\n      throw new Error('Request timeout');\n    }\n    if (error.name === 'TypeError') {\n      throw new Error('Network error - check your connection');\n    }\n    throw error;\n  }\n}\n```\n\n## Retry Logic\n\n```javascript\nasync function fetchWithRetry(url, options = {}, maxRetries = 3) {\n  let lastError;\n  \n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fetchWithErrorHandling(url, options);\n    } catch (error) {\n      lastError = error;\n      \n      // Don't retry client errors (4xx)\n      if (error.status >= 400 && error.status < 500) {\n        throw error;\n      }\n      \n      // Wait before retrying (exponential backoff)\n      if (i < maxRetries - 1) {\n        const delay = Math.pow(2, i) * 1000;  // 1s, 2s, 4s\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  \n  throw lastError;\n}\n```\n\n## User-Friendly Error Messages\n\n```javascript\nfunction getErrorMessage(error) {\n  if (error.message.includes('Network error')) {\n    return 'Please check your internet connection and try again.';\n  }\n  if (error.status === 404) {\n    return 'The requested resource was not found.';\n  }\n  if (error.status === 401) {\n    return 'Please log in to continue.';\n  }\n  if (error.status === 403) {\n    return 'You do not have permission to perform this action.';\n  }\n  if (error.status >= 500) {\n    return 'Something went wrong on our end. Please try again later.';\n  }\n  return 'An unexpected error occurred. Please try again.';\n}\n\n// Usage\ntry {\n  const data = await fetchWithErrorHandling('/api/data');\n} catch (error) {\n  showErrorToast(getErrorMessage(error));\n}\n```",
      "codeExample": "// Comprehensive error handling wrapper\nasync function robustFetch(url, options = {}) {\n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000);\n    \n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal\n    });\n    \n    clearTimeout(timeoutId);\n    \n    if (!response.ok) {\n      const error = new Error(`HTTP ${response.status}: ${response.statusText}`);\n      error.status = response.status;\n      try {\n        error.data = await response.json();\n      } catch {\n        error.data = null;\n      }\n      throw error;\n    }\n    \n    return response.json();\n    \n  } catch (error) {\n    if (error.name === 'AbortError') {\n      throw new Error('Request timed out');\n    }\n    if (error.name === 'TypeError') {\n      throw new Error('Network error - please check your connection');\n    }\n    throw error;\n  }\n}\n\n// Retry with exponential backoff\nasync function fetchWithRetry(url, options, maxRetries = 3) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await robustFetch(url, options);\n    } catch (error) {\n      // Don't retry client errors\n      if (error.status >= 400 && error.status < 500) {\n        throw error;\n      }\n      \n      if (i === maxRetries - 1) throw error;\n      \n      // Exponential backoff\n      await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000));\n    }\n  }\n}\n\n// User-friendly error messages\nconst errorMessages = {\n  401: 'Please log in to continue',\n  403: 'You do not have permission',\n  404: 'Resource not found',\n  500: 'Server error - please try again later',\n  network: 'Check your internet connection',\n  timeout: 'Request timed out - please try again'\n};"
    }
  ],
  "exercises": []
}
