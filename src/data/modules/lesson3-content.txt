# Essential to know
- Server stores session data, client gets session ID
- Session ID sent via cookie
- Stateful: server must track all sessions
- Good for traditional web apps

---

# Session-Based Authentication

## How Session-Based Auth Works

Session-based authentication is the traditional approach used by server-rendered web applications.

### The Flow

```
1. User submits credentials (login form)
       ↓
2. Server validates credentials
       ↓
3. Server creates session in database/memory
       ↓
4. Server sends session ID via cookie
       ↓
5. Client sends cookie with every request
       ↓
6. Server looks up session, identifies user
       ↓
7. Server responds with user-specific data
```

### Visual Diagram

```
┌─────────┐    Login     ┌─────────┐   Create    ┌─────────┐
│ Client  │ ───────────→ │ Server  │ ──────────→ │Session  │
│         │              │         │   Session   │  Store  │
│         │ ←─────────── │         │ ←────────── │         │
│         │  Set-Cookie  │         │  Return ID  │         │
└─────────┘              └─────────┘             └─────────┘
     │                        ▲                        ▲
     │    Request + Cookie    │                        │
     └───────────────────────┘                        │
                              │    Validate Session   │
                              └───────────────────────┘
```

## Setting Up express-session

### Basic Configuration

```javascript
import express from 'express';
import session from 'express-session';

const app = express();

app.use(session({
  secret: process.env.SESSION_SECRET,  // Secret key for signing cookies
  resave: false,                       // Don't save if unmodified
  saveUninitialized: false,            // Don't create session until something stored
  cookie: {
    secure: process.env.NODE_ENV === 'production',  // HTTPS only in prod
    httpOnly: true,    // Prevent XSS attacks
    maxAge: 24 * 60 * 60 * 1000,  // 24 hours
    sameSite: 'strict'  // CSRF protection
  },
  name: 'sessionId'  // Don't use default 'connect.sid'
}));
```

### Environment Variables

```bash
# .env
SESSION_SECRET=your-super-secret-long-random-string-here
NODE_ENV=production
```

**Generate a strong secret:**
```bash
node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
```

## Complete Login/Logout Implementation

```javascript
// Login route
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Find user
  const user = await db.findUserByEmail(email);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Verify password
  const validPassword = await bcrypt.compare(password, user.passwordHash);
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Create session
  req.session.userId = user.id;
  req.session.email = user.email;
  
  // Optional: track session info
  req.session.loginTime = new Date();
  req.session.ipAddress = req.ip;
  
  res.json({ message: 'Logged in successfully' });
});

// Logout route
app.post('/auth/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ error: 'Could not log out' });
    }
    res.clearCookie('sessionId');
    res.json({ message: 'Logged out successfully' });
  });
});

// Check auth status
app.get('/auth/me', (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  res.json({ userId: req.session.userId, email: req.session.email });
});
```

## Session Stores

By default, sessions are stored in memory (not suitable for production).

### 1. Redis (Recommended for Production)

```bash
npm install connect-redis redis
```

```javascript
import RedisStore from 'connect-redis';
import { createClient } from 'redis';

const redisClient = createClient({
  url: process.env.REDIS_URL
});
redisClient.connect();

app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: { secure: true, httpOnly: true, maxAge: 86400000 }
}));
```

**Benefits:**
- Fast in-memory storage
- Automatic expiration (TTL)
- Shared across multiple servers
- Persistence options

### 2. Database Store (PostgreSQL/MySQL)

```bash
npm install connect-session-sequelize sequelize
```

```javascript
import session from 'express-session';
import SequelizeStore from 'connect-session-sequelize';
import { sequelize } from './database.js';

const SessionStore = SequelizeStore(session.Store);

app.use(session({
  store: new SessionStore({
    db: sequelize,
    tableName: 'sessions',
    checkExpirationInterval: 15 * 60 * 1000  // Clean up every 15 min
  }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false
}));
```

### 3. MongoDB Store

```bash
npm install connect-mongo
```

```javascript
import MongoStore from 'connect-mongo';

app.use(session({
  store: MongoStore.create({
    mongoUrl: process.env.MONGODB_URI,
    ttl: 14 * 24 * 60 * 60  // 14 days
  }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false
}));
```

## Cookie Security Best Practices

### Essential Flags

```javascript
cookie: {
  httpOnly: true,     // Prevents XSS (JS can't read cookie)
  secure: true,       // HTTPS only (prevents interception)
  sameSite: 'strict', // CSRF protection
  maxAge: 3600000,    // Expiration time
  domain: 'example.com',  // Limit to specific domain
  path: '/'           // Available on all paths
}
```

### Cookie Flag Explained

| Flag | Purpose | Without It |
|------|---------|------------|
| `httpOnly` | Prevents JavaScript access | XSS attacks can steal session |
| `secure` | HTTPS only | Cookie sent over HTTP (MITM attack) |
| `sameSite` | Controls cross-site requests | CSRF attacks possible |
| `maxAge` | Expiration | Session persists forever |

### SameSite Options

```javascript
// Strict: Cookie never sent in cross-site requests
sameSite: 'strict'
// Best for: Banking, high-security apps

// Lax: Cookie sent for top-level GET requests only
sameSite: 'lax'
// Best for: Most web apps (allows external links)

// None: Cookie always sent (requires secure: true)
sameSite: 'none'
// Best for: Embedded widgets, APIs
```

## Session Security Checklist

- [ ] Use HTTPS in production
- [ ] Set `httpOnly`, `secure`, `sameSite` flags
- [ ] Use strong session secret (256+ bits)
- [ ] Rotate session secret periodically
- [ ] Set reasonable expiration
- [ ] Use external session store (Redis/DB)
- [ ] Regenerate session ID on login (prevents fixation)
- [ ] Destroy session completely on logout
- [ ] Implement idle timeout
- [ ] Log suspicious session activity

## Session vs JWT: When to Use What?

### Use Sessions When:
- Traditional server-rendered web apps
- Need to revoke sessions instantly
- Want server-side control
- Smaller scale applications
- Real-time session monitoring needed

### Use JWT When:
- API-first architectures
- Microservices
- Mobile apps
- Need stateless authentication
- Cross-domain authentication

## Common Pitfalls

### 1. Storing Sensitive Data in Session
```javascript
// ❌ BAD
req.session.password = user.password;
req.session.creditCard = cardNumber;

// ✅ GOOD
req.session.userId = user.id;  // Store only identifier
```

### 2. Not Regenerating Session on Login
```javascript
// ❌ BAD - Session fixation vulnerability
req.session.userId = user.id;

// ✅ GOOD
req.session.regenerate((err) => {
  req.session.userId = user.id;
  res.json({ message: 'Logged in' });
});
```

### 3. Missing Error Handling
```javascript
// ❌ BAD
req.session.destroy();
res.json({ message: 'Logged out' });

// ✅ GOOD
req.session.destroy((err) => {
  if (err) {
    console.error('Session destruction error:', err);
    return res.status(500).json({ error: 'Logout failed' });
  }
  res.clearCookie('sessionId');
  res.json({ message: 'Logged out' });
});
```