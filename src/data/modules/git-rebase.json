{
  "module": {
    "id": "git-rebase",
    "title": "Git Rebase",
    "description": "Master git rebase for clean and linear history",
    "icon": "GitCommit",
    "requiredXp": 400,
    "color": "from-purple-400 to-indigo-600",
    "courseId": "git-mastery"
  },
  "lessons": [
    {
      "id": "git-rebase-intro",
      "moduleId": "git-rebase",
      "title": "Introduction to Rebase",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Rebase = move or replay commits on another base\n- Interactive rebase = modify, merge, reorder commits\n- Produces clean and linear history\n- Never rebase already pushed commits!\n- git rebase main = replay current branch commits on main\n- git rebase -i = interactive mode to modify history\n\n---\n\n# Git Rebase: Clean History\n\n## What is Rebase?\n\n**Rebase** = Replay commits from one branch on another base.\n\nImagine you have a feature branch created from main, but main has moved forward since.\n\n**Before rebase (zigzag history):**\n```\nmain:    A---B---C---D\n              \\feature:       E---F---G\n```\n\n**After rebase (linear history):**\n```\nmain:    A---B---C---D\n                      \\feature:               E'---F'---G'\n```\n\nCommits E, F, G are \"replayed\" (recreated) after D.\n\n## Why Use Rebase?\n\n**Advantages:**\n- ‚úÖ Clean and linear history\n- ‚úÖ Easier to read history\n- ‚úÖ Avoids unnecessary merge commits\n- ‚úÖ Facilitates git bisect (debug)\n\n**Disadvantages:**\n- ‚ùå Rewrites history (new commit hashes)\n- ‚ùå Dangerous if used on shared code\n- ‚ùå More complex than merge\n\n## When to Use Rebase vs Merge?\n\n**Use Rebase when:**\n- You're working alone on your branch\n- You want clean history before merging\n- You want to update your branch with main\n\n**Use Merge when:**\n- You're working as a team on the branch\n- Commits are already pushed\n- You want to preserve exact history\n\n## Simple Rebase\n\n```bash\n# On your feature branch\ngit checkout feature\n\n# Replay your commits on latest main version\ngit rebase main\n\n# Resolve conflicts if necessary\n# Then continue\ngit rebase --continue\n\n# Or cancel rebase\ngit rebase --abort\n```\n\n## Typical Workflow\n\n```bash\n# 1. Start feature\ngit checkout -b feature/login\n\n# 2. Develop...\ngit commit -m \"Add form\"\ngit commit -m \"Add validation\"\n\n# 3. Meanwhile, main has evolved\n# Update your branch\ngit fetch origin\ngit rebase origin/main\n\n# 4. Resolve conflicts if any\n# Then push\ngit push --force-with-lease\n```\n\n## Rebase vs Merge\n\n```\nMerge:                          Rebase:\nA---B---C---D (main)            A---B---C---D (main)\n     \\                                          \\feature:  E---F---G           feature:      E'---F'---G'\n              \\   /                                  ‚Üë\n               M (merge commit)               Linear, no merge\n```\n\n## Golden Rule: Never Rebase Shared Commits!\n\n```bash\n# ‚ùå NEVER do this:\ngit checkout main\ngit rebase feature  # Rewrites main history!\ngit push --force    # üíÄ Destroys team work!\n```\n\n**Rebase is only for your local branches before pushing.**",
      "codeExample": "# Simple rebase: update a branch\n\ngit checkout feature-branch\n\n# Replay feature-branch commits on main\ngit rebase main\n\n# Conflict management\ngit add .                    # Resolve then stage\ngit rebase --continue        # Continue rebase\n# or\ngit rebase --abort           # Cancel completely\n\n# Push after rebase (history modified)\ngit push --force-with-lease\n\n# Alternative: pull with rebase\ngit pull --rebase origin main\n\n# Configure pull to rebase by default\ngit config --global pull.rebase true"
    },
    {
      "id": "git-rebase-interactive",
      "moduleId": "git-rebase",
      "title": "Interactive Rebase",
      "order": 2,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Interactive rebase (-i) = modify commit history\n- Actions: pick, reword, squash, fixup, drop, reorder\n- Perfect for cleaning up before merging a PR\n- Allows merging \"WIP\" commits\n- Warning: never do on pushed commits!\n\n---\n\n# Interactive Rebase: Modify History\n\n## Introduction\n\nInteractive rebase lets you modify your commits like video editing:\n- Reorder commits\n- Modify messages\n- Merge commits\n- Delete commits\n- Split a commit into several\n\n## Basic Syntax\n\n```bash\n# Modify last 3 commits\ngit rebase -i HEAD~3\n\n# Modify from a specific commit\ngit rebase -i abc1234\n\n# Modify entire branch from main\ngit rebase -i main\n```\n\n## Available Actions\n\nWhen you run `git rebase -i`, an editor opens:\n\n```\npick abc1234 Add login form\npick def5678 WIP: fix bug\npick ghi9012 Update styles\n\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# d, drop <commit> = remove commit\n```\n\n## Practical Examples\n\n### 1. Modify a commit message\n\n```bash\ngit rebase -i HEAD~3\n```\n\n```\n# Before\npick abc1234 Add login form\npick def5678 WIP: fix bug\npick ghi9012 Update styles\n\n# After (replace pick with reword)\npick abc1234 Add login form\nreword def5678 WIP: fix bug    # ‚Üê We'll modify this message\npick ghi9012 Update styles\n```\n\nSave and close. A new editor opens to modify the message.\n\n### 2. Merge commits (squash)\n\n```\n# Before\npick abc1234 Add login form\npick def5678 WIP: fix typo\npick ghi9012 WIP: another fix\npick jkl3456 Finalize login\n\n# After (merge WIPs)\npick abc1234 Add login form\nsquash def5678 WIP: fix typo   # ‚Üê Merges with previous\nsquash ghi9012 WIP: another fix # ‚Üê Merges with previous\npick jkl3456 Finalize login\n\n# Result: 2 commits instead of 4\n```\n\n### 3. Delete a commit\n\n```\n# Before\npick abc1234 Good commit\npick def5678 Bad commit\npick ghi9012 Another good commit\n\n# After\npick abc1234 Good commit\ndrop def5678 Bad commit        # ‚Üê Deleted\npick ghi9012 Another good commit\n```\n\n### 4. Reorder commits\n\n```\n# Before\npick abc1234 Commit 1\npick def5678 Commit 2\npick ghi9012 Commit 3\n\n# After (swap 2 and 3)\npick abc1234 Commit 1\npick ghi9012 Commit 3          # ‚Üê Moved up\npick def5678 Commit 2\n```\n\n## Complete Example\n\n```bash\n# You have this messy history\ngit log --oneline\na1b2c3d (HEAD -> feature) WIP: fix typo\ne4f5g6h WIP: debugging\ni7j8k9l Add authentication\nm0n1o2p Initial commit\n\n# Clean it up\ngit rebase -i HEAD~3\n\n# Editor opens:\n# pick i7j8k9l Add authentication\n# pick e4f5g6h WIP: debugging\n# pick a1b2c3d WIP: fix typo\n\n# Change to:\n# pick i7j8k9l Add authentication\n# squash e4f5g6h WIP: debugging\n# squash a1b2c3d WIP: fix typo\n\n# Save and close\n# Another editor opens for the merged commit message\n# Enter: \"feat: add complete authentication\"\n\n# Result:\ngit log --oneline\nabc1234 (HEAD -> feature) feat: add complete authentication\nm0n1o2p Initial commit\n```\n\n## Split a Commit\n\n```bash\ngit rebase -i HEAD~2\n\n# Change 'pick' to 'edit' on the commit to split\nedit abc1234 Big commit with multiple changes\n\n# Save\n# Rebase stops at this commit\n\n# Unstage everything\ngit reset HEAD~1\n\n# Re-commit in parts\ngit add auth.js\ngit commit -m \"feat: add authentication\"\n\ngit add tests/\ngit commit -m \"test: add auth tests\"\n\n# Continue rebase\ngit rebase --continue\n```",
      "codeExample": "# Complete interactive rebase\n\n# Modify last 5 commits\ngit rebase -i HEAD~5\n\n# Editor opens with:\n# pick abc1111 Commit 1\n# pick def2222 Commit 2\n# pick ghi3333 Commit 3\n# pick jkl4444 Commit 4\n# pick mno5555 Commit 5\n\n# SCENARIO 1: Merge commits 2 and 3\n# pick abc1111 Commit 1\n# squash def2222 Commit 2   # ‚Üê squash merges with previous\n# pick ghi3333 Commit 3     # ‚Üê becomes new commit 3\n# pick jkl4444 Commit 4\n# pick mno5555 Commit 5\n\n# SCENARIO 2: Modify commit 4 message\n# pick abc1111 Commit 1\n# pick def2222 Commit 2\n# pick ghi3333 Commit 3\n# reword jkl4444 Commit 4   # ‚Üê reword to change message\n# pick mno5555 Commit 5\n\n# SCENARIO 3: Delete commit 3\n# pick abc1111 Commit 1\n# pick def2222 Commit 2\n# drop ghi3333 Commit 3     # ‚Üê drop deletes commit\n# pick jkl4444 Commit 4\n# pick mno5555 Commit 5\n\n# SCENARIO 4: Reorder\n# pick abc1111 Commit 1\n# pick ghi3333 Commit 3     # ‚Üê swapped with commit 2\n# pick def2222 Commit 2\n# pick jkl4444 Commit 4\n# pick mno5555 Commit 5\n\n# After modifying file:\n# Save and close editor\n\n# Resolve conflicts if necessary\ngit add .\ngit rebase --continue\n\n# Check result\ngit log --oneline"
    },
    {
      "id": "git-rebase-conflicts",
      "moduleId": "git-rebase",
      "title": "Resolving Conflicts in Rebase",
      "order": 3,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Conflicts in rebase = same principle as merge\n- Git stops at each conflicting commit\n- Resolve, stage, then rebase --continue\n- Use git rebase --abort to cancel\n- git rebase --skip to skip a commit\n- Multiple conflicts possible (one per commit)\n\n---\n\n# Managing Conflicts in Rebase\n\n## Why Conflicts in Rebase?\n\nWhen you rebase, Git replays your commits one by one. If a commit modifies a file that was also modified in the base branch, there's a conflict.\n\n**Difference with merge:**\n- **Merge**: Single conflict for everything\n- **Rebase**: Potentially one conflict PER COMMIT\n\n## Resolution Workflow\n\n```bash\n# 1. Start rebase\ngit rebase main\n\n# 2. Git stops on a conflict\nAuto-merging src/app.js\nCONFLICT (content): Merge conflict in src/app.js\nerror: could not apply abc1234... Add feature\nhint: Resolve all conflicts manually...\n\n# 3. View conflicting files\ngit status\n\n# 4. Resolve conflicts in files\n# (Edit files, keep what you need)\n\n# 5. Stage resolved files\ngit add src/app.js\n\n# 6. Continue rebase\ngit rebase --continue\n\n# 7. Repeat if other conflicts...\n```\n\n## Available Options\n\nWhen a conflict occurs:\n\n```bash\n# Continue after resolution\ngit rebase --continue\n\n# Skip this commit (warning, loss of changes)\ngit rebase --skip\n\n# Cancel rebase completely\ngit rebase --abort\n\n# Edit current commit\ngit commit --amend\n```\n\n## Complete Example\n\n```bash\n# Context\ngit checkout feature\ngit rebase main\n\n# Conflict!\n# Auto-merging README.md\n# CONFLICT (content): Merge conflict in README.md\n\n# View conflict\ncat README.md\n```\n\n```markdown\n# My Project\n\n<<<<<<< HEAD (main)\nNew description added in main\n=======\nDescription from my feature branch\n>>>>>>> abc1234 (Add feature)\n```\n\n```bash\n# Edit README.md to keep what you want\n# For example, combine both:\n\n# My Project\n# \n# New description added in main\n# Description from my feature branch\n\n# Stage\ngit add README.md\n\n# Continue\ngit rebase --continue\n\n# New conflict on next commit?\n# Repeat process...\n\n# If too complicated, cancel\n# git rebase --abort\n```\n\n## Tips to Avoid Conflicts\n\n1. **Rebase often**: The longer you wait, the more conflicts\n   ```bash\n   # Daily rebase\n   git fetch origin\n   git rebase origin/main\n   ```\n\n2. **Communicate with team**: Coordinate big changes\n\n3. **Make small commits**: Easier to manage in rebase\n\n4. **Use visual tools**:\n   ```bash\n   git mergetool\n   ```\n\n## Rebase vs Merge: Conflicts\n\n| Aspect | Merge | Rebase |\n|--------|-------|--------|\n| Number of conflicts | Single | One per commit |\n| Complexity | All at once | Progressive |\n| Final history | Merge commit | Linear |\n| Recommended for | Shared branches | Personal branches |",
      "codeExample": "# Complete management of rebase with conflicts\n\n# Start rebase\ngit checkout feature\ngit rebase main\n\n# === CONFLICT ===\n# Git shows:\n# Auto-merging app.js\n# CONFLICT (content): Merge conflict in app.js\n\n# View status\ngit status\n# Output:\n# You are currently rebasing branch 'feature' on 'main'.\n#   (fix conflicts and then run \"git rebase --continue\")\n#   (use \"git rebase --skip\" to skip this patch)\n#   (use \"git rebase --abort\" to check out the original branch)\n#\n# Unmerged paths:\n#   (use \"git restore --staged <file>...\" to unstage)\n#   (use \"git add <file>...\" to mark resolution)\n#\n# \tboth modified:   app.js\n\n# View differences\ngit diff\n\n# Edit app.js to resolve\n# ...\n\n# Stage resolved file\ngit add app.js\n\n# Optional: verify\ngit status\n\n# Continue\ngit rebase --continue\n\n# If new conflict, repeat...\n\n# If all goes well:\n# Successfully rebased and updated refs/heads/feature.\n\n# Check history\ngit log --oneline --graph\n\n# Push (force needed)\ngit push --force-with-lease"
    }
  ],
  "exercises": [
    {
      "id": "rebase-ex-1",
      "lessonId": "git-rebase-intro",
      "moduleId": "git-rebase",
      "title": "Rebase Basics Quiz",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "What does git rebase main do on a feature branch?",
          "options": [
            "Merges main into feature",
            "Replays feature commits on top of main",
            "Deletes feature commits",
            "Creates a new branch"
          ],
          "correctAnswer": 1,
          "explanation": "git rebase main takes feature commits and replays them one by one on top of main, creating a linear history."
        },
        {
          "question": "What is the golden rule of rebase?",
          "options": [
            "Rebase every day",
            "Never rebase already pushed commits",
            "Always use rebase instead of merge",
            "Only rebase on main"
          ],
          "correctAnswer": 1,
          "explanation": "You should never rebase commits that have already been pushed to a remote, as this rewrites history and can cause problems for the team."
        },
        {
          "question": "Which command cancels a rebase in progress?",
          "options": [
            "git rebase --cancel",
            "git rebase --abort",
            "git rebase --stop",
            "git reset --hard"
          ],
          "correctAnswer": 1,
          "explanation": "git rebase --abort cancels the rebase in progress and puts the branch back in its original state."
        }
      ]
    },
    {
      "id": "rebase-ex-2",
      "lessonId": "git-rebase-interactive",
      "moduleId": "git-rebase",
      "title": "Interactive Rebase Quiz",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "Which command launches interactive rebase?",
          "options": [
            "git rebase -interactive",
            "git rebase -i",
            "git interactive-rebase",
            "git rebase --edit"
          ],
          "correctAnswer": 1,
          "explanation": "git rebase -i (or --interactive) launches interactive mode allowing you to modify, merge, or reorder commits."
        },
        {
          "question": "What does 'squash' do in an interactive rebase?",
          "options": [
            "Deletes the commit",
            "Merges commit with previous",
            "Changes commit order",
            "Modifies commit message"
          ],
          "correctAnswer": 1,
          "explanation": "squash merges the commit with the previous one and allows editing the combined commit message."
        },
        {
          "question": "What is the difference between squash and fixup?",
          "options": [
            "No difference",
            "fixup merges without keeping message",
            "squash deletes commit",
            "fixup changes order"
          ],
          "correctAnswer": 1,
          "explanation": "fixup works like squash but keeps only the previous commit's message, without asking to edit the combined commit's message."
        }
      ]
    },
    {
      "id": "rebase-ex-3",
      "type": "git-scenario",
      "lessonId": "git-rebase-intro",
      "moduleId": "git-rebase",
      "title": "Simple Rebase",
      "difficulty": "medium",
      "story": "You're on the 'feature' branch which has 2 commits. Main has moved forward with 2 new commits. Use rebase to update your branch with main.",
      "hints": [
        "Make sure you're on the feature branch",
        "Use 'git rebase main' to replay your commits on main",
        "Verify with git log that history is linear"
      ],
      "initialState": {
        "files": [
          { "name": "app.js", "status": "committed" }
        ],
        "commits": [
          { "message": "Initial commit", "files": ["app.js"] },
          { "message": "Feature commit 1", "files": ["app.js"], "branch": "feature" },
          { "message": "Feature commit 2", "files": ["app.js"], "branch": "feature" },
          { "message": "Main update 1", "files": ["app.js"], "branch": "main" },
          { "message": "Main update 2", "files": ["app.js"], "branch": "main" }
        ],
        "branches": ["main", "feature"],
        "currentBranch": "feature",
        "isInitialized": true
      },
      "objectives": [
        { "description": "Rebase feature on main", "check": { "type": "currentBranch", "value": "feature" } },
        { "description": "Linear history", "check": { "type": "minCommits", "value": 5 } }
      ]
    }
  ]
}