{
  "module": {
    "id": "databases-data",
    "title": "Databases & Data",
    "description": "SQL vs NoSQL, SQLite, PostgreSQL, MongoDB and ORMs",
    "icon": "Database",
    "requiredXp": 850,
    "color": "from-green-400 to-green-600",
    "courseId": "web-stack"
  },
  "lessons": [
    {
      "id": "sql-vs-nosql",
      "moduleId": "databases-data",
      "title": "SQL vs NoSQL",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- SQL = Structured Query Language (relational databases)\n- NoSQL = Non-relational databases (flexible schema)\n- SQL uses tables, NoSQL uses documents/key-value/graphs\n- Choose based on data structure and scalability needs\n\n---\n\n# SQL vs NoSQL: Two Philosophies\n\n## SQL (Relational) Databases\n\n**Structure:** Tables with rows and columns\n\n**Example (Users table):**\n```\nid | name    | email              | age\n---|---------|--------------------|----\n1  | Alice   | alice@example.com  | 25\n2  | Bob     | bob@example.com    | 30\n```\n\n**Relationships:**\n```\nUsers table:\nid | name\n---|------\n1  | Alice\n\nPosts table:\nid | user_id | title\n---|---------|-------\n1  | 1       | My Post\n```\n\nPosts link to Users via `user_id`!\n\n## SQL Query Language\n\n```sql\n-- Get all users\nSELECT * FROM users;\n\n-- Get user by ID\nSELECT * FROM users WHERE id = 1;\n\n-- Get users with posts\nSELECT users.name, posts.title\nFROM users\nJOIN posts ON users.id = posts.user_id;\n\n-- Create user\nINSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');\n\n-- Update user\nUPDATE users SET age = 26 WHERE id = 1;\n\n-- Delete user\nDELETE FROM users WHERE id = 1;\n```\n\n## SQL Databases\n\n**Popular choices:**\n- **PostgreSQL** - Feature-rich, open-source\n- **MySQL** - Popular, easy to use\n- **SQLite** - File-based, no server needed\n- **Microsoft SQL Server** - Enterprise\n\n## NoSQL Databases\n\n**Structure:** Flexible (documents, key-value, graphs)\n\n**Document Database (MongoDB example):**\n```json\n{\n  \"_id\": \"abc123\",\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\",\n  \"age\": 25,\n  \"posts\": [\n    { \"title\": \"My Post\", \"date\": \"2024-01-01\" }\n  ]\n}\n```\n\nNo fixed schema! Can add any fields.\n\n## Types of NoSQL\n\n**1. Document (MongoDB, CouchDB)**\n```json\n{ \"name\": \"Alice\", \"age\": 25, \"hobbies\": [\"coding\"] }\n```\n\n**2. Key-Value (Redis, DynamoDB)**\n```\nuser:1 → {\"name\": \"Alice\"}\nsession:abc → {\"userId\": 1}\n```\n\n**3. Column-Family (Cassandra)**\nWide columns, great for time-series\n\n**4. Graph (Neo4j)**\nNodes and relationships\n\n## SQL vs NoSQL Comparison\n\n**SQL (Relational):**\n- ✅ Structured data\n- ✅ ACID transactions (reliable)\n- ✅ Complex queries (JOINs)\n- ✅ Data integrity\n- ❌ Fixed schema (harder to change)\n- ❌ Harder to scale horizontally\n\n**NoSQL:**\n- ✅ Flexible schema\n- ✅ Scales horizontally (distributed)\n- ✅ Fast for simple queries\n- ✅ Good for unstructured data\n- ❌ Weaker consistency\n- ❌ Limited JOIN support\n\n## When to Use SQL\n\n**Choose SQL when:**\n- ✅ Structured, relational data\n- ✅ Need ACID transactions (banking, orders)\n- ✅ Complex queries with JOINs\n- ✅ Data integrity is critical\n- ✅ Traditional business apps\n\n**Examples:**\n- E-commerce (orders, inventory)\n- Banking systems\n- HR systems\n- CRM\n\n## When to Use NoSQL\n\n**Choose NoSQL when:**\n- ✅ Flexible/evolving schema\n- ✅ Massive scale (millions of users)\n- ✅ Simple queries\n- ✅ Real-time data\n- ✅ Unstructured data (logs, social media)\n\n**Examples:**\n- Social media feeds\n- IoT sensor data\n- Real-time analytics\n- Content management\n- Caching\n\n## Can You Use Both?\n\n**Yes! Polyglot persistence:**\n\n```\nApp:\n├─ PostgreSQL → User accounts, orders (need ACID)\n├─ Redis → Caching, sessions (fast key-value)\n└─ MongoDB → User profiles, posts (flexible)\n```\n\nUse the right tool for each job!",
      "codeExample": "// SQL example (with PostgreSQL client)\n\nimport pg from 'pg';\n\nconst client = new pg.Client({\n  connectionString: 'postgresql://localhost/mydb'\n});\n\nawait client.connect();\n\n// Query\nconst result = await client.query(\n  'SELECT * FROM users WHERE age > $1',\n  [18]\n);\nconsole.log(result.rows);\n\n// Insert\nawait client.query(\n  'INSERT INTO users (name, email) VALUES ($1, $2)',\n  ['Alice', 'alice@example.com']\n);\n\n// ――――――――――――――――――――――――――――――――――――\n\n// NoSQL example (MongoDB)\n\nimport { MongoClient } from 'mongodb';\n\nconst client = new MongoClient('mongodb://localhost:27017');\nawait client.connect();\n\nconst db = client.db('mydb');\nconst users = db.collection('users');\n\n// Find\nconst user = await users.findOne({ age: { $gt: 18 } });\n\n// Insert\nawait users.insertOne({\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 25,\n  tags: ['developer', 'gamer'] // Flexible!\n});\n\n// Update\nawait users.updateOne(\n  { name: 'Alice' },\n  { $set: { age: 26 } }\n);"
    },
    {
      "id": "sqlite-intro",
      "moduleId": "databases-data",
      "title": "SQLite: File-Based Database",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- SQLite = file-based SQL database (no server)\n- Perfect for local apps, mobile, embedded systems\n- Zero configuration, just one file\n- Full SQL support but lightweight\n\n---\n\n# SQLite: Database in a File\n\n## What is SQLite?\n\nSQLite is a **file-based** SQL database. No server needed!\n\n**Traditional databases:**\n```\nApp → Network → Database Server\n```\n\n**SQLite:**\n```\nApp → database.db file\n```\n\nEverything in one file!\n\n## Why SQLite?\n\n**1. Zero Configuration**\nNo installation, no server, just a file.\n\n**2. Portable**\nCopy the .db file = copy entire database\n\n**3. Lightweight**\nSmall footprint, fast for local use\n\n**4. Full SQL**\nSupports most SQL features\n\n## Use Cases\n\n**✅ Perfect for:**\n- Mobile apps (iOS, Android)\n- Desktop applications\n- Browser (via SQL.js)\n- Embedded systems\n- Development/testing\n- Small websites (< 100k hits/day)\n- Local caching\n\n**❌ Not for:**\n- High concurrency (many simultaneous writes)\n- Very large datasets (> 100GB)\n- Network access (use PostgreSQL/MySQL)\n\n## Basic Usage\n\n```javascript\nimport sqlite3 from 'sqlite3';\nimport { open } from 'sqlite';\n\n// Open database (creates if doesn't exist)\nconst db = await open({\n  filename: './mydb.sqlite',\n  driver: sqlite3.Database\n});\n\n// Create table\nawait db.exec(`\n  CREATE TABLE IF NOT EXISTS users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL,\n    email TEXT UNIQUE\n  )\n`);\n\n// Insert\nawait db.run(\n  'INSERT INTO users (name, email) VALUES (?, ?)',\n  'Alice',\n  'alice@example.com'\n);\n\n// Query\nconst users = await db.all('SELECT * FROM users');\nconst user = await db.get('SELECT * FROM users WHERE id = ?', 1);\n\n// Update\nawait db.run(\n  'UPDATE users SET name = ? WHERE id = ?',\n  'Alice Smith',\n  1\n);\n\n// Delete\nawait db.run('DELETE FROM users WHERE id = ?', 1);\n```\n\n## In the Browser!\n\n**SQL.js** - SQLite compiled to WebAssembly:\n\n```javascript\nimport initSqlJs from 'sql.js';\n\nconst SQL = await initSqlJs();\nconst db = new SQL.Database();\n\ndb.run('CREATE TABLE users (name TEXT, age INTEGER)');\ndb.run('INSERT INTO users VALUES (\"Alice\", 25)');\n\nconst result = db.exec('SELECT * FROM users');\nconsole.log(result);\n```\n\nDatabase in the browser!\n\n## When to Use SQLite\n\n**Choose SQLite:**\n- ✅ Local-first applications\n- ✅ Mobile apps\n- ✅ Testing/development\n- ✅ Embedded devices\n- ✅ Single-user apps\n- ✅ Simple websites\n\n**Upgrade to PostgreSQL/MySQL when:**\n- ❌ Multiple concurrent writers\n- ❌ Need client-server architecture\n- ❌ Very large data\n- ❌ Need advanced features\n\n## Advantages\n\n✅ No setup required\n✅ Cross-platform\n✅ Public domain (free)\n✅ Reliable and fast\n✅ Great for prototyping\n✅ Entire DB in one file\n\n## Limitations\n\n❌ Limited concurrent writes\n❌ No user management\n❌ No network access (file-only)\n❌ Some SQL features missing",
      "codeExample": "// Complete SQLite example: Todo app backend\n\nimport express from 'express';\nimport sqlite3 from 'sqlite3';\nimport { open } from 'sqlite';\n\nconst app = express();\napp.use(express.json());\n\n// Initialize database\nconst db = await open({\n  filename: './todos.db',\n  driver: sqlite3.Database\n});\n\n// Create table\nawait db.exec(`\n  CREATE TABLE IF NOT EXISTS todos (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    text TEXT NOT NULL,\n    completed BOOLEAN DEFAULT 0,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n  )\n`);\n\n// API Routes\n\n// Get all todos\napp.get('/api/todos', async (req, res) => {\n  const todos = await db.all('SELECT * FROM todos ORDER BY created_at DESC');\n  res.json(todos);\n});\n\n// Create todo\napp.post('/api/todos', async (req, res) => {\n  const { text } = req.body;\n  const result = await db.run(\n    'INSERT INTO todos (text) VALUES (?)',\n    text\n  );\n  const todo = await db.get('SELECT * FROM todos WHERE id = ?', result.lastID);\n  res.json(todo);\n});\n\n// Toggle completed\napp.patch('/api/todos/:id', async (req, res) => {\n  const { id } = req.params;\n  await db.run(\n    'UPDATE todos SET completed = NOT completed WHERE id = ?',\n    id\n  );\n  const todo = await db.get('SELECT * FROM todos WHERE id = ?', id);\n  res.json(todo);\n});\n\n// Delete todo\napp.delete('/api/todos/:id', async (req, res) => {\n  await db.run('DELETE FROM todos WHERE id = ?', req.params.id);\n  res.json({ success: true });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n  console.log('Database: todos.db');\n});"
    },
    {
      "id": "postgres-mysql",
      "moduleId": "databases-data",
      "title": "PostgreSQL & MySQL",
      "order": 3,
      "difficulty": "beginner",
      "content": "# Essential to know\n- PostgreSQL & MySQL = Popular open-source SQL databases\n- Both are client-server (run as separate process)\n- PostgreSQL is more feature-rich, MySQL is simpler\n- Both great for production applications\n\n---\n\n# PostgreSQL & MySQL: Production Databases\n\n## PostgreSQL\n\n**\"The world's most advanced open source database\"**\n\n**Strengths:**\n- ✅ Feature-rich (JSON, arrays, full-text search)\n- ✅ Standards-compliant\n- ✅ Advanced data types\n- ✅ Better for complex queries\n- ✅ ACID compliant\n- ✅ Great for data integrity\n\n**Use cases:**\n- Enterprise applications\n- Geospatial data (PostGIS)\n- Data warehousing\n- Complex business logic\n\n**Syntax:**\n```sql\n-- JSON support\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  name TEXT,\n  metadata JSONB\n);\n\nSELECT * FROM users WHERE metadata->>'role' = 'admin';\n\n-- Arrays\nCREATE TABLE posts (\n  id SERIAL PRIMARY KEY,\n  title TEXT,\n  tags TEXT[]\n);\n\nSELECT * FROM posts WHERE 'javascript' = ANY(tags);\n```\n\n## MySQL\n\n**\"The world's most popular open source database\"**\n\n**Strengths:**\n- ✅ Easy to learn\n- ✅ Fast for read-heavy workloads\n- ✅ Great documentation\n- ✅ Wide hosting support\n- ✅ Simpler administration\n\n**Use cases:**\n- Web applications\n- WordPress, Drupal\n- E-commerce\n- Startups (MVP)\n\n**Syntax:**\n```sql\n-- Auto-increment\nCREATE TABLE users (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100) UNIQUE\n);\n\n-- Insert\nINSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');\n\n-- Query\nSELECT * FROM users WHERE name LIKE 'A%';\n```\n\n## PostgreSQL vs MySQL\n\n**PostgreSQL:**\n- More SQL features\n- Better for complex queries\n- JSON support\n- Full ACID compliance\n- Extensible (plugins)\n- Steeper learning curve\n\n**MySQL:**\n- Easier to learn\n- Faster for simple queries\n- More hosting options\n- Better for read-heavy\n- Simpler setup\n- Less strict\n\n## Connection Strings\n\n**PostgreSQL:**\n```\npostgresql://user:password@localhost:5432/mydb\n```\n\n**MySQL:**\n```\nmysql://user:password@localhost:3306/mydb\n```\n\n## When to Use Which?\n\n**Use PostgreSQL:**\n- ✅ Complex queries\n- ✅ Need advanced features (JSON, arrays, etc.)\n- ✅ Data integrity critical\n- ✅ Analytics/reporting\n- ✅ Geospatial data\n\n**Use MySQL:**\n- ✅ Simple CRUD operations\n- ✅ Read-heavy workloads\n- ✅ Rapid development\n- ✅ Shared hosting\n- ✅ WordPress/CMS\n\n**Both are great for:**\n- Web applications\n- APIs\n- E-commerce\n- SaaS products\n\n## Cloud Options\n\n**PostgreSQL:**\n- Amazon RDS\n- Google Cloud SQL\n- Azure Database\n- Heroku Postgres\n- Supabase (PostgreSQL + tools)\n\n**MySQL:**\n- Amazon RDS\n- Google Cloud SQL\n- Azure Database\n- PlanetScale\n\n## Hosted vs Self-Hosted\n\n**Hosted (managed):**\n- ✅ No maintenance\n- ✅ Auto backups\n- ✅ Scaling handled\n- ❌ More expensive\n- ❌ Less control\n\n**Self-Hosted:**\n- ✅ Full control\n- ✅ Cheaper\n- ❌ You manage backups\n- ❌ You handle scaling",
      "codeExample": "// PostgreSQL example with node-postgres\n\nimport pg from 'pg';\nconst { Pool } = pg;\n\nconst pool = new Pool({\n  host: 'localhost',\n  port: 5432,\n  database: 'mydb',\n  user: 'postgres',\n  password: 'password'\n});\n\n// Query\nconst result = await pool.query(\n  'SELECT * FROM users WHERE age > $1',\n  [18]\n);\nconsole.log(result.rows);\n\n// Transaction\nconst client = await pool.connect();\ntry {\n  await client.query('BEGIN');\n  await client.query('INSERT INTO users (name) VALUES ($1)', ['Alice']);\n  await client.query('INSERT INTO logs (action) VALUES ($1)', ['user_created']);\n  await client.query('COMMIT');\n} catch (e) {\n  await client.query('ROLLBACK');\n  throw e;\n} finally {\n  client.release();\n}\n\n// ――――――――――――――――――――――――――――――――――――\n\n// MySQL example with mysql2\n\nimport mysql from 'mysql2/promise';\n\nconst connection = await mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'mydb'\n});\n\n// Query\nconst [rows] = await connection.execute(\n  'SELECT * FROM users WHERE age > ?',\n  [18]\n);\nconsole.log(rows);\n\n// Insert\nconst [result] = await connection.execute(\n  'INSERT INTO users (name, email) VALUES (?, ?)',\n  ['Alice', 'alice@example.com']\n);\nconsole.log('Inserted ID:', result.insertId);"
    },
    {
      "id": "mongodb-nosql",
      "moduleId": "databases-data",
      "title": "MongoDB: Document Database",
      "order": 4,
      "difficulty": "beginner",
      "content": "# Essential to know\n- MongoDB = Document-oriented NoSQL database\n- Stores data as JSON-like documents (BSON)\n- No fixed schema (flexible structure)\n- Great for rapid development and scaling\n\n---\n\n# MongoDB: Flexible Documents\n\n## What is MongoDB?\n\nMongoDB stores data as **documents** (like JSON objects).\n\n**SQL Table:**\n```\nid | name  | email\n---|-------|-------\n1  | Alice | alice@example.com\n```\n\n**MongoDB Collection:**\n```json\n{\n  \"_id\": \"507f1f77bcf86cd799439011\",\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\",\n  \"hobbies\": [\"coding\", \"gaming\"],\n  \"address\": {\n    \"city\": \"Paris\",\n    \"country\": \"France\"\n  }\n}\n```\n\nNested data, arrays - no problem!\n\n## Key Concepts\n\n**Database** → **Collections** → **Documents**\n\n```\nmydb (database)\n├─ users (collection)\n│  ├─ { _id: 1, name: \"Alice\" }\n│  └─ { _id: 2, name: \"Bob\", age: 30 }\n└─ posts (collection)\n   └─ { _id: 1, title: \"Hello\" }\n```\n\n## CRUD Operations\n\n**Create:**\n```javascript\n// Insert one\nawait db.collection('users').insertOne({\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 25\n});\n\n// Insert many\nawait db.collection('users').insertMany([\n  { name: 'Bob', age: 30 },\n  { name: 'Charlie', age: 35 }\n]);\n```\n\n**Read:**\n```javascript\n// Find all\nconst users = await db.collection('users').find().toArray();\n\n// Find one\nconst user = await db.collection('users').findOne({ name: 'Alice' });\n\n// Find with filter\nconst adults = await db.collection('users').find({ age: { $gte: 18 } }).toArray();\n\n// Find with projection (select fields)\nconst names = await db.collection('users')\n  .find({}, { projection: { name: 1, _id: 0 } })\n  .toArray();\n```\n\n**Update:**\n```javascript\n// Update one\nawait db.collection('users').updateOne(\n  { name: 'Alice' },\n  { $set: { age: 26 } }\n);\n\n// Update many\nawait db.collection('users').updateMany(\n  { age: { $lt: 18 } },\n  { $set: { minor: true } }\n);\n\n// Increment\nawait db.collection('posts').updateOne(\n  { _id: postId },\n  { $inc: { views: 1 } }\n);\n```\n\n**Delete:**\n```javascript\n// Delete one\nawait db.collection('users').deleteOne({ name: 'Alice' });\n\n// Delete many\nawait db.collection('users').deleteMany({ age: { $lt: 18 } });\n```\n\n## Query Operators\n\n```javascript\n// Comparison\n{ age: { $gt: 18 } }         // greater than\n{ age: { $gte: 18 } }        // greater than or equal\n{ age: { $lt: 30 } }         // less than\n{ age: { $ne: 25 } }         // not equal\n{ age: { $in: [25, 30] } }   // in array\n\n// Logical\n{ $and: [{ age: { $gte: 18 } }, { age: { $lt: 30 } }] }\n{ $or: [{ name: 'Alice' }, { name: 'Bob' }] }\n\n// Array\n{ tags: { $all: ['javascript', 'react'] } }  // has all\n{ tags: 'javascript' }                       // has element\n\n// Exists\n{ email: { $exists: true } }\n```\n\n## Flexible Schema\n\n**Documents in same collection can differ:**\n```json\n// User 1\n{ \"name\": \"Alice\", \"email\": \"alice@example.com\" }\n\n// User 2 (different fields!)\n{ \"name\": \"Bob\", \"age\": 30, \"hobbies\": [\"gaming\"] }\n```\n\nNo schema enforcement!\n\n## Embedded vs Referenced\n\n**Embedded (denormalized):**\n```json\n{\n  \"_id\": 1,\n  \"name\": \"Alice\",\n  \"posts\": [\n    { \"title\": \"Post 1\", \"date\": \"2024-01-01\" },\n    { \"title\": \"Post 2\", \"date\": \"2024-01-02\" }\n  ]\n}\n```\nEverything in one document!\n\n**Referenced (normalized):**\n```json\n// users\n{ \"_id\": 1, \"name\": \"Alice\" }\n\n// posts\n{ \"_id\": 100, \"userId\": 1, \"title\": \"Post 1\" }\n{ \"_id\": 101, \"userId\": 1, \"title\": \"Post 2\" }\n```\nSeparate collections, manual joins.\n\n## Pros & Cons\n\n**✅ Pros:**\n- Flexible schema\n- Fast for simple queries\n- Scales horizontally\n- JSON-native\n- Easy to get started\n\n**❌ Cons:**\n- No JOINs (manual)\n- Weaker consistency\n- No transactions (older versions)\n- Can waste space\n\n## When to Use MongoDB\n\n**Great for:**\n- ✅ Rapid prototyping\n- ✅ Evolving data models\n- ✅ Content management\n- ✅ Real-time analytics\n- ✅ IoT data\n- ✅ Catalogs (products)\n\n**Not ideal for:**\n- ❌ Complex transactions\n- ❌ Heavy relational data\n- ❌ Banking systems",
      "codeExample": "// Complete MongoDB example with Mongoose\n\nimport mongoose from 'mongoose';\n\n// Connect\nawait mongoose.connect('mongodb://localhost:27017/mydb');\n\n// Define schema (optional but recommended)\nconst userSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  email: { type: String, unique: true },\n  age: Number,\n  posts: [{\n    title: String,\n    content: String,\n    createdAt: { type: Date, default: Date.now }\n  }]\n});\n\nconst User = mongoose.model('User', userSchema);\n\n// Create\nconst user = await User.create({\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 25\n});\n\n// Find\nconst users = await User.find({ age: { $gte: 18 } });\nconst alice = await User.findOne({ name: 'Alice' });\n\n// Update\nawait User.updateOne(\n  { name: 'Alice' },\n  { $set: { age: 26 }, $push: { posts: { title: 'New Post' } } }\n);\n\n// Delete\nawait User.deleteOne({ name: 'Alice' });\n\n// ――――――――――――――――――――――――――――――――――――\n\n// Native MongoDB driver (no Mongoose)\n\nimport { MongoClient } from 'mongodb';\n\nconst client = new MongoClient('mongodb://localhost:27017');\nawait client.connect();\n\nconst db = client.db('mydb');\nconst users = db.collection('users');\n\n// Insert\nawait users.insertOne({ name: 'Alice', age: 25 });\n\n// Find\nconst allUsers = await users.find({}).toArray();\nconst adult = await users.findOne({ age: { $gte: 18 } });\n\n// Aggregate (complex queries)\nconst stats = await users.aggregate([\n  { $match: { age: { $gte: 18 } } },\n  { $group: { _id: null, avgAge: { $avg: '$age' } } }\n]).toArray();"
    },
    {
      "id": "orms-explained",
      "moduleId": "databases-data",
      "title": "ORMs: Simplifying Databases",
      "order": 5,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- ORM = Object-Relational Mapping (work with objects, not SQL)\n- Popular ORMs: Prisma, Drizzle, TypeORM, Sequelize\n- Trade-off: easier to use but less control\n- Most modern apps use an ORM\n\n---\n\n# ORMs: Objects Instead of SQL\n\n## What is an ORM?\n\n**ORM** lets you interact with databases using **objects** instead of SQL.\n\n**Without ORM (raw SQL):**\n```javascript\nconst result = await db.query(\n  'SELECT * FROM users WHERE age > $1',\n  [18]\n);\nconst users = result.rows;\n```\n\n**With ORM (Prisma):**\n```javascript\nconst users = await prisma.user.findMany({\n  where: { age: { gt: 18 } }\n});\n```\n\nNo SQL needed!\n\n## Why Use an ORM?\n\n**1. Type Safety (TypeScript)**\n```typescript\n// Autocomplete!\nconst user = await prisma.user.findUnique({\n  where: { id: 1 }\n});\n\nuser.name // ✅ Known property\nuser.age  // ✅ Known property\nuser.xyz  // ❌ Error: Property doesn't exist\n```\n\n**2. Database Agnostic**\nSwitch from SQLite → PostgreSQL with minimal changes.\n\n**3. Migrations**\nAutomatic schema updates.\n\n**4. Relations**\nEasy to work with related data.\n\n## Popular ORMs\n\n### Prisma (Modern, TypeScript-first)\n\n**Schema:**\n```prisma\nmodel User {\n  id    Int     @id @default(autoincrement())\n  name  String\n  email String  @unique\n  posts Post[]\n}\n\nmodel Post {\n  id      Int    @id @default(autoincrement())\n  title   String\n  user    User   @relation(fields: [userId], references: [id])\n  userId  Int\n}\n```\n\n**Usage:**\n```typescript\n// Create with relation\nconst user = await prisma.user.create({\n  data: {\n    name: 'Alice',\n    email: 'alice@example.com',\n    posts: {\n      create: [\n        { title: 'First Post' },\n        { title: 'Second Post' }\n      ]\n    }\n  }\n});\n\n// Query with relations\nconst userWithPosts = await prisma.user.findUnique({\n  where: { id: 1 },\n  include: { posts: true }\n});\n```\n\n### Drizzle (SQL-like, type-safe)\n\n**Schema:**\n```typescript\nimport { pgTable, serial, text } from 'drizzle-orm/pg-core';\n\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n  email: text('email').unique()\n});\n```\n\n**Usage:**\n```typescript\nimport { db } from './db';\nimport { users } from './schema';\nimport { eq } from 'drizzle-orm';\n\n// Insert\nawait db.insert(users).values({ name: 'Alice', email: 'alice@example.com' });\n\n// Select\nconst allUsers = await db.select().from(users);\nconst alice = await db.select().from(users).where(eq(users.name, 'Alice'));\n```\n\n### Sequelize (Established, works with many DBs)\n\n```javascript\nconst User = sequelize.define('User', {\n  name: DataTypes.STRING,\n  email: DataTypes.STRING\n});\n\nconst user = await User.create({ name: 'Alice', email: 'alice@example.com' });\nconst users = await User.findAll({ where: { age: { [Op.gt]: 18 } } });\n```\n\n## Migrations\n\n**ORMs help manage schema changes:**\n\n**Prisma:**\n```bash\n# Create migration\nnpx prisma migrate dev --name add_user_age\n\n# Apply migrations\nnpx prisma migrate deploy\n```\n\n**Drizzle:**\n```bash\n# Generate migration\ndrizzle-kit generate:pg\n\n# Run migration\ndrizzle-kit push:pg\n```\n\nVersioned schema changes!\n\n## Pros & Cons\n\n**✅ Pros:**\n- Type safety\n- Less SQL to write\n- Easier to learn\n- Auto-generated queries\n- Migrations handled\n- Database abstraction\n\n**❌ Cons:**\n- Less control\n- Generated queries can be slow\n- Learning curve (ORM-specific)\n- Harder to optimize\n- Abstraction leak (need SQL knowledge anyway)\n\n## When to Use an ORM\n\n**Use ORM:**\n- ✅ TypeScript projects\n- ✅ Rapid development\n- ✅ Team unfamiliar with SQL\n- ✅ Standard CRUD operations\n- ✅ Want type safety\n\n**Skip ORM (use raw SQL):**\n- ❌ Complex queries\n- ❌ Performance-critical\n- ❌ Need full SQL control\n- ❌ Small project\n\n## ORM Comparison\n\n**Prisma:**\n- Best TypeScript support\n- Auto-generated client\n- Great DX\n- Opinionated\n\n**Drizzle:**\n- SQL-like syntax\n- Very fast\n- Lightweight\n- More control\n\n**TypeORM:**\n- Decorators (@Entity)\n- Active Record pattern\n- Established\n\n**Sequelize:**\n- Works with many DBs\n- Large community\n- More verbose",
      "codeExample": "// Prisma complete example\n\n// schema.prisma\n/*\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  posts     Post[]\n  createdAt DateTime @default(now())\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  author    User     @relation(fields: [authorId], references: [id])\n  authorId  Int\n}\n*/\n\n// Using Prisma\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\n// Create user with posts\nconst user = await prisma.user.create({\n  data: {\n    name: 'Alice',\n    email: 'alice@example.com',\n    posts: {\n      create: [\n        { title: 'Hello World', published: true },\n        { title: 'Draft Post', published: false }\n      ]\n    }\n  },\n  include: { posts: true } // Include related posts\n});\n\n// Query with relations\nconst usersWithPosts = await prisma.user.findMany({\n  where: {\n    posts: {\n      some: { published: true } // Has published posts\n    }\n  },\n  include: {\n    posts: {\n      where: { published: true },\n      orderBy: { createdAt: 'desc' }\n    }\n  }\n});\n\n// Update\nawait prisma.post.update({\n  where: { id: 1 },\n  data: { published: true }\n});\n\n// Delete\nawait prisma.user.delete({ where: { id: 1 } });\n\n// Transaction\nawait prisma.$transaction(async (tx) => {\n  const user = await tx.user.create({ data: { name: 'Bob', email: 'bob@example.com' } });\n  await tx.post.create({ data: { title: 'Post', authorId: user.id } });\n});\n\n// Raw SQL (when needed)\nconst result = await prisma.$queryRaw`\n  SELECT * FROM users WHERE age > ${18}\n`;"
    }
  ],
  "exercises": [
    {
      "id": "db-ex-1",
      "lessonId": "sql-vs-nosql",
      "moduleId": "databases-data",
      "title": "SQL or NoSQL?",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "You're building a banking application with transactions. Which database?",
          "options": ["MongoDB (NoSQL)", "PostgreSQL (SQL)", "Redis (NoSQL)", "Either works"],
          "correctAnswer": 1,
          "explanation": "Banking needs ACID transactions and data integrity. SQL databases like PostgreSQL are designed for this."
        },
        {
          "question": "You're building a social media feed with evolving post types. Which database?",
          "options": ["PostgreSQL (SQL)", "MongoDB (NoSQL)", "SQLite", "Must use both"],
          "correctAnswer": 1,
          "explanation": "Social feeds have evolving schemas (posts, images, videos, polls). NoSQL's flexible schema fits well."
        },
        {
          "question": "What's the main advantage of SQL databases?",
          "options": ["Flexible schema", "Horizontal scaling", "ACID transactions & data integrity", "Faster always"],
          "correctAnswer": 2,
          "explanation": "SQL databases excel at ACID compliance and maintaining data integrity through relations."
        },
        {
          "question": "What's the main advantage of NoSQL databases?",
          "options": ["Better JOINs", "Flexible schema & horizontal scaling", "More reliable", "Easier to learn"],
          "correctAnswer": 1,
          "explanation": "NoSQL databases allow flexible schemas and scale horizontally across many servers."
        }
      ]
    },
    {
      "id": "db-ex-2",
      "lessonId": "sqlite-intro",
      "moduleId": "databases-data",
      "title": "When to Use SQLite",
      "difficulty": "easy",
      "type": "quiz",
      "questions": [
        {
          "question": "What makes SQLite different from PostgreSQL?",
          "options": ["SQLite is faster", "SQLite is file-based (no server)", "SQLite has more features", "SQLite scales better"],
          "correctAnswer": 1,
          "explanation": "SQLite is file-based - no separate server process needed. Perfect for local apps."
        },
        {
          "question": "Best use case for SQLite?",
          "options": ["High-traffic website", "Mobile app", "Multi-user application", "Data warehouse"],
          "correctAnswer": 1,
          "explanation": "SQLite is perfect for mobile apps - lightweight, no server, entire DB in one file."
        },
        {
          "question": "SQLite limitation?",
          "options": ["No SQL support", "Can't handle any writes", "Limited concurrent writes", "No transactions"],
          "correctAnswer": 2,
          "explanation": "SQLite handles one write at a time. For high concurrency, use PostgreSQL/MySQL."
        }
      ]
    },
    {
      "id": "db-ex-3",
      "lessonId": "postgres-mysql",
      "moduleId": "databases-data",
      "title": "PostgreSQL vs MySQL",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "You need to store JSON data with complex queries. Which database?",
          "options": ["MySQL", "PostgreSQL", "Either works the same", "SQLite"],
          "correctAnswer": 1,
          "explanation": "PostgreSQL has excellent JSONB support with indexing and querying capabilities."
        },
        {
          "question": "You're building a WordPress site. Which is more common?",
          "options": ["PostgreSQL", "MySQL", "MongoDB", "SQLite"],
          "correctAnswer": 1,
          "explanation": "WordPress traditionally uses MySQL. It's simpler and has wider hosting support."
        },
        {
          "question": "Main advantage of PostgreSQL over MySQL?",
          "options": ["Easier to learn", "More hosting options", "More advanced features", "Faster always"],
          "correctAnswer": 2,
          "explanation": "PostgreSQL has more advanced features like JSONB, arrays, full-text search, and better standards compliance."
        }
      ]
    },
    {
      "id": "db-ex-4",
      "lessonId": "mongodb-nosql",
      "moduleId": "databases-data",
      "title": "MongoDB Concepts",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "How does MongoDB store data?",
          "options": ["Tables and rows", "JSON-like documents", "Key-value pairs", "Graphs"],
          "correctAnswer": 1,
          "explanation": "MongoDB stores data as BSON documents (binary JSON), allowing nested structures."
        },
        {
          "question": "Can documents in the same MongoDB collection have different fields?",
          "options": ["No, schema is enforced", "Yes, schema is flexible", "Only with migrations", "Only in development"],
          "correctAnswer": 1,
          "explanation": "MongoDB has flexible schema - documents in the same collection can have different structures."
        },
        {
          "question": "MongoDB is NOT ideal for:",
          "options": ["Rapid prototyping", "Complex multi-table transactions", "Content management", "Catalogs"],
          "correctAnswer": 1,
          "explanation": "MongoDB lacks traditional JOINs and has weaker transaction support than SQL databases."
        }
      ]
    },
    {
      "id": "db-ex-5",
      "lessonId": "orms-explained",
      "moduleId": "databases-data",
      "title": "Understanding ORMs",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "What does ORM stand for?",
          "options": ["Object Resource Manager", "Object-Relational Mapping", "Online Request Method", "Operational Record Model"],
          "correctAnswer": 1,
          "explanation": "ORM = Object-Relational Mapping, converting between objects and database tables."
        },
        {
          "question": "Main benefit of using an ORM?",
          "options": ["Always faster", "Type safety and easier to use", "Smaller bundle size", "Better security"],
          "correctAnswer": 1,
          "explanation": "ORMs provide type safety (in TypeScript) and let you work with objects instead of SQL."
        },
        {
          "question": "When might you skip using an ORM?",
          "options": ["TypeScript project", "Need complex, optimized queries", "Team project", "Rapid prototyping"],
          "correctAnswer": 1,
          "explanation": "For complex queries needing optimization, raw SQL often gives more control and better performance."
        }
      ]
    }
  ]
}
