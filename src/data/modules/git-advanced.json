{
  "module": {
    "id": "git-advanced",
    "title": "Git Advanced & Vibe Coding",
    "description": "Master git stash, reset, advanced checkout, and best practices for stress-free development",
    "icon": "Zap",
    "requiredXp": 600,
    "color": "from-pink-400 to-rose-600",
    "courseId": "git"
  },
  "lessons": [
    {
      "id": "git-stash",
      "moduleId": "git-advanced",
      "title": "Git Stash - Temporary Save",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- `git stash` temporarily saves your uncommitted modifications\n- `git stash pop` retrieves and removes the stash\n- `git stash list` shows all stashes\n- `git stash apply` retrieves without removing the stash\n- Perfect when you need to switch branches quickly\n\n---\n\n# Git Stash - Temporary Save\n\nStash is like a stack where you pile your changes temporarily. Imagine you're in the middle of a feature but need to fix an urgent bug on main - stash saves your life!\n\n## Why Use Stash?\n\n**Common scenarios:**\n1. **Urgent branch switch** - You need to switch but your changes aren't ready\n2. **Pull with conflicts** - You want to pull but have local modifications\n3. **Experimentation** - You want to test something without losing current work\n4. **Code review** - You need to review code but are in the middle of development\n\n## Basic Commands\n\n### Stash your changes\n\n```bash\n# Stash everything (staged and unstaged modifications)\ngit stash\n\n# Stash with a descriptive message\ngit stash push -m \"WIP: authentication in progress\"\n\n# Stash only staged files\ngit stash --staged\n\n# Stash while keeping staged files (unstash only)\ngit stash --keep-index\n```\n\n### View your stashes\n\n```bash\n# List all stashes\ngit stash list\n\n# Output:\n# stash@{0}: WIP on feature-login: a1b2c3d Add login form\n# stash@{1}: On main: temp fix for header\n```\n\n### Retrieve a stash\n\n```bash\n# Retrieve last stash and delete it\ngit stash pop\n\n# Retrieve without deleting\ngit stash apply\n\n# Retrieve a specific stash\ngit stash apply stash@{1}\n\n# Retrieve into a new branch\ngit stash branch new-branch stash@{0}\n```\n\n### Manage stashes\n\n```bash\n# Delete last stash\ngit stash drop\n\n# Delete a specific stash\ngit stash drop stash@{2}\n\n# Delete all stashes\ngit stash clear\n```\n\n## Practical Examples\n\n### Scenario 1: Urgent Bug\n\n```bash\n# You're working on feature-auth\ngit status\n# M login.js\n# M auth.css\n\n# Urgent bug on main\ngit stash push -m \"WIP: auth form\"\ngit checkout main\ngit checkout -b hotfix/critical-bug\n\n# Fix bug...\ngit add .\ngit commit -m \"fix: correct header bug\"\ngit push\n\n# Return to feature\ngit checkout feature-auth\ngit stash pop\n```\n\n### Scenario 2: Pull with Local Changes\n\n```bash\n# You have local modifications\ngit status\n# M app.js\n\n# Stash, pull, then restore\ngit stash\ngit pull origin main\ngit stash pop\n\n# If conflicts, resolve them\n```\n\n## Advanced Options\n\n### Partial Stash\n\n```bash\n# Stash specific files\ngit stash push -m \"WIP: API\" api.js utils.js\n\n# Stash with patch mode (interactive)\ngit stash push -p\n```\n\n### Stash Untracked Files\n\n```bash\n# Also stash untracked files\ngit stash -u\ngit stash --include-untracked\n\n# Also stash ignored files (!)\ngit stash -a\ngit stash --all\n```",
      "codeExample": "# Quick stash\ngit stash\n\n# Stash with message\ngit stash push -m \"WIP: refactoring auth\"\n\n# View stashes\ngit stash list\n\n# Retrieve and delete\ngit stash pop\n\n# Retrieve without deleting\ngit stash apply\n\n# Include untracked files\ngit stash -u"
    },
    {
      "id": "git-reset",
      "moduleId": "git-advanced",
      "title": "Git Reset - Undoing Commits",
      "order": 2,
      "difficulty": "advanced",
      "content": "# Essential to know\n- `git reset` moves HEAD and changes history\n- `--soft`: keeps modifications staged\n- `--mixed` (default): keeps modifications unstaged\n- `--hard`: deletes EVERYTHING (danger!)\n- Never use on pushed commits\n- Prefer `git revert` for shared history\n\n---\n\n# Git Reset - Undoing Commits\n\nGit reset is the ultimate tool for correcting commit mistakes. But be careful, it's a double-edged sword!\n\n## The Three Reset Modes\n\nImagine you want to go back 2 commits:\n\n```\nA---B---C---D (HEAD)\n        ‚Üë\n    You want to go back here\n```\n\n### 1. Soft Reset (--soft)\n\n```bash\ngit reset --soft HEAD~2\n```\n\n**What happens:**\n- HEAD goes back to commit C\n- Modifications from commits D and C are **staged** (ready to commit)\n- Your working directory is unchanged\n\n**Usage:** You want to redo your commits with better messages or better organization.\n\n### 2. Mixed Reset (--mixed, default)\n\n```bash\ngit reset HEAD~2\n# or explicitly\ngit reset --mixed HEAD~2\n```\n\n**What happens:**\n- HEAD goes back to commit C\n- Modifications are **unstaged** (modified but not staged)\n- Your working directory keeps the changes\n\n**Usage:** You want to reconsider which files to include in your commits.\n\n### 3. Hard Reset (--hard) ‚ö†Ô∏è DANGER\n\n```bash\ngit reset --hard HEAD~2\n```\n\n**What happens:**\n- HEAD goes back to commit C\n- **ALL modifications are LOST**\n- Your working directory is exactly at commit C\n\n**Usage:** You really want to erase everything and start from scratch.\n\n## ‚ö†Ô∏è GOLDEN RULE: Never reset --hard on pushed commits!\n\n```bash\n# DANGER - If you do this on already pushed commits:\ngit reset --hard HEAD~3\ngit push --force  # üíÄ You just destroyed others' work!\n```\n\n**If commits are pushed, use `git revert` instead!**\n\n## Practical Scenarios\n\n### Correct the last commit\n\n```bash\n# Forgot to add a file?\ngit add forgotten-file.js\ngit commit --amend -m \"Better message\"\n\n# Or with reset\ngit reset --soft HEAD~1\ngit add .\ngit commit -m \"New message\"\n```\n\n### Split a commit\n\n```bash\n# You committed everything at once (bad!)\ngit log --oneline\n# a1b2c3d Big messy commit\n\n# Go back but keep modifications\ngit reset HEAD~1\n\n# Now re-commit properly\ngit add auth.js\ngit commit -m \"feat: add authentication\"\n\ngit add tests/\ngit commit -m \"test: add auth tests\"\n```\n\n### Remove sensitive data\n\n```bash\n# Oops, you committed a password\ngit reset --hard HEAD~1  # Local only!\n\n# Better: use filter-branch or BFG Repo-Cleaner\n```\n\n## Unstage Files\n\n```bash\n# Unstage a specific file\ngit reset HEAD filename.txt\n\n# Unstage everything\ngit reset HEAD\n\n# Modern alternative\ngit restore --staged filename.txt\n```",
      "codeExample": "# Soft reset: undo commit, keep staged\ngit reset --soft HEAD~1\n\n# Mixed reset (default): undo commit, keep modifications unstaged\ngit reset HEAD~2\n\n# Hard reset: DELETE everything (danger!)\ngit reset --hard HEAD~1\n\n# Unstage a specific file\ngit reset HEAD filename.txt\n\n# View reflog to recover\ngit reflog"
    },
    {
      "id": "git-checkout-advanced",
      "moduleId": "git-advanced",
      "title": "Git Checkout Advanced",
      "order": 3,
      "difficulty": "advanced",
      "content": "# Essential to know\n- `git checkout` can restore files or switch branches\n- `git checkout -- file` restores a file to last commit\n- `git checkout commit -- file` restores a file to a specific commit\n- `git checkout -b branch commit` creates a branch from an old commit\n- Warning: checkout overwrites local modifications\n\n---\n\n# Git Checkout Advanced\n\nCheckout is a powerful command that does several things: switch branches, restore files, or even travel through time!\n\n## Restore a File\n\n### Restore to last commit\n\n```bash\n# You made modifications to app.js that you want to undo\ngit checkout -- app.js\n\n# Modern alternative\ngit restore app.js\n```\n\n‚ö†Ô∏è **Warning**: your local modifications are LOST!\n\n### Restore to a specific commit\n\n```bash\n# Get app.js version from commit abc1234\ngit checkout abc1234 -- app.js\n\n# File is restored and staged\ngit status\n# Changes to be committed:\n#   modified:   app.js\n\n# You can commit or modify\ngit commit -m \"Restore app.js to stable state\"\n```\n\n### Restore multiple files\n\n```bash\n# Restore an entire folder\ngit checkout abc1234 -- src/components/\n\n# Restore multiple files\ngit checkout HEAD -- package.json package-lock.json\n```\n\n## Time Travel\n\n### Checkout a specific commit (DETACHED HEAD)\n\n```bash\n# Checkout an old commit\ngit checkout abc1234\n\n# Message:\n# You are in 'detached HEAD' state...\n```\n\n**In DETACHED HEAD:**\n- You see code exactly as it was at that commit\n- You can look, test, compile\n- ‚ö†Ô∏è If you commit, they will be orphaned (lost if you switch branches)\n\n### Create a branch from an old commit\n\n```bash\n# Create a branch from an old commit\ngit checkout -b hotfix-v1 abc1234\n\n# Now you can work on this version\n# and merge later\n```\n\n## Restore vs Reset vs Checkout\n\n| Command | What it does | Risk |\n|---------|-------------|------|\n| `git restore file` | Restore file to last commit | Medium |\n| `git reset HEAD file` | Unstage file | Low |\n| `git checkout -- file` | Restore file (old syntax) | Medium |\n| `git reset --hard` | Erase everything | High üíÄ |\n\n## Practical Examples\n\n### Recover a deleted file\n\n```bash\n# Oops, you deleted config.js\ngit status\n# D config.js\n\n# Restore it\ngit checkout HEAD -- config.js\n```\n\n### Get an old file version\n\n```bash\n# See file history\ngit log --oneline -- config.js\n# a1b2c3d Update config\n# e4f5g6h Initial config\n\n# Get initial version\ngit checkout e4f5g6h -- config.js\ngit commit -m \"Revert config to initial version\"\n```\n\n### Test an old version\n\n```bash\n# Go back 5 commits\ngit checkout HEAD~5\n\n# Test, look...\n\n# Return to main\ngit checkout main\n```",
      "codeExample": "# Restore a file to last commit\ngit checkout -- app.js\n\n# Restore a file to a specific commit\ngit checkout abc1234 -- app.js\n\n# Checkout a commit (detached HEAD)\ngit checkout abc1234\n\n# Create branch from old commit\ngit checkout -b hotfix abc1234\n\n# Modern alternative\ngit switch feature-branch\ngit restore app.js"
    },
    {
      "id": "push-force",
      "moduleId": "git-advanced",
      "title": "Push Force - Usage and Dangers",
      "order": 4,
      "difficulty": "advanced",
      "content": "# Essential to know\n- `git push --force` overwrites remote history\n- **DANGER**: can destroy others' work\n- Prefer `--force-with-lease` for more safety\n- Never force push on shared main/master\n- Acceptable on personal branches not shared\n- Prefer `git revert` to correct errors on shared branches\n\n---\n\n# Push Force - Usage and Dangers\n\nForce push is often seen as Git's nuclear weapon. Used incorrectly, it can cause team nightmares.\n\n## Why Push Force Exists\n\n**Legitimate scenarios:**\n1. You rebased your feature branch and need to update remote\n2. You amended a commit and need to update\n3. You're working alone on a branch\n4. You really want to delete sensitive commits (passwords, API keys)\n\n## The Danger of Force Push\n\n```\nBefore force push on main:\n\nRemote:  A---B---C---D (main)\n                      ‚Üë\nAlice works here\n\nLocal (you):  A---B---C'---D' (main)\n                         ‚Üë\n                    You rebased\n\nAfter `git push --force`:\n\nRemote:  A---B---C'---D' (main)\n\nCommits C and D are LOST!\nAlice's work is erased!\n```\n\n## Force vs Force-with-lease\n\n### Classic Force Push (dangerous)\n\n```bash\ngit push --force\ngit push -f\n```\n\n**Problem:** Overwrites remote even if someone else pushed in the meantime.\n\n### Force-with-lease (safer)\n\n```bash\ngit push --force-with-lease\n```\n\n**Advantage:** Checks that no one pushed since your last fetch.\n- If someone pushed ‚Üí error and push refused\n- If everything OK ‚Üí push accepted\n\n## Golden Rules\n\n### ‚ùå NEVER force push on:\n- `main` / `master`\n- `develop`\n- Any branch others are working on\n\n### ‚úÖ Force push acceptable on:\n- Your personal feature branch (that no one else touches)\n- After rebasing your branch\n- To delete sensitive data\n\n## Safe Workflow\n\n```bash\n# Before force push, always:\n\n# 1. Fetch to see remote state\ngit fetch origin\n\n# 2. Check what you'll overwrite\ngit log origin/my-branch..my-branch\n\n# 3. If OK, force with lease\ngit push --force-with-lease\n```\n\n## Better Alternative: Revert\n\n```bash\n# Instead of force push on shared branch:\n\n# 1. Revert problematic commit\ngit revert abc1234\n\n# 2. Push normally (safe!)\ngit push\n\n# History is preserved, error is corrected\n```\n\n## If You Made a Mistake\n\n```bash\n# Oops, you force pushed on main!\n\n# 1. Don't panic\n# 2. Ask colleagues not to pull\n# 3. Find old commit with reflog\ngit reflog\n\n# 4. Restore main\ngit checkout main\ngit reset --hard abc1234  # Old commit\ngit push --force-with-lease\n\n# 5. Ask colleagues to reset their local main\n```",
      "codeExample": "# DANGER: Classic force push\ngit push --force\ngit push -f\n\n# SAFER: Force with lease\ngit push --force-with-lease\n\n# Safe workflow before force push\ngit fetch origin\ngit log origin/my-branch..my-branch\ngit push --force-with-lease\n\n# Alternative: revert instead of force\ngit revert HEAD\ngit push"
    },
    {
      "id": "vibe-coding-practices",
      "moduleId": "git-advanced",
      "title": "Vibe Coding Best Practices",
      "order": 5,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Commit often, push regularly\n- Clear and descriptive commit messages\n- One feature = one branch\n- Pull before pushing\n- Stash when you need to change context\n- Never commit directly on main\n- Review your code before committing\n\n---\n\n# Vibe Coding Best Practices\n\n\"Vibe coding\" is coding in the flow, calmly, without stress. Git is your ally for this!\n\n## The Perfect Workflow\n\n### 1. Before Starting\n\n```bash\n# Get up to date\ngit checkout main\ngit pull\n\n# Create your feature branch\ngit checkout -b feature/my-super-feature\n\n# Or with a descriptive name\ngit checkout -b feature/login-page-redesign\n```\n\n### 2. During Development\n\n**Golden rule: Commit early, commit often**\n\n```bash\n# ‚úÖ Good: small logical commits\ngit add src/auth.js\ngit commit -m \"feat: add email validation\"\n\ngit add src/auth.js\ngit commit -m \"feat: add password hashing\"\n\ngit add tests/\ngit commit -m \"test: add tests for auth\"\n\n# ‚ùå Bad: one big commit\ngit add .\ngit commit -m \"update\"\n```\n\n### 3. If You Need to Change Context\n\n```bash\n# You're in the middle of dev but an urgent bug arrives\ngit stash push -m \"WIP: auth in progress\"\ngit checkout main\ngit checkout -b hotfix/urgent-bug\n\n# Fix bug...\ngit add .\ngit commit -m \"fix: correct crash on login\"\ngit push\n\n# Return to your feature\ngit checkout feature/my-feature\ngit stash pop\n```\n\n### 4. Before Pushing\n\n```bash\n# Get up to date\ngit fetch origin\n\n# Check if there are changes\ngit log --oneline HEAD..origin/main\n\n# If yes, merge or rebase\ngit rebase origin/main\n# or\ngit merge origin/main\n\n# Resolve conflicts if necessary\n\n# Push\ngit push -u origin feature/my-feature\n```\n\n## Pro Commit Messages\n\n### Conventional Format\n\n```\n<type>: <short description>\n\n[optional body]\n```\n\n### Common types:\n\n- **feat**: New feature\n- **fix**: Bug fix\n- **docs**: Documentation\n- **style**: Formatting (no code change)\n- **refactor**: Code restructuring\n- **test**: Tests\n- **chore**: Maintenance\n\n### Examples:\n\n```bash\n# Good\ngit commit -m \"feat: add user authentication with JWT\"\ngit commit -m \"fix: correct header alignment on mobile\"\ngit commit -m \"refactor: extract validation logic\"\n\n# Bad\ngit commit -m \"update\"\ngit commit -m \"fix\"\ngit commit -m \"WIP\"\n```\n\n## Useful Aliases\n\n```bash\n# Add to ~/.gitconfig\n[alias]\n  st = status\n  co = checkout\n  br = branch\n  ci = commit\n  lg = log --oneline --graph --all\n  last = log -1 HEAD\n  unstage = reset HEAD --\n  discard = checkout --\n```\n\n## Checklist Before Committing\n\n- [ ] I reviewed my modifications (`git diff`)\n- [ ] I didn't commit sensitive files (.env, passwords)\n- [ ] My message is descriptive\n- [ ] Tests pass (if applicable)\n- [ ] I committed only what's necessary\n\n## Typical Day\n\n```bash\n# Morning\ngit checkout main && git pull\ngit checkout -b feature/task-of-the-day\n\n# During the day\ngit add .\ngit commit -m \"feat: implement X\"\n\n# Before leaving\ngit fetch origin\ngit rebase origin/main\ngit push -u origin feature/task-of-the-day\n```",
      "codeExample": "# Daily workflow\ngit checkout main && git pull\ngit checkout -b feature/name-feature\n\n# Frequent commits\ngit add file.js\ngit commit -m \"feat: clear description\"\n\n# Stash if interruption\ngit stash push -m \"WIP\"\ngit checkout main\n\n# Before push\ngit fetch origin\ngit rebase origin/main\ngit push -u origin feature/name-feature\n\n# Useful aliases\ngit config --global alias.st status\ngit config --global alias.lg \"log --oneline --graph\""
    }
  ],
  "exercises": [
    {
      "id": "advanced-ex-1",
      "type": "git-scenario",
      "lessonId": "git-stash",
      "moduleId": "git-advanced",
      "title": "Stash Interruption",
      "difficulty": "easy",
      "story": "You're modifying login.js on the feature-auth branch, but an urgent bug needs to be fixed on main. Stash your changes, switch to main, then retrieve your work.",
      "hints": [
        "Use 'git stash push -m \"WIP: auth\"' to stash with a message",
        "Switch to main with 'git checkout main'",
        "Retrieve stash with 'git stash pop'"
      ],
      "initialState": {
        "files": [
          { "name": "index.html", "status": "committed" },
          { "name": "login.js", "status": "modified" }
        ],
        "commits": [{ "message": "Initial commit", "files": ["index.html", "login.js"] }],
        "branches": ["main", "feature-auth"],
        "currentBranch": "feature-auth",
        "isInitialized": true
      },
      "objectives": [
        { "description": "Stash modifications", "check": { "type": "fileStatus", "file": "login.js", "status": "committed" } },
        { "description": "Switch to main", "check": { "type": "currentBranch", "value": "main" } },
        { "description": "Retrieve stash on feature-auth", "check": { "type": "currentBranch", "value": "feature-auth" } }
      ]
    },
    {
      "id": "advanced-ex-2",
      "type": "git-scenario",
      "lessonId": "git-reset",
      "moduleId": "git-advanced",
      "title": "Soft Reset to Redo",
      "difficulty": "medium",
      "story": "You made 2 commits on your feature branch, but want to redo them with better messages. Use reset --soft to go back while keeping your modifications.",
      "hints": [
        "Use 'git reset --soft HEAD~2' to go back 2 commits",
        "Your modifications will be staged, ready to be recommitted",
        "Redo your commits with better messages"
      ],
      "initialState": {
        "files": [
          { "name": "app.js", "status": "committed" },
          { "name": "utils.js", "status": "committed" }
        ],
        "commits": [
          { "message": "wip", "files": ["app.js"] },
          { "message": "fix", "files": ["utils.js"] },
          { "message": "Initial commit", "files": ["app.js", "utils.js"] }
        ],
        "branches": ["main", "feature"],
        "currentBranch": "feature",
        "isInitialized": true
      },
      "objectives": [
        { "description": "Do a soft reset of 2 commits", "check": { "type": "minCommits", "value": 1 } },
        { "description": "Create at least 2 new clean commits", "check": { "type": "minCommits", "value": 3 } }
      ]
    },
    {
      "id": "advanced-ex-3",
      "type": "git-scenario",
      "lessonId": "git-reset",
      "moduleId": "git-advanced",
      "title": "Unstage a File",
      "difficulty": "easy",
      "story": "You accidentally added config.env (sensitive file) to the staging area with other files. Unstage config.env but keep the other files ready to be committed.",
      "hints": [
        "Use 'git reset HEAD config.env' to unstage a specific file",
        "Other files will remain staged",
        "Then commit the remaining files"
      ],
      "initialState": {
        "files": [
          { "name": "app.js", "status": "staged" },
          { "name": "config.env", "status": "staged" },
          { "name": "README.md", "status": "staged" }
        ],
        "commits": [{ "message": "Initial commit", "files": ["app.js", "config.env", "README.md"] }],
        "branches": ["main"],
        "currentBranch": "main",
        "isInitialized": true
      },
      "objectives": [
        { "description": "Unstage config.env", "check": { "type": "fileStatus", "file": "config.env", "status": "modified" } },
        { "description": "Commit remaining files", "check": { "type": "minCommits", "value": 2 } },
        { "description": "config.env is not in the new commit", "check": { "type": "fileStatus", "file": "config.env", "status": "modified" } }
      ]
    },
    {
      "id": "advanced-ex-4",
      "type": "git-scenario",
      "lessonId": "git-checkout-advanced",
      "moduleId": "git-advanced",
      "title": "Restore an Old Version",
      "difficulty": "medium",
      "story": "The app.js file was broken by recent commits. You want to restore the version from commit abc1234. Use checkout to retrieve this specific version.",
      "hints": [
        "Use 'git checkout abc1234 -- app.js' to restore to a specific commit",
        "The file will be automatically staged",
        "Then commit with an appropriate message"
      ],
      "initialState": {
        "files": [
          { "name": "app.js", "status": "modified" },
          { "name": "index.html", "status": "committed" }
        ],
        "commits": [
          { "message": "BREAK: break app.js", "files": ["app.js"] },
          { "message": "Initial commit", "files": ["app.js", "index.html"] }
        ],
        "branches": ["main"],
        "currentBranch": "main",
        "isInitialized": true
      },
      "objectives": [
        { "description": "Restore app.js to initial commit", "check": { "type": "fileStatus", "file": "app.js", "status": "staged" } },
        { "description": "Commit the restoration", "check": { "type": "minCommits", "value": 3 } }
      ]
    },
    {
      "id": "advanced-ex-5",
      "type": "quiz",
      "lessonId": "git-stash",
      "moduleId": "git-advanced",
      "title": "Git Stash Quiz",
      "difficulty": "easy",
      "questions": [
        {
          "question": "Which command retrieves a stash and removes it from the stack?",
          "options": [
            "git stash apply",
            "git stash pop",
            "git stash get",
            "git stash restore"
          ],
          "correctAnswer": 1,
          "explanation": "git stash pop retrieves the last stash and automatically removes it from the stack. git stash apply retrieves the stash but keeps it in the stack."
        },
        {
          "question": "How to stash with a descriptive message?",
          "options": [
            "git stash -m \"message\"",
            "git stash push -m \"message\"",
            "git stash message \"message\"",
            "git stash --msg \"message\""
          ],
          "correctAnswer": 1,
          "explanation": "The correct syntax is git stash push -m \"message\". This allows naming your stash to find it more easily later."
        }
      ]
    },
    {
      "id": "advanced-ex-6",
      "type": "quiz",
      "lessonId": "git-reset",
      "moduleId": "git-advanced",
      "title": "Git Reset Quiz",
      "difficulty": "medium",
      "questions": [
        {
          "question": "What is the difference between `git reset --soft HEAD~1` and `git reset --hard HEAD~1`?",
          "options": [
            "No difference",
            "--soft keeps modifications staged, --hard deletes everything",
            "--soft deletes modifications, --hard keeps them",
            "--soft only works on local branches"
          ],
          "correctAnswer": 1,
          "explanation": "--soft undoes the commit but keeps modifications in the staging area. --hard undoes the commit AND permanently deletes all modifications. It's dangerous!"
        },
        {
          "question": "When should you use `git reset --hard`?",
          "options": [
            "On already pushed commits",
            "Only on local unpushed commits",
            "Every day to clean up",
            "Never, it's too dangerous"
          ],
          "correctAnswer": 1,
          "explanation": "git reset --hard should only be used on local commits that haven't been pushed yet. On pushed commits, this would rewrite history and cause problems for the team."
        },
        {
          "question": "How to unstage a specific file?",
          "options": [
            "git unstage file",
            "git reset HEAD file",
            "git checkout -- file",
            "git restore file"
          ],
          "correctAnswer": 1,
          "explanation": "git reset HEAD file removes the file from the staging area (index) but keeps the modifications. This is the old syntax, today you can also use git restore --staged file."
        }
      ]
    },
    {
      "id": "advanced-ex-7",
      "type": "quiz",
      "lessonId": "push-force",
      "moduleId": "git-advanced",
      "title": "Push Force Quiz",
      "difficulty": "medium",
      "questions": [
        {
          "question": "Why is `git push --force` dangerous?",
          "options": [
            "It slows down the server",
            "It can overwrite other developers' work",
            "It creates empty commits",
            "It doesn't work on GitHub"
          ],
          "correctAnswer": 1,
          "explanation": "Force push overwrites the remote history. If other people based their work on the commits you overwrite, their work becomes orphaned and can be lost."
        },
        {
          "question": "What is the safer alternative to `git push --force`?",
          "options": [
            "git push --safe",
            "git push --force-with-lease",
            "git push --soft",
            "git push --overwrite"
          ],
          "correctAnswer": 1,
          "explanation": "git push --force-with-lease checks that no one pushed to the branch since your last fetch. If someone pushed, the command fails, thus protecting others' work."
        },
        {
          "question": "On which branch(es) should you NEVER force push?",
          "options": [
            "Only on main/master",
            "On all branches shared with the team",
            "On personal feature branches",
            "On all branches without exception"
          ],
          "correctAnswer": 1,
          "explanation": "Never force push on main, master, develop, or any branch others are working on. Force push is only acceptable on your personal unshared branches."
        }
      ]
    },
    {
      "id": "advanced-ex-8",
      "type": "quiz",
      "lessonId": "vibe-coding-practices",
      "moduleId": "git-advanced",
      "title": "Best Practices Quiz",
      "difficulty": "easy",
      "questions": [
        {
          "question": "Which commit message convention is recommended?",
          "options": [
            "update, fix, change",
            "feat:, fix:, docs:, refactor:",
            "Add, Modify, Delete",
            "No particular convention"
          ],
          "correctAnswer": 1,
          "explanation": "The conventional convention uses prefixes like feat: (new feature), fix: (correction), docs: (documentation), refactor: (refactoring), etc. This makes history readable."
        },
        {
          "question": "What is the right commit frequency?",
          "options": [
            "Once per day",
            "Once per week",
            "Every 30-60 minutes or at each small feature",
            "Only when everything is finished"
          ],
          "correctAnswer": 2,
          "explanation": "Commit often, ideally every 30-60 minutes or at each completed small feature. This creates save points and facilitates debugging."
        }
      ]
    },
    {
      "id": "advanced-ex-9",
      "type": "git-scenario",
      "lessonId": "vibe-coding-practices",
      "moduleId": "git-advanced",
      "title": "Complete Workflow",
      "difficulty": "hard",
      "story": "Put everything you learned into practice! You need to create a feature branch, make several commits with conventional messages, then return to main cleanly. Then stash changes and retrieve them.",
      "hints": [
        "Create a branch with git checkout -b feature/name",
        "Make at least 2 commits with messages like 'feat: ...'",
        "Stash changes before returning to main",
        "Retrieve the stash on your feature"
      ],
      "initialState": {
        "files": [
          { "name": "index.html", "status": "committed" },
          { "name": "style.css", "status": "untracked" },
          { "name": "app.js", "status": "untracked" }
        ],
        "commits": [{ "message": "Initial commit", "files": ["index.html"] }],
        "branches": ["main"],
        "currentBranch": "main",
        "isInitialized": true
      },
      "objectives": [
        { "description": "Create a feature branch", "check": { "type": "branchExists", "value": "feature" } },
        { "description": "Make at least 2 commits on feature", "check": { "type": "minCommits", "value": 3 } },
        { "description": "Stash changes", "check": { "type": "fileStatus", "file": "style.css", "status": "committed" } },
        { "description": "Return to main cleanly", "check": { "type": "currentBranch", "value": "main" } }
      ]
    }
  ]
}