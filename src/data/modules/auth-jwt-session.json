{
  "module": {
    "id": "auth-jwt-session",
    "title": "Auth: Sessions and JWT",
    "description": "Implement session and JWT authentication in an Express application",
    "icon": "Key",
    "requiredXp": 1200,
    "color": "from-yellow-500 to-amber-500",
    "courseId": "auth-security"
  },
  "lessons": [
    {
      "id": "session-auth",
      "moduleId": "auth-jwt-session",
      "title": "Session-Based Authentication",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Sessions = server-side state, client-side cookie\n- Cookie contains an opaque session ID\n- Server stores session data (DB, Redis, file)\n- Stateful: server must manage all session states\n\n---\n\n# HTTP Sessions\n\n## How It Works\n\n```\n1. Successful login\n2. Server creates a session (id: abc123, userId: 42)\n3. Server stores the session (Redis/DB)\n4. Server sends cookie: sessionId=abc123\n5. Client stores the cookie\n6. Subsequent requests: client sends the cookie\n7. Server retrieves sessionId and loads the data\n```\n\n## Implementation with express-session\n\n```bash\nnpm install express-session\nnpm install connect-redis  # or connect-pg-simple for PostgreSQL\n```\n\n```javascript\nimport session from 'express-session';\nimport RedisStore from 'connect-redis';\nimport { createClient } from 'redis';\n\n// Setup Redis\nconst redisClient = createClient();\nredisClient.connect();\n\napp.use(session({\n  store: new RedisStore({ client: redisClient }),\n  secret: process.env.SESSION_SECRET,  // Secret key to sign the cookie\n  resave: false,                       // Don't save if not modified\n  saveUninitialized: false,            // Don't create empty session\n  name: 'sessionId',                   // Cookie name (not 'connect.sid')\n  cookie: {\n    secure: process.env.NODE_ENV === 'production',  // HTTPS only in prod\n    httpOnly: true,                    // No JS access\n    maxAge: 24 * 60 * 60 * 1000,       // 24 hours\n    sameSite: 'strict'                 // CSRF protection\n  }\n}));\n```\n\n## Authentication Routes\n\n```javascript\n// Login\napp.post('/auth/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  const user = await db.findUserByEmail(email);\n  if (!user || !await verifyPassword(password, user.passwordHash)) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Create the session\n  req.session.userId = user.id;\n  req.session.email = user.email;\n  \n  res.json({ message: 'Login successful', user: { id: user.id, email: user.email } });\n});\n\n// Logout\napp.post('/auth/logout', (req, res) => {\n  req.session.destroy();\n  res.clearCookie('sessionId');\n  res.json({ message: 'Logout successful' });\n});\n\n// Protected route\napp.get('/profile', requireAuth, (req, res) => {\n  const user = await db.findUserById(req.session.userId);\n  res.json(user);\n});\n```\n\n## Middleware for Protection\n\n```javascript\nfunction requireAuth(req, res, next) {\n  if (!req.session.userId) {\n    return res.status(401).json({ error: 'Authentication required' });\n  }\n  next();\n}\n```\n\n## Pros and Cons\n\n**Pros:**\n- ✅ Simple to implement\n- ✅ Automatic session management\n- ✅ Easy to revoke sessions\n- ✅ Server-side control\n\n**Cons:**\n- ❌ Stateful: requires session store (Redis/DB)\n- ❌ Doesn't work well with mobile apps\n- ❌ Less suitable for microservices\n- ❌ Session affinity required for load balancing"
    },
    {
      "id": "jwt-auth",
      "moduleId": "auth-jwt-session",
      "title": "JWT Authentication",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- JWT = JSON Web Token: signed token containing claims\n- Stateless: server doesn't store state\n- Structure: header.payload.signature\n- Access token (short duration) + Refresh token (long duration)\n\n---\n\n# JSON Web Tokens (JWT)\n\n## JWT Structure\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.  ← Header (algo, type)\neyJ1c2VySWQiOjQyLCJyb2xlIjoidXNlciJ9.   ← Payload (data)\nSflKxwRJSMeKKF2QT4fwpMe...                ← Signature (verification)\n```\n\nDecode at https://jwt.io\n\n## Implementation\n\n```bash\nnpm install jsonwebtoken\n```\n\n```javascript\nimport jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET;\nconst JWT_EXPIRES_IN = '15m';      // Access token: short\nconst REFRESH_EXPIRES_IN = '7d';   // Refresh token: long\n\n// Generate tokens\nfunction generateTokens(user) {\n  const accessToken = jwt.sign(\n    { userId: user.id, role: user.role },\n    JWT_SECRET,\n    { expiresIn: JWT_EXPIRES_IN }\n  );\n  \n  const refreshToken = jwt.sign(\n    { userId: user.id, type: 'refresh' },\n    JWT_SECRET,\n    { expiresIn: REFRESH_EXPIRES_IN }\n  );\n  \n  return { accessToken, refreshToken };\n}\n\n// Login\napp.post('/auth/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  const user = await db.findUserByEmail(email);\n  if (!user || !await verifyPassword(password, user.passwordHash)) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  const tokens = generateTokens(user);\n  \n  // Store the refresh token (to be able to revoke it)\n  await db.saveRefreshToken(user.id, tokens.refreshToken);\n  \n  res.json({\n    accessToken: tokens.accessToken,\n    refreshToken: tokens.refreshToken,\n    expiresIn: 900  // 15 minutes in seconds\n  });\n});\n\n// JWT verification middleware\nfunction requireAuth(req, res, next) {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader?.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'Token required' });\n  }\n  \n  const token = authHeader.substring(7);\n  \n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    req.userId = decoded.userId;\n    req.userRole = decoded.role;\n    next();\n  } catch (err) {\n    return res.status(401).json({ error: 'Invalid or expired token' });\n  }\n}\n\n// Refresh token\napp.post('/auth/refresh', async (req, res) => {\n  const { refreshToken } = req.body;\n  \n  if (!refreshToken) {\n    return res.status(401).json({ error: 'Refresh token required' });\n  }\n  \n  try {\n    const decoded = jwt.verify(refreshToken, JWT_SECRET);\n    \n    // Check if token is valid in DB (not revoked)\n    const storedToken = await db.findRefreshToken(decoded.userId);\n    if (storedToken !== refreshToken) {\n      return res.status(401).json({ error: 'Invalid refresh token' });\n    }\n    \n    // Generate new tokens\n    const user = await db.findUserById(decoded.userId);\n    const tokens = generateTokens(user);\n    \n    // Replace old refresh token\n    await db.saveRefreshToken(user.id, tokens.refreshToken);\n    \n    res.json(tokens);\n  } catch (err) {\n    return res.status(401).json({ error: 'Invalid refresh token' });\n  }\n});\n```\n\n## Using JWT on the Client\n\n```javascript\n// Store tokens (after login)\nlocalStorage.setItem('accessToken', response.accessToken);\nlocalStorage.setItem('refreshToken', response.refreshToken);\n\n// Send token with each request\nfetch('/api/protected', {\n  headers: {\n    'Authorization': `Bearer ${localStorage.getItem('accessToken')}`\n  }\n});\n\n// Automatic token refresh\nasync function fetchWithAuth(url, options = {}) {\n  let token = localStorage.getItem('accessToken');\n  \n  let response = await fetch(url, {\n    ...options,\n    headers: {\n      ...options.headers,\n      'Authorization': `Bearer ${token}`\n    }\n  });\n  \n  // If expired, refresh and retry\n  if (response.status === 401) {\n    const newToken = await refreshAccessToken();\n    response = await fetch(url, {\n      ...options,\n      headers: {\n        ...options.headers,\n        'Authorization': `Bearer ${newToken}`\n      }\n    });\n  }\n  \n  return response;\n}\n```\n\n## Sessions vs JWT: When to Use Which?\n\n**Use Sessions when:**\n- Traditional web application\n- You need to revoke sessions immediately\n- Simple architecture with one server\n- You want automatic session management\n\n**Use JWT when:**\n- Mobile or SPA application\n- Microservices architecture\n- API that needs to be stateless\n- Cross-domain authentication required\n\n**Best Practice:**\n- Use short-lived access tokens (15-30 minutes)\n- Use refresh tokens for long sessions\n- Store tokens securely (HttpOnly cookies preferred over localStorage)"
    }
  ],
  "exercises": []
}
