{"module":{"id":"db-postgresql","title":"PostgreSQL: Professional Database","description":"Master PostgreSQL for production applications: installation, optimization and advanced features","icon":"Database","requiredXp":900,"color":"from-indigo-600 to-purple-600","courseId":"databases"},"lessons":[{"id":"postgres-intro","moduleId":"db-postgresql","title":"Introduction to PostgreSQL","order":1,"difficulty":"intermediate","content":"# Essential to know\\n- PostgreSQL = advanced open-source relational database\\n- Modern features: JSONB, arrays, full-text search\\n- Strict ACID, concurrent (MVCC)\\n- Extensible via extensions (PostGIS, TimescaleDB)\\n- Industry standard for serious applications\\n\\n---\\n\\n# Why PostgreSQL?\\n\\nPostgreSQL (often called \"Postgres\") is considered the most advanced open-source relational database. Created in 1986, it combines reliability, advanced features, and SQL standards compliance.\\n\\n## PostgreSQL strengths\\n\\n### 1. SQL Compliance\\n- Strict SQL standards compliance\\n- Portable to other systems\\n- Consistent and documented syntax\\n\\n### 2. Rich data types\\n- Standard types: INTEGER, TEXT, BOOLEAN, DATE/TIMESTAMP\\n- Arrays: INTEGER[], TEXT[]\\n- JSONB: Indexable binary JSON\\n- Geospatial with PostGIS\\n- Custom types\\n\\n### 3. Reliability\\n- Strict ACID\\n- MVCC (Multi-Version Concurrency Control): non-blocking reads\\n- Write-Ahead Logging (WAL): no data corruption\\n- Point-in-time recovery\\n\\n### 4. Extensibility\\n- PostGIS: Geospatial data\\n- TimescaleDB: Time-series data\\n- pg_trgm: Text similarity\\n- uuid-ossp: UUID generation\\n- And hundreds more\\n\\n## Local installation\\n\\n### macOS (with Homebrew)\\n```bash\\nbrew install postgresql@15\\nbrew services start postgresql@15\\n\\n# Create database for your user\\ncreatedb $(whoami)\\n```\\n\\n### Linux (Ubuntu/Debian)\\n```bash\\nsudo apt update\\nsudo apt install postgresql postgresql-contrib\\nsudo systemctl start postgresql\\n\\n# Change postgres password\\nsudo -u postgres psql -c \\\"ALTER USER postgres WITH PASSWORD 'your_password';\\\"\\n```\\n\\n### Docker (recommended for dev)\\n```bash\\ndocker run --name postgres-dev \\\\\\\\n  -e POSTGRES_PASSWORD=password \\\\\\\\n  -e POSTGRES_DB=myapp \\\\\\\\n  -p 5432:5432 \\\\\\\\n  -v postgres_data:/var/lib/postgresql/data \\\\\\\\n  -d postgres:15\\n```..."},{"id":"postgres-node","moduleId":"db-postgresql","title":"PostgreSQL with Node.js","order":2,"difficulty":"intermediate","content":"# Essential to know\\n- Use `pg` (node-postgres) the standard driver\\n- Connection pool for performance\\n- Parameterized queries against SQL injection\\n- Transactions with BEGIN/COMMIT/ROLLBACK\\n- Migrations with node-pg-migrate or other\\n\\n---\\n\\n# pg (node-postgres)\\n\\nThe `pg` package is the standard PostgreSQL driver for Node.js. It supports SSL connections, notifications, and more.\\n\\n## Installation and setup\\n\\n```bash\\nnpm install pg\\n```\\n\\n```javascript\\nimport { Pool, Client } from 'pg';\\n\\n// Pool (recommended for web apps)\\nconst pool = new Pool({\\n  connectionString: process.env.DATABASE_URL,\\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\\n  max: 20,                    // Max concurrent connections\\n  idleTimeoutMillis: 30000,   // Close idle connections after 30s\\n  connectionTimeoutMillis: 2000,\\n});\\n\\n// Test connection\\npool.on('connect', () => {\\n  console.log('Connected to PostgreSQL');\\n});\\n\\npool.on('error', (err) => {\\n  console.error('PostgreSQL error', err);\\n});\\n```\\n\\n## Basic queries\\n\\n```javascript\\n// Simple query\\nconst result = await pool.query('SELECT NOW()');\\nconsole.log(result.rows[0].now);\\n\\n// With parameters (SECURITY: prevents SQL injection)\\nconst userId = 1;\\nconst result = await pool.query(\\n  'SELECT * FROM users WHERE id = $1',\\n  [userId]\\n);\\n\\n// Multiple parameters\\nawait pool.query(\\n  'INSERT INTO users (name, email, age) VALUES ($1, $2, $3)',\\n  ['John', 'john@example.com', 30]\\n);\\n\\n// Get with LIMIT/OFFSET\\nconst { rows } = await pool.query(\\n  'SELECT * FROM users LIMIT $1 OFFSET $2',\\n  [20, 0]  // LIMIT 20 OFFSET 0\\n);\\n```\\n\\n## Repository Pattern\\n\\n```javascript\\nclass UserRepository {\\n  constructor(pool) {\\n    this.pool = pool;\\n  }\\n  \\n  async findById(id) {\\n    const { rows } = await this.pool.query(\\n      'SELECT * FROM users WHERE id = $1',\\n      [id]\\n    );\\n    return rows[0] || null;\\n..."},{"id":"postgres-advanced","moduleId":"db-postgresql","title":"Advanced features","order":3,"difficulty":"advanced","content":"# Essential to know\\n- Indexes to speed up queries (B-tree, Hash, GIN, GIST)\\n- Built-in full-text search\\n- Materialized views for aggregated data\\n- Partitions for large tables\\n- Backup with pg_dump and point-in-time recovery\\n\\n---\\n\\n# Indexing\\n\\nIndexes speed up queries but slow down writes. Use them judiciously.\\n\\n## Index types\\n\\n```sql\\n-- B-tree (default): equality and range\\nCREATE INDEX idx_users_email ON users(email);\\nCREATE INDEX idx_orders_date ON orders(created_at);\\n\\n-- Composite\\nCREATE INDEX idx_orders_user_date ON orders(user_id, created_at);\\n\\n-- Unique\\nCREATE UNIQUE INDEX idx_users_lower_email ON users(LOWER(email));\\n\\n-- Partial (with condition)\\nCREATE INDEX idx_active_users ON users(email) WHERE active = true;\\n\\n-- GIN for JSONB and arrays\\nCREATE INDEX idx_events_data ON events USING GIN(data);\\n\\n-- GiST for geospatial data\\nCREATE INDEX idx_locations_coords ON locations USING GIST(coords);\\n```\\n\\n## Full-Text Search\\n\\n```sql\\n-- Enable extension\\nCREATE EXTENSION IF NOT EXISTS pg_trgm;\\n\\n-- tsvector column for search\\nALTER TABLE articles ADD COLUMN search_vector tsvector;\\n\\n-- Update with data\\nUPDATE articles SET\\n  search_vector = setweight(to_tsvector('english', title), 'A') ||\\n                  setweight(to_tsvector('english', content), 'B');\\n\\n-- GIN index\\nCREATE INDEX idx_articles_search ON articles USING GIN(search_vector);\\n\\n-- Search\\nSELECT * FROM articles\\nWHERE search_vector @@ to_tsquery('english', 'postgresql & tutorial');\\n\\n-- Rank by relevance\\nSELECT\\n  title,\\n  ts_rank(search_vector, query) AS rank\\nFROM articles, to_tsquery('english', 'postgresql') query\\nWHERE search_vector @@ query\\nORDER BY rank DESC;\\n```\\n\\n## Views and Materialized Views\\n\\n```sql\\n-- View (stored query)\\nCREATE VIEW active_users AS\\nSELECT id, name, email FROM users WHERE active = true;\\n\\nSELECT * FROM active_users;..."}],"exercises":[]}
