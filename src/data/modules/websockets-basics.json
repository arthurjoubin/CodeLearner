{
  "module": {
    "id": "websockets-basics",
    "title": "WebSockets & Real-time",
    "description": "Communicate in real-time between client and server with WebSockets and Socket.io",
    "icon": "Zap",
    "requiredXp": 1800,
    "color": "from-green-400 to-emerald-600",
    "courseId": "node-express"
  },
  "lessons": [
    {
      "id": "websockets-intro",
      "moduleId": "websockets-basics",
      "title": "Introduction to WebSockets",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- WebSocket = bidirectional real-time communication protocol\n- Persistent connection: one connection for multiple messages\n- Full-duplex: client and server can send messages simultaneously\n- Alternative to HTTP polling requests (more efficient)\n- Perfect for: chat, notifications, online games, real-time dashboards\n- Requires a WebSocket server (Node.js, etc.)\n\n---\n\n# WebSockets: Real-time Communication\n\n## The Problem with HTTP\n\n**Classic HTTP (request-response):**\n```\nClient: Hey server, any news?\nServer: No\n[wait 5 seconds]\nClient: Hey server, any news?\nServer: No\n[wait 5 seconds]\nClient: Hey server, any news?\nServer: Yes! Here are the news.\n```\n\n**Problems:**\n- High latency\n- HTTP overhead (headers on every request)\n- Server resource consumption\n- No push from server\n\n## The Solution: WebSockets\n\n**WebSocket persistent connection:**\n```\nClient: Hey server, let's open a WebSocket connection\nServer: OK, connection established!\n\n[connection open]\n\nServer: New news!\nClient: Thanks!\nServer: More news!\nClient: Great!\nClient: I want to send a message\nServer: Received!\n\n[connection stays open...]\n```\n\n**Advantages:**\n- Bidirectional persistent connection\n- Low latency\n- No HTTP overhead after handshake\n- Server can push data\n- Scalable (less resources than HTTP polling)\n\n## How it works?\n\n### 1. HTTP Handshake (once)\n\n```\nClient sends:\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\n\nServer responds:\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n```\n\n### 2. WebSocket Connection Established\n\nAfter handshake, the connection d...",
      "codeExample": "// Complete WebSocket client\n\nclass ChatClient {\n  constructor(url) {\n    this.url = url;\n    this.socket = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n  }\n\n  connect() {\n    console.log('Connecting to', this.url);\n    \n    this.socket = new WebSocket(this.url);\n    \n    this.socket.onopen = () => {\n      console.log('‚úÖ Connected!');\n      this.reconnectAttempts = 0;\n      this.onConnect?.();\n    };\n    \n    this.socket.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('üì® Message received:', data);\n        this.onMessage?.(data);\n      } catch (e) {\n        console.log('üì® Text message:', event.data);\n      }\n    };\n    \n    this.socket.onclose = (event) => {\n      console.log('‚ùå Disconnected', event.code, event.reason);\n      this.onDisconnect?.();\n      \n      // Automatic reconnection\n      if (this.reconnectAttempts < this.maxReconnectAttempts) {\n        this.reconnectAttempts++;\n        console.log(`Reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}...`);\n        setTimeout(() => this.connect(), 3000);\n      }\n    };\n    \n    this.socket.onerror = (error) => {\n      console.error('üí• Error:', error);\n      this.onError?.(error);\n    };\n  }\n\n  send(message) {\n    if (this.socket?.readyState === WebSocket.OPEN) {\n      const data = typeof message === 'string' ? message : JSON.stringify(message);\n      this.socket.send(data);\n      console.log('üì§ Sent:', message);\n    } else {\n      console.error('Socket not connected');\n    }\n  }\n\n  disconnect() {\n    this.socket?.close();\n  }\n}\n\n// Usage\nconst chat = new ChatClient('wss://my-chat.com');\n\nchat.onConnect = () => {\n  chat.send({ type: 'join', room: 'general' });\n};\n\nchat.onMessage = (data) => {\n  if (data.type === 'chat') {\n    displayMessage(data.user, data.content);\n  }\n};\n\nchat.connect();\n\n// Send ..."
    },
    {
      "id": "socketio-intro",
      "moduleId": "websockets-basics",
      "title": "Socket.io: Simplifying WebSockets",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Socket.io = library that simplifies WebSockets\n- Automatic fallback if WebSocket unavailable (long-polling)\n- Built-in room (channel) management\n- Broadcasting (send to multiple clients)\n- Automatic reconnection\n- Supports acknowledgments (receipt confirmation)\n- Requires socket.io on both server AND client\n\n---\n\n# Socket.io: Simplified WebSockets\n\n## Why Socket.io?\n\n**Native WebSocket is basic:**\n- No fallback if WebSocket unavailable\n- No automatic reconnection\n- No concept of \"rooms\"\n- No simple broadcasting\n- Manual error handling\n\n**Socket.io brings:**\n- ‚úÖ Automatic fallback (long-polling ‚Üí WebSocket)\n- ‚úÖ Automatic reconnection with backoff\n- ‚úÖ Rooms and namespaces\n- ‚úÖ Easy broadcasting\n- ‚úÖ Acknowledgments\n- ‚úÖ Binary support\n- ‚úÖ Middleware possible\n\n## Socket.io Architecture\n\n```\nClient (browser)        Server (Node.js)\n      ‚Üì                           ‚Üë\nsocket.emit('chat')  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>  socket.on('chat')\n      ‚Üë                           ‚Üì\nsocket.on('reply')  <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  io.emit('reply')\n```\n\n## Installation\n\n**Server (Node.js):**\n```bash\nnpm install socket.io\n```\n\n**Client:**\n```bash\nnpm install socket.io-client\n# or CDN\n<script src=\"/socket.io/socket.io.js\"></script>\n```\n\n## Socket.io Server (Node.js + Express)\n\n```javascript\nconst express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server, {\n  cors: {\n    origin: \"http://localhost:3000\",\n    methods: [\"GET\", \"POST\"]\n  }\n});\n\n// Client connection\nio.on('connection', (socket) => {\n  console.log('A user connected:', socket.id);\n  \n  // Receive a message\n  socket.on('chat message', (msg) => {\n    console.log('Message received:', msg);\n    \n    // Send to all clients\n...",
      "codeExample": "// Complete example: Chat with Socket.io\n\n// ============ SERVER (server.js) ============\nconst express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server, {\n  cors: { origin: '*' }\n});\n\nconst users = new Map();\n\nio.on('connection', (socket) => {\n  console.log('üü¢ Connected:', socket.id);\n  \n  // User login\n  socket.on('user-login', (username) => {\n    users.set(socket.id, username);\n    socket.broadcast.emit('user-joined', username);\n    io.emit('user-count', users.size);\n  });\n  \n  // General chat message\n  socket.on('chat-message', ({ text, room = 'general' }) => {\n    const username = users.get(socket.id) || 'Anonymous';\n    const message = {\n      id: Date.now(),\n      user: username,\n      text,\n      room,\n      timestamp: new Date().toISOString()\n    };\n    \n    if (room === 'general') {\n      io.emit('chat-message', message);\n    } else {\n      io.to(room).emit('chat-message', message);\n    }\n  });\n  \n  // Join room\n  socket.on('join-room', (room) => {\n    socket.join(room);\n    const username = users.get(socket.id);\n    socket.to(room).emit('notification', `${username} joined ${room}`);\n  });\n  \n  // Typing indicator\n  socket.on('typing', ({ isTyping, room }) => {\n    const username = users.get(socket.id);\n    socket.to(room || 'general').emit('user-typing', {\n      user: username,\n      isTyping\n    });\n  });\n  \n  // Disconnection\n  socket.on('disconnect', () => {\n    const username = users.get(socket.id);\n    users.delete(socket.id);\n    socket.broadcast.emit('user-left', username);\n    io.emit('user-count', users.size);\n    console.log('üî¥ Disconnected:', socket.id);\n  });\n});\n\nserver.listen(3001, () => console.log('üöÄ Server on :3001'));\n\n\n// ============ CLIENT (App.js) ============\nimport { u..."
    },
    {
      "id": "websockets-patterns",
      "moduleId": "websockets-basics",
      "title": "Advanced Patterns",
      "order": 3,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Acknowledgments: confirm message receipt\n- Middleware: execute code before events\n- Authentication: secure WebSocket connections\n- Error handling: recovery and retry\n- Room-based architecture: organize by rooms\n- Presence tracking: know who is online\n- Rate limiting: prevent spam\n\n---\n\n# Advanced WebSocket Patterns\n\n## 1. Acknowledgments (Confirmations)\n\nConfirm that the message was received:\n\n```javascript\n// Client\nsocket.emit('send-message', message, (response) => {\n  if (response.success) {\n    console.log('‚úÖ Message sent:', response.id);\n    // Update UI (checkmark, etc.)\n  } else {\n    console.error('‚ùå Error:', response.error);\n    // Show error to user\n  }\n});\n\n// Server\nsocket.on('send-message', async (message, callback) => {\n  try {\n    // Save to database\n    const saved = await Message.create({\n      text: message.text,\n      user: socket.userId,\n      timestamp: new Date()\n    });\n    \n    // Send to others\n    socket.broadcast.emit('new-message', saved);\n    \n    // Confirm to client\n    callback({\n      success: true,\n      id: saved._id,\n      timestamp: saved.timestamp\n    });\n  } catch (error) {\n    callback({\n      success: false,\n      error: error.message\n    });\n  }\n});\n```\n\n## 2. Authentication Middleware\n\n```javascript\n// Middleware to verify authentication\nio.use(async (socket, next) => {\n  try {\n    const token = socket.handshake.auth.token;\n    \n    if (!token) {\n      return next(new Error('Token missing'));\n    }\n    \n    // Verify JWT\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    const user = await User.findById(decoded.userId);\n    \n    if (!user) {\n      return next(new Error('User not found'));\n    }\n    \n    // Attach user to socket\n    socket.userId = user._id;\n    ...",
      "codeExample": "// Complete pattern: Secure chat with rooms and presence\n\nconst express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\nconst jwt = require('jsonwebtoken');\nconst Redis = require('ioredis');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server, { cors: { origin: '*' } });\nconst redis = new Redis();\n\n// ============ AUTH MIDDLEWARE ============\nio.use(async (socket, next) => {\n  try {\n    const token = socket.handshake.auth.token;\n    const decoded = jwt.verify(token, 'secret');\n    const user = await User.findById(decoded.id);\n    \n    socket.userId = user._id.toString();\n    socket.username = user.username;\n    socket.roomsJoined = new Set();\n    \n    next();\n  } catch (err) {\n    next(new Error('Auth failed'));\n  }\n});\n\n// ============ CONNECTION MANAGEMENT ============\nio.on('connection', (socket) => {\n  console.log(`üîå ${socket.username} connected`);\n  \n  // Track presence\n  redis.sadd('online-users', socket.userId);\n  redis.sadd(`user:${socket.userId}:sockets`, socket.id);\n  socket.broadcast.emit('user-online', socket.username);\n  \n  // Join room\n  socket.on('join-room', async (roomId, callback) => {\n    try {\n      // Leave other rooms\n      socket.roomsJoined.forEach(room => socket.leave(room));\n      socket.roomsJoined.clear();\n      \n      // Join new room\n      socket.join(roomId);\n      socket.roomsJoined.add(roomId);\n      socket.currentRoom = roomId;\n      \n      // Notify\n      socket.to(roomId).emit('user-joined', {\n        user: socket.username,\n        room: roomId\n      });\n      \n      // Get history\n      const history = await Message.find({ room: roomId })\n        .sort({ timestamp: -1 })\n        .limit(50)\n        .lean();\n      \n      callback({ success: true, history: history.reverse() });\n    } catch (error) {\n      callback({ success..."
    }
  ],
  "exercises": [
    {
      "id": "ws-ex-1",
      "lessonId": "websockets-intro",
      "moduleId": "websockets-basics",
      "title": "WebSockets Basics Quiz",
      "difficulty": "easy",
      "type": "quiz",
      "questions": [
        {
          "question": "What is the main difference between HTTP and WebSocket?",
          "options": [
            "WebSocket is slower",
            "WebSocket keeps a persistent open connection",
            "WebSocket doesn't work on mobile",
            "WebSocket uses XML instead of JSON"
          ],
          "correctAnswer": 1,
          "explanation": "WebSocket establishes a persistent bidirectional connection, unlike HTTP which makes distinct request-responses."
        },
        {
          "question": "Which event triggers when a message is received via WebSocket?",
          "options": [
            "'receive'",
            "'data'",
            "'message'",
            "'incoming'"
          ],
          "correctAnswer": 2,
          "explanation": "The 'message' event triggers when a message is received from the server via WebSocket."
        },
        {
          "question": "Which WebSocket protocol is secure (like HTTPS)?",
          "options": [
            "ws://",
            "wss://",
            "websocket://",
            "ws-secure://"
          ],
          "correctAnswer": 1,
          "explanation": "wss:// (WebSocket Secure) is the secure version of WebSocket, equivalent to HTTPS for WebSockets."
        }
      ]
    },
    {
      "id": "ws-ex-2",
      "lessonId": "socketio-intro",
      "moduleId": "websockets-basics",
      "title": "Socket.io Quiz",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "What advantage does Socket.io bring over native WebSockets?",
          "options": [
            "It's faster",
            "Automatic fallback and automatic reconnection",
            "It uses less memory",
            "It's built into the browser"
          ],
          "correctAnswer": 1,
          "explanation": "Socket.io offers automatic fallback to long-polling if WebSocket is not available, and handles automatic reconnection."
        },
        {
          "question": "How do you send a message to all clients EXCEPT the sender with Socket.io?",
          "options": [
            "io.emit()",
            "socket.broadcast.emit()",
            "socket.emit()",
            "io.broadcast()"
          ],
          "correctAnswer": 1,
          "explanation": "socket.broadcast.emit() sends to all connected clients except the one that triggered the event."
        },
        {
          "question": "What is a 'room' in Socket.io?",
          "options": [
            "A physical chat room",
            "A logical channel to group sockets",
            "A database",
            "A message type"
          ],
          "correctAnswer": 1,
          "explanation": "A room is a logical channel that allows grouping sockets and sending messages to that specific group."
        }
      ]
    },
    {
      "id": "ws-ex-3",
      "lessonId": "websockets-patterns",
      "moduleId": "websockets-basics",
      "title": "Advanced Patterns Quiz",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "What are 'acknowledgments' used for in Socket.io?",
          "options": [
            "To thank the server",
            "To confirm receipt of a message",
            "To encrypt messages",
            "To compress data"
          ],
          "correctAnswer": 1,
          "explanation": "Acknowledgments allow the server to confirm that it has received and processed the client's message."
        },
        {
          "question": "Why use Redis with Socket.io in production?",
          "options": [
            "To make it faster",
            "To share rooms between multiple servers",
            "Because it's free",
            "To store files"
          ],
          "correctAnswer": 1,
          "explanation": "Redis allows synchronizing rooms and events between multiple Socket.io server instances (horizontal scaling)."
        },
        {
          "question": "What is the best practice for WebSocket authentication?",
          "options": [
            "Send token in each message",
            "Use socket.handshake.auth during connection",
            "Don't use authentication",
            "Store token in localStorage on server side"
          ],
          "correctAnswer": 1,
          "explanation": "The best practice is to send the token during the handshake via socket.handshake.auth and verify via middleware."
        }
      ]
    }
  ]
}
