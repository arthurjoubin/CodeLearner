{"module":{"id":"db-orms","title":"ORMs: Prisma and Drizzle","description":"Using ORMs to simplify data access: Prisma and Drizzle with Node.js","icon":"Layers","requiredXp":1000,"color":"from-violet-500 to-purple-600","courseId":"databases"},"lessons":[{"id":"orms-why","moduleId":"db-orms","title":"Why use an ORM?","order":1,"difficulty":"intermediate","content":"# Essential to know\\n- ORM = Object-Relational Mapping: code ↔ database\\n- Avoid writing repetitive SQL\\n- Type-safe with TypeScript\\n- Automatic migrations\\n- Trade-off: abstraction vs performance/control\\n\\n---\\n\\n# ORM vs Raw SQL\\n\\n## Writing SQL everywhere\\n```javascript\\n// ❌ Verbose, repetitive, not type-safe\\nconst result = await pool.query(\\n  'SELECT * FROM users WHERE id = $1',\\n  [id]\\n);\\nconst user = result.rows[0];\\n\\n// Manual validation\\nif (!user) throw new Error('User not found');\\n```\\n\\n## With an ORM\\n```javascript\\n// ✅ Concise, type-safe, automatic relations\\nconst user = await prisma.user.findUnique({\\n  where: { id },\\n  include: { posts: true }\\n});\\n```\\n\\n## Why an ORM?\\n\\n### ✅ Advantages\\n- **Productivity**: Less boilerplate code\\n- **Type-safe**: Autocompletion and compile-time checking\\n- **Relations**: Automatic JOIN management\\n- **Migrations**: DB schema versioning\\n- **Multi-database**: Change DB without changing code (theoretically)\\n- **Security**: Automatic parameterized queries\\n\\n### ❌ Disadvantages\\n- **Overhead**: Sometimes generates suboptimal queries\\n- **Learning curve**: New syntax and concepts\\n- **Debugging**: Harder to optimize queries\\n- **Complex queries**: Complex queries sometimes verbose\\n- **Lock-in**: Difficult migration if you want to change ORM\\n\\n## When to use an ORM?\\n\\n✅ **Use an ORM if:**\\n- You want complete type-safety\\n- Your team prefers pure JavaScript/TypeScript\\n- Moderate relational schema (not 50 complex tables)\\n- Project with lots of CRUD\\n\\n❌ **Raw SQL if:**\\n- Very complex queries (analytics, reporting)\\n- Need complete control over queries\\n- Critical performance (benchmarking needed)\\n- Experienced SQL team\\n\\n## Modern ORMs (2024)\\n\\n| ORM | Approach | Strengths | Weaknesses |\\n|-----|----------|-----------|------------|\\n..."},{"id":"prisma-intro","moduleId":"db-orms","title":"Prisma: Setup and Schema","order":2,"difficulty":"intermediate","content":"# Essential to know\\n- Prisma = Schema-first ORM with excellent DX\\n- Prisma Client for queries\\n- Prisma Migrate for migrations\\n- Prisma Studio to visualize data\\n- Supports PostgreSQL, MySQL, SQLite, SQL Server, MongoDB\\n\\n---\\n\\n# Prisma in practice\\n\\n## Installation\\n\\n```bash\\n# Initialize Prisma\\nnpm install prisma --save-dev\\nnpm install @prisma/client\\n\\n# Initialize project\\nnpx prisma init\\n\\n# Generates:\\n# - prisma/schema.prisma\\n# - .env with DATABASE_URL\\n```\\n\\n## Configuration\\n\\n```prisma\\n// schema.prisma\\ngenerator client {\\n  provider = \\\"prisma-client-js\\\"\\n}\\n\\ndatasource db {\\n  provider = \\\"postgresql\\\"  // or \\\"sqlite\\\", \\\"mysql\\\"\\n  url      = env(\\\"DATABASE_URL\\\")\\n}\\n\\n// Models\\nmodel User {\\n  id        Int      @id @default(autoincrement())\\n  email     String   @unique\\n  name      String?\\n  posts     Post[]\\n  profile   Profile?\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n}\\n\\nmodel Post {\\n  id       Int     @id @default(autoincrement())\\n  title    String\\n  content  String?\\n  published Boolean @default(false)\\n  author   User    @relation(fields: [authorId], references: [id])\\n  authorId Int\\n  tags     Tag[]\\n}\\n\\nmodel Profile {\\n  id     Int    @id @default(autoincrement())\\n  bio    String?\\n  user   User   @relation(fields: [userId], references: [id])\\n  userId Int    @unique\\n}\\n\\nmodel Tag {\\n  id    Int    @id @default(autoincrement())\\n  name  String @unique\\n  posts Post[]\\n}\\n```\\n\\n## Migrations\\n\\n```bash\\n# Create and apply migration\\nnpx prisma migrate dev --name init\\n\\n# View generated SQL without applying\\nnpx prisma migrate dev --create-only\\n\\n# Deploy to production (without interactive)\\nnpx prisma migrate deploy\\n\\n# Reset (warning: data loss!)\\nnpx prisma migrate reset\\n```\\n\\n## Prisma Client\\n\\n```javascript\\nimport { PrismaClient } from '@prisma/client';\\n\\nconst prisma = new PrismaClient({\\n  log: ['query', 'info', '..."},{"id":"drizzle-intro","moduleId":"db-orms","title":"Drizzle: SQL-like TypeScript","order":3,"difficulty":"intermediate","content":"# Essential to know\\n- Drizzle = ORM that looks like SQL\\n- Lightweight, performant, type-safe\\n- No complex runtime\\n- Query builder close to SQL\\n- Modern alternative to Prisma\\n\\n---\\n\\n# Drizzle in practice\\n\\n## Installation\\n\\n```bash\\nnpm install drizzle-orm pg\\nnpm install -D drizzle-kit\\n```\\n\\n## Configuration\\n\\n```typescript\\n// db/schema.ts\\nimport { pgTable, serial, varchar, text, timestamp, integer, boolean } from 'drizzle-orm/pg-core';\\nimport { relations } from 'drizzle-orm';\\n\\n// Tables\\nexport const users = pgTable('users', {\\n  id: serial('id').primaryKey(),\\n  email: varchar('email', { length: 255 }).notNull().unique(),\\n  name: varchar('name', { length: 255 }),\\n  createdAt: timestamp('created_at').defaultNow(),\\n  updatedAt: timestamp('updated_at').defaultNow()\\n});\\n\\nexport const posts = pgTable('posts', {\\n  id: serial('id').primaryKey(),\\n  title: varchar('title', { length: 255 }).notNull(),\\n  content: text('content'),\\n  published: boolean('published').default(false),\\n  authorId: integer('author_id').references(() => users.id),\\n  createdAt: timestamp('created_at').defaultNow()\\n});\\n\\n// Relations\\nexport const usersRelations = relations(users, ({ many }) => ({\\n  posts: many(posts)\\n}));\\n\\nexport const postsRelations = relations(posts, ({ one }) => ({\\n  author: one(users, {\\n    fields: [posts.authorId],\\n    references: [users.id]\\n  })\\n}));\\n```\\n\\n## Drizzle Config\\n\\n```typescript\\n// drizzle.config.ts\\nimport type { Config } from 'drizzle-kit';\\n\\nexport default {\\n  schema: './db/schema.ts',\\n  out: './drizzle',\\n  driver: 'pg',\\n  dbCredentials: {\\n    connectionString: process.env.DATABASE_URL!\\n  }\\n} satisfies Config;\\n```\\n\\n## Migrations\\n\\n```bash\\n# Generate migrations\\nnpx drizzle-kit generate:pg\\n\\n# Apply\\nnpx drizzle-kit push:pg\\n```\\n\\n## Drizzle Client\\n\\n```typescript\\n// db/index.ts\\nimport { Pool } from 'pg';\\nimport { drizzle } from 'drizzle-orm/node-postgres';\\nimport * as schem..."}],"exercises":[{"id":"orm-ex-1","lessonId":"prisma-intro","moduleId":"db-orms","title":"Fix the Prisma Schema Syntax","difficulty":"easy","type":"code","description":"Cursor generated this Prisma schema for a blog, but it has a common syntax error. Debug it!","instructions":"Your AI assistant generated this Prisma schema:\n\n```prisma\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  author    User     @relation(fields: [authorId], references: [id])\n  authorId  Int\n}\n\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String?\n}\n```\n\nWhen you run `npx prisma generate`, you get an error: `Error validating: The relation field 'author' on Model 'Post' is missing an opposite relation field on the model 'User'`.\n\nFix the schema so the relation works correctly.\n\n**Expected behavior:** User should be able to have multiple posts, and each post should belong to one user.\n\n**Hint:** Prisma relations must be defined on BOTH sides!","starterCode":"model Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  author    User     @relation(fields: [authorId], references: [id])\n  authorId  Int\n}\n\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String?\n}","solution":"model Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  author    User     @relation(fields: [authorId], references: [id])\n  authorId  Int\n}\n\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String?\n  posts Post[]\n}","hints":["Prisma requires relation fields on BOTH models in a relationship","User should have a 'posts' field of type Post[] to represent the one-to-many relationship","The User side of the relation doesn't need @relation() since Post already has it","Add: posts Post[] to the User model"],"validationPrompt":"Check if the student's Prisma schema:\n1. Has a 'posts' field in the User model\n2. The posts field is of type Post[] (array of posts)\n3. The Post model still has the author and authorId fields\n4. Both models are properly defined with @id decorators\n\nThe key fix is adding the opposite relation field (posts Post[]) to the User model. Accept variations in formatting or field ordering."},{"id":"orm-ex-2","lessonId":"prisma-intro","moduleId":"db-orms","title":"Understanding the N+1 Query Problem","difficulty":"intermediate","type":"quiz","question":"You asked v0 to 'fetch all users with their posts'. It generated this code:\n\n```typescript\nconst users = await prisma.user.findMany();\nfor (const user of users) {\n  user.posts = await prisma.post.findMany({ \n    where: { authorId: user.id } \n  });\n}\n```\n\nWith 100 users, how many database queries does this execute?","options":["1 query (Prisma automatically optimizes it)","2 queries (1 for users, 1 for all posts)","101 queries (1 for users + 1 per user for their posts)","100 queries (1 per user, Prisma batches the user query)"],"correctAnswer":2,"explanation":"This is the classic **N+1 query problem**:\n- 1 query to fetch all users: `SELECT * FROM users`\n- Then 100 separate queries (one per user): `SELECT * FROM posts WHERE authorId = ?`\n- Total: **101 queries**\n\nThis is extremely inefficient! Each query has network overhead.\n\n**The fix:** Use Prisma's `include` to fetch relations in ONE query:\n```typescript\nconst users = await prisma.user.findMany({\n  include: { posts: true }\n});\n```\n\nThis generates a single efficient query with a JOIN, fetching all users and their posts at once.\n\nThe N+1 problem is one of the most common ORM performance issues. Always use `include` or `select` to eagerly load relations when you know you'll need them!"},{"id":"orm-ex-3","lessonId":"prisma-intro","moduleId":"db-orms","title":"Debug the Missing Relation Error","difficulty":"intermediate","type":"code","description":"ChatGPT wrote code to fetch a user with their profile, but it crashes. Fix the query!","instructions":"Your AI assistant generated this code:\n\n```typescript\nconst user = await prisma.user.findUnique({\n  where: { id: userId },\n  include: { profile: true }\n});\n\nif (!user.profile) {\n  throw new Error('Profile not found');\n}\n```\n\nIt compiles fine, but at runtime you get: `TypeError: Cannot read properties of null (reading 'profile')`\n\nThe issue is that `findUnique` can return `null` if the user doesn't exist, but the code doesn't check for that before accessing `user.profile`.\n\nFix the code to properly handle the case where the user might not exist.\n\n**Expected behavior:**\n- If user doesn't exist, throw 'User not found'\n- If user exists but has no profile, throw 'Profile not found'\n- Otherwise, return the user with profile\n\n**Tip:** Always check if the result is null before accessing its properties!","starterCode":"const user = await prisma.user.findUnique({\n  where: { id: userId },\n  include: { profile: true }\n});\n\nif (!user.profile) {\n  throw new Error('Profile not found');\n}","solution":"const user = await prisma.user.findUnique({\n  where: { id: userId },\n  include: { profile: true }\n});\n\nif (!user) {\n  throw new Error('User not found');\n}\n\nif (!user.profile) {\n  throw new Error('Profile not found');\n}","hints":["findUnique returns null if no record matches the where clause","You need to check if user is null BEFORE accessing user.profile","Add a null check: if (!user) throw new Error('User not found');","This should come BEFORE the profile check","Common mistake: AI-generated code often assumes data exists without null checks"],"validationPrompt":"Check if the student's code:\n1. Checks if user is null/falsy before accessing user.profile\n2. Throws an error (like 'User not found') when user is null\n3. Still checks if user.profile exists and throws an error if not\n4. The user null check comes BEFORE the profile check\n\nAccept variations like 'if (user === null)', 'if (!user)', or using optional chaining, as long as there's proper null handling before accessing user.profile."},{"id":"orm-ex-4","lessonId":"drizzle-intro","moduleId":"db-orms","title":"ORM vs Raw SQL: When to Use Each","difficulty":"intermediate","type":"quiz","question":"You're building an analytics dashboard that needs to generate a report with complex aggregations, multiple JOINs, window functions, and CTEs. The query is 50+ lines of SQL. Your teammate suggests using Prisma for type-safety. What's the best approach?","options":["Use Prisma's query builder - it can handle any SQL query with type-safety","Write raw SQL with prisma.$queryRaw for complex queries, use ORM for simple CRUD","Rewrite the database schema to make it simpler so Prisma can handle it","Use Drizzle instead - it's better at complex queries than Prisma"],"correctAnswer":1,"explanation":"**Use raw SQL for complex analytical queries, ORM for application logic.**\n\nHere's why:\n\n**✅ When to use Raw SQL:**\n- Complex analytics with CTEs, window functions, complex aggregations\n- Performance-critical queries where you need full control\n- Queries that are much simpler in SQL than ORM syntax\n- One-off reports or admin tools\n\n```typescript\n// Complex analytics - use raw SQL\nconst results = await prisma.$queryRaw`\n  WITH monthly_stats AS (\n    SELECT DATE_TRUNC('month', created_at) as month,\n           COUNT(*) as orders,\n           SUM(total) as revenue\n    FROM orders\n    GROUP BY 1\n  )\n  SELECT \n    month,\n    revenue,\n    LAG(revenue) OVER (ORDER BY month) as prev_month,\n    revenue - LAG(revenue) OVER (ORDER BY month) as growth\n  FROM monthly_stats;\n`;\n```\n\n**✅ When to use ORM:**\n- CRUD operations (create, read, update, delete)\n- Simple queries with relations\n- Application business logic\n- Type-safety is critical\n\n```typescript\n// Simple CRUD - use ORM\nconst user = await prisma.user.create({\n  data: {\n    email: 'user@example.com',\n    posts: { create: { title: 'First post' } }\n  },\n  include: { posts: true }\n});\n```\n\n**The hybrid approach is best:** Use ORM for 80% of your queries (CRUD), raw SQL for the 20% that are complex or performance-critical. Don't force complex SQL into ORM syntax - it becomes unreadable and often less efficient."}]}
