{
  "module": {
    "id": "express-apis",
    "title": "Express: RESTful APIs and Validation",
    "description": "Design professional REST APIs with validation, documentation, and best practices",
    "icon": "FileJson",
    "requiredXp": 600,
    "color": "from-blue-500 to-indigo-600",
    "courseId": "node-express"
  },
  "lessons": [
    {
      "id": "rest-principles",
      "moduleId": "express-apis",
      "title": "REST Principles",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- REST = Representational State Transfer\n- Resources identified by URLs (nouns, not verbs)\n- HTTP methods used semantically (GET, POST, PUT, DELETE)\n- Stateless: each request contains everything needed\n- Appropriate status codes (200, 201, 400, 404, 500...)\n\n---\n\n# Designing a RESTful API\n\n## Fundamental Principles\n\n### 1. Resources, Not Actions\n\n❌ Bad (URLs with verbs):\n- GET /getUsers\n- POST /createUser\n- PUT /updateUser/123\n- DELETE /deleteUser/123\n\n✅ Good (URLs with nouns, HTTP verbs for actions):\n- GET /users (list)\n- GET /users/123 (detail)\n- POST /users (create)\n- PUT /users/123 (replace)\n- PATCH /users/123 (partial update)\n- DELETE /users/123 (delete)\n\n### 2. Resource Relationships\n\n```\nGET    /users/123/posts       # Posts by user 123\nGET    /users/123/posts/456   # Specific post by user 123\nPOST   /users/123/posts       # Create a post for user 123\n```\n\n### 3. Stateless\n\nThe server keeps no client state between requests. Each request must contain:\n- Authentication (token)\n- All necessary data\n\n### 4. HTTP Status Codes\n\n| Code | Usage |\n|------|-------|\n| 200 | OK - Request successful |\n| 201 | Created - Resource created |\n| 204 | No Content - Success without body (DELETE) |\n| 400 | Bad Request - Invalid data |\n| 401 | Unauthorized - Not authenticated |\n| 403 | Forbidden - No permission |\n| 404 | Not Found - Resource doesn't exist |\n| 409 | Conflict - Conflict (e.g., email already used) |\n| 422 | Unprocessable - Validation failed |\n| 500 | Server Error - Server error |\n\n## Response Structure\n\n### Success\n```json\n{\n  \"status\": \"success\",\n  \"data\": {\n    \"id\": 1,\n    \"name\": \"John\"\n  }\n}\n```\n\n### List with Pagination\n```json\n{\n  \"status\": \"success\",\n  \"data\": [\n    { \"id\": 1, \"name\": \"John\" },\n    { \"id\": 2, \"name\": \"Jane\" }\n  ],\n  \"meta\": {\n    \"pagination\": {\n      \"page\": 1,\n      \"limit\": 20,\n      \"total\": 100,\n      \"totalPages\": 5\n    }\n  }\n}\n```\n\n### Error\n```json\n{\n  \"status\": \"error\",\n  \"message\": \"User not found\",\n  \"code\": \"USER_NOT_FOUND\"\n}\n```\n\n## Express Implementation\n\n```javascript\nimport express from 'express';\nconst app = express();\n\napp.use(express.json());\n\n// GET /users - List\napp.get('/users', async (req, res) => {\n  const { page = 1, limit = 20 } = req.query;\n  const users = await db.getUsers(page, limit);\n  \n  res.json({\n    status: 'success',\n    data: users,\n    meta: {\n      pagination: {\n        page: parseInt(page),\n        limit: parseInt(limit),\n        total: await db.countUsers()\n      }\n    }\n  });\n});\n\n// GET /users/:id - Detail\napp.get('/users/:id', async (req, res) => {\n  const user = await db.getUserById(req.params.id);\n  \n  if (!user) {\n    return res.status(404).json({\n      status: 'error',\n      message: 'User not found'\n    });\n  }\n  \n  res.json({\n    status: 'success',\n    data: user\n  });\n});\n\n// POST /users - Create\napp.post('/users', async (req, res) => {\n  try {\n    const user = await db.createUser(req.body);\n    res.status(201).json({\n      status: 'success',\n      data: user\n    });\n  } catch (error) {\n    res.status(400).json({\n      status: 'error',\n      message: error.message\n    });\n  }\n});\n\n// PUT /users/:id - Replace\napp.put('/users/:id', async (req, res) => {\n  const user = await db.updateUser(req.params.id, req.body);\n  res.json({\n    status: 'success',\n    data: user\n  });\n});\n\n// PATCH /users/:id - Partial Update\napp.patch('/users/:id', async (req, res) => {\n  const user = await db.patchUser(req.params.id, req.body);\n  res.json({\n    status: 'success',\n    data: user\n  });\n});\n\n// DELETE /users/:id - Delete\napp.delete('/users/:id', async (req, res) => {\n  await db.deleteUser(req.params.id);\n  res.status(204).send();\n});\n```"
    },
    {
      "id": "validation-zod",
      "moduleId": "express-apis",
      "title": "Validation with Zod",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Zod is a TypeScript-first validation library\n- Defines schemas to validate data at runtime\n- Better DX (Developer Experience) than Joi/Yup\n- Automatically infers TypeScript types\n\n---\n\n# Validating with Zod\n\nZod allows you to define schemas and validate that data matches. This is crucial for:\n- Securing your API\n- Having clear error messages\n- Automatically typing with TypeScript\n\n## Installation\n\n```bash\nnpm install zod\n```\n\n## Basic Schemas\n\n```javascript\nimport { z } from 'zod';\n\n// Primitive types\nconst StringSchema = z.string();\nconst NumberSchema = z.number();\nconst BooleanSchema = z.boolean();\nconst DateSchema = z.date();\n\n// Validation\nStringSchema.parse('hello');     // ✅ 'hello'\nStringSchema.parse(123);         // ❌ Throws error\n```\n\n## Advanced Validation\n\n```javascript\n// Strings\nconst EmailSchema = z.string().email();\nconst UrlSchema = z.string().url();\nconst UuidSchema = z.string().uuid();\nconst MinLengthSchema = z.string().min(5).max(100);\nconst RegexSchema = z.string().regex(/^[a-z]+$/);\n\n// Numbers\nconst PositiveInt = z.number().int().positive();\nconst PortSchema = z.number().min(1).max(65535);\n\n// Optional and defaults\nconst OptionalName = z.string().optional();  // string | undefined\nconst DefaultName = z.string().default('Anonymous');\nconst NullableName = z.string().nullable();  // string | null\n```\n\n## Objects and API Validation\n\n```javascript\n// User schema\nconst UserSchema = z.object({\n  id: z.number().int().positive(),\n  email: z.string().email(),\n  name: z.string().min(2).max(50),\n  age: z.number().int().min(0).max(150).optional(),\n  role: z.enum(['user', 'admin', 'moderator']).default('user'),\n  createdAt: z.date().default(() => new Date())\n});\n\n// Schema for creation (without id)\nconst CreateUserSchema = UserSchema.omit({ id: true, createdAt: true });\n\n// Schema for update (all optional)\nconst UpdateUserSchema = UserSchema.omit({ id: true, createdAt: true }).partial();\n\n// Extract TypeScript type\ntype User = z.infer<typeof UserSchema>;\ntype CreateUser = z.infer<typeof CreateUserSchema>;\n```\n\n## Middleware for Express\n\n```javascript\n// middleware/validate.js\nimport { z } from 'zod';\n\nexport const validate = (schema) => {\n  return (req, res, next) => {\n    try {\n      // Validate body\n      schema.parse(req.body);\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          status: 'error',\n          message: 'Validation failed',\n          errors: error.errors.map(e => ({\n            field: e.path.join('.'),\n            message: e.message\n          }))\n        });\n      }\n      next(error);\n    }\n  };\n};\n\n// Usage in routes\nimport { CreateUserSchema, UpdateUserSchema } from './schemas/user.js';\n\napp.post('/users', validate(CreateUserSchema), async (req, res) => {\n  // req.body is validated and typed\n  const user = await db.createUser(req.body);\n  res.status(201).json({\n    status: 'success',\n    data: user\n  });\n});\n\napp.patch('/users/:id', validate(UpdateUserSchema), async (req, res) => {\n  const user = await db.updateUser(req.params.id, req.body);\n  res.json({\n    status: 'success',\n    data: user\n  });\n});\n```\n\n## Validation for Params and Query\n\n```javascript\nconst ParamsSchema = z.object({\n  id: z.string().regex(/^\\d+$/).transform(Number)\n});\n\nconst QuerySchema = z.object({\n  page: z.string().optional().default('1').transform(Number),\n  limit: z.string().optional().default('20').transform(Number),\n  search: z.string().optional()\n});\n\n// Validation middleware for all inputs\nexport const validateRequest = (schemas) => {\n  return (req, res, next) => {\n    try {\n      if (schemas.body) schemas.body.parse(req.body);\n      if (schemas.params) schemas.params.parse(req.params);\n      if (schemas.query) schemas.query.parse(req.query);\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          status: 'error',\n          message: 'Validation failed',\n          errors: error.errors\n        });\n      }\n      next(error);\n    }\n  };\n};\n\n// Usage\napp.get('/users',\n  validateRequest({ query: QuerySchema }),\n  async (req, res) => {\n    const { page, limit, search } = req.query;\n    // Already validated and transformed!\n  }\n);\n```\n\n## Best Practices\n\n1. **Validate everything**: body, params, query\n2. **Use specific error messages**\n3. **Transform when possible** (e.g., string -> number)\n4. **Don't expose internal details** in error messages\n5. **Use TypeScript inference** for automatic types"
    },
    {
      "id": "api-documentation",
      "moduleId": "express-apis",
      "title": "Documenting Your API",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Documenting your API is essential for consumers\n- OpenAPI (Swagger) is the standard\n- Tools generate docs and clients from the spec\n- Keep the doc up to date (it quickly becomes obsolete)\n\n---\n\n# API Documentation with OpenAPI/Swagger\n\nOpenAPI (formerly Swagger) is a standard specification for describing REST APIs. It allows you to:\n- Generate interactive documentation\n- Validate requests/responses\n- Generate SDK clients\n\n## Installation\n\n```bash\nnpm install swagger-ui-express swagger-jsdoc\n```\n\n## Basic Configuration\n\n```javascript\nimport swaggerUi from 'swagger-ui-express';\nimport swaggerJSDoc from 'swagger-jsdoc';\n\nconst swaggerOptions = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'My API',\n      version: '1.0.0',\n      description: 'Description of my API',\n      contact: {\n        name: 'Support',\n        email: 'support@example.com'\n      }\n    },\n    servers: [\n      {\n        url: 'http://localhost:3000/api',\n        description: 'Development server'\n      },\n      {\n        url: 'https://api.example.com',\n        description: 'Production server'\n      }\n    ]\n  },\n  apis: ['./routes/*.js', './controllers/*.js']  // Files with annotations\n};\n\nconst swaggerSpec = swaggerJSDoc(swaggerOptions);\n\n// Route for documentation\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));\n\n// Route to get raw JSON\napp.get('/api-docs.json', (req, res) => {\n  res.setHeader('Content-Type', 'application/json');\n  res.send(swaggerSpec);\n});\n```\n\nAccess http://localhost:3000/api-docs to see the interactive documentation!\n\n## Annotations in Code\n\n```javascript\n/**\n * @swagger\n * /users:\n *   get:\n *     summary: Get all users\n *     description: Returns a paginated list of users\n *     tags: [Users]\n *     parameters:\n *       - in: query\n *         name: page\n *         schema:\n *           type: integer\n *           default: 1\n *         description: Page number\n *       - in: query\n *         name: limit\n *         schema:\n *           type: integer\n *           default: 20\n *         description: Number of items per page\n *     responses:\n *       200:\n *         description: List of users\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 status:\n *                   type: string\n *                 data:\n *                   type: array\n *                   items:\n *                     $ref: '#/components/schemas/User'\n *       401:\n *         description: Unauthorized\n */\napp.get('/users', getUsers);\n\n/**\n * @swagger\n * /users:\n *   post:\n *     summary: Create a new user\n *     tags: [Users]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             $ref: '#/components/schemas/CreateUser'\n *     responses:\n *       201:\n *         description: User created\n *       400:\n *         description: Invalid data\n */\napp.post('/users', validate(CreateUserSchema), createUser);\n\n// Schema definitions\n/**\n * @swagger\n * components:\n *   schemas:\n *     User:\n *       type: object\n *       properties:\n *         id:\n *           type: integer\n *         email:\n *           type: string\n *         name:\n *           type: string\n *         createdAt:\n *           type: string\n *           format: date-time\n *     CreateUser:\n *       type: object\n *       required:\n *         - email\n *         - name\n *       properties:\n *         email:\n *           type: string\n *         name:\n *           type: string\n *         age:\n *           type: integer\n */\n```\n\n## Alternatives to JSDoc\n\n### Manual YAML/JSON\n\nCreate `openapi.yaml`:\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: My API\n  version: 1.0.0\npaths:\n  /users:\n    get:\n      summary: Get all users\n      responses:\n        '200':\n          description: OK\n```\n\n### Using Postman\n\n1. Create your API in Postman\n2. Export to OpenAPI format\n3. Import into your project\n\n## Best Practices\n\n1. **Document as you code**: Don't leave it for later\n2. **Use tags** to organize endpoints\n3. **Include examples** in schemas\n4. **Document errors** as well as successes\n5. **Keep it up to date**: Outdated docs are worse than no docs\n6. **Add authentication info**: How to obtain and use tokens"
    },
    {
      "id": "api-testing",
      "moduleId": "express-apis",
      "title": "Testing Your API",
      "order": 4,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Test your API endpoints automatically\n- Supertest to test HTTP without starting a server\n- Test both successes AND errors\n- Mock external dependencies (DB, APIs)\n\n---\n\n# Integration Testing for APIs\n\nAPI tests verify that your endpoints work correctly without having to manually start the server.\n\n## Setup with Jest and Supertest\n\n```bash\nnpm install --save-dev jest supertest\n```\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\"\n  }\n}\n```\n\n## Test Structure\n\n```javascript\n// tests/users.test.js\nimport request from 'supertest';\nimport app from '../src/app.js';\nimport { User } from '../src/models/User.js';\n\ndescribe('Users API', () => {\n  beforeEach(async () => {\n    // Clean DB before each test\n    await User.deleteMany();\n  });\n\n  describe('GET /api/users', () => {\n    it('should return empty array when no users', async () => {\n      const response = await request(app)\n        .get('/api/users')\n        .expect('Content-Type', /json/)\n        .expect(200);\n      \n      expect(response.body.data).toEqual([]);\n    });\n\n    it('should return list of users', async () => {\n      // Create test data\n      await User.create([\n        { name: 'John', email: 'john@test.com' },\n        { name: 'Jane', email: 'jane@test.com' }\n      ]);\n      \n      const response = await request(app)\n        .get('/api/users')\n        .expect(200);\n      \n      expect(response.body.data).toHaveLength(2);\n      expect(response.body.data[0].name).toBe('John');\n    });\n  });\n\n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      const newUser = {\n        name: 'Test User',\n        email: 'test@example.com',\n        password: 'password123'\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(newUser)\n        .expect('Content-Type', /json/)\n        .expect(201);\n      \n      expect(response.body.data.name).toBe('Test User');\n      expect(response.body.data.email).toBe('test@example.com');\n      expect(response.body.data.password).toBeUndefined(); // Should not return password\n    });\n\n    it('should return 400 for invalid data', async () => {\n      const invalidUser = {\n        name: 'A',  // Too short\n        email: 'invalid-email'\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(invalidUser)\n        .expect(400);\n      \n      expect(response.body.status).toBe('error');\n      expect(response.body.errors).toBeDefined();\n    });\n  });\n\n  describe('GET /api/users/:id', () => {\n    it('should return user by id', async () => {\n      const user = await User.create({\n        name: 'John',\n        email: 'john@test.com'\n      });\n      \n      const response = await request(app)\n        .get(`/api/users/${user.id}`)\n        .expect(200);\n      \n      expect(response.body.data.name).toBe('John');\n    });\n\n    it('should return 404 for non-existent user', async () => {\n      const response = await request(app)\n        .get('/api/users/999999')\n        .expect(404);\n      \n      expect(response.body.status).toBe('error');\n    });\n  });\n});\n```\n\n## Testing with Authentication\n\n```javascript\n// tests/auth.test.js\ndescribe('Protected Routes', () => {\n  let authToken;\n  let userId;\n\n  beforeEach(async () => {\n    // Create user and login\n    const user = await User.create({\n      email: 'test@test.com',\n      password: await hashPassword('password123')\n    });\n    userId = user.id;\n\n    const loginResponse = await request(app)\n      .post('/auth/login')\n      .send({ email: 'test@test.com', password: 'password123' });\n    \n    authToken = loginResponse.body.accessToken;\n  });\n\n  it('should access protected route with token', async () => {\n    const response = await request(app)\n      .get('/api/profile')\n      .set('Authorization', `Bearer ${authToken}`)\n      .expect(200);\n    \n    expect(response.body.data.email).toBe('test@test.com');\n  });\n\n  it('should reject request without token', async () => {\n    const response = await request(app)\n      .get('/api/profile')\n      .expect(401);\n    \n    expect(response.body.error).toBe('Token required');\n  });\n\n  it('should reject request with invalid token', async () => {\n    const response = await request(app)\n      .get('/api/profile')\n      .set('Authorization', 'Bearer invalid-token')\n      .expect(401);\n    \n    expect(response.body.error).toBe('Invalid or expired token');\n  });\n});\n```\n\n## Testing Best Practices\n\n1. **Use separate test database**\n2. **Clean up before/after tests**\n3. **Test both success and error cases**\n4. **Don't test implementation, test behavior**\n5. **Use realistic test data**\n6. **Test edge cases** (empty inputs, large data, etc.)\n7. **Mock external services** (emails, payments, etc.)"
    }
  ],
  "exercises": []
}
