{
  "module": {
    "id": "express-apis",
    "title": "Express: RESTful APIs and Validation",
    "description": "Design professional REST APIs with validation, documentation, and best practices",
    "icon": "FileJson",
    "requiredXp": 600,
    "color": "from-blue-500 to-indigo-600",
    "courseId": "node-express"
  },
  "lessons": [
    {
      "id": "rest-principles",
      "moduleId": "express-apis",
      "title": "REST Principles",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- REST = Representational State Transfer\n- Resources identified by URLs (nouns, not verbs)\n- HTTP methods used semantically (GET, POST, PUT, DELETE)\n- Stateless: each request contains everything needed\n- Appropriate status codes (200, 201, 400, 404, 500...)\n\n---\n\n# Designing a RESTful API\n\n## Fundamental Principles\n\n### 1. Resources, Not Actions\n\n❌ Bad (URLs with verbs):\n- GET /getUsers\n- POST /createUser\n- PUT /updateUser/123\n- DELETE /deleteUser/123\n\n✅ Good (URLs with nouns, HTTP verbs for actions):\n- GET /users (list)\n- GET /users/123 (detail)\n- POST /users (create)\n- PUT /users/123 (replace)\n- PATCH /users/123 (partial update)\n- DELETE /users/123 (delete)\n\n### 2. Resource Relationships\n\n```\nGET    /users/123/posts       # Posts by user 123\nGET    /users/123/posts/456   # Specific post by user 123\nPOST   /users/123/posts       # Create a post for user 123\n```\n\n### 3. Stateless\n\nThe server keeps no client state between requests. Each request must contain:\n- Authentication (token)\n- All necessary data\n\n### 4. HTTP Status Codes\n\n| Code | Usage |\n|------|-------|\n| 200 | OK - Request successful |\n| 201 | Created - Resource created |\n| 204 | No Content - Success without body (DELETE) |\n| 400 | Bad Request - Invalid data |\n| 401 | Unauthorized - Not authenticated |\n| 403 | Forbidden - No permission |\n| 404 | Not Found - Resource doesn't exist |\n| 409 | Conflict - Conflict (e.g., email already used) |\n| 422 | Unprocessable - Validation failed |\n| 500 | Server Error - Server error |\n\n## Response Structure\n\n### Success\n```json\n{\n  \"status\": \"success\",\n  \"data\": {\n    \"id\": 1,\n    \"name\": \"John\"\n  }\n}\n```\n\n### List with Pagination\n```json\n{\n  \"status\": \"success\",\n  \"data\": [\n    { \"id\": 1, \"name\": \"John\" },\n    { \"id\": 2, \"name\": \"Jane\" }\n  ],\n  \"meta\": {\n    \"pagination\": {\n      \"page\": 1,\n      \"limit\": 20,\n      \"total\": 100,\n      \"totalPages\": 5\n    }\n  }\n}\n```\n\n### Error\n```json\n{\n  \"status\": \"error\",\n  \"message\": \"User not found\",\n  \"code\": \"USER_NOT_FOUND\"\n}\n```\n\n## Express Implementation\n\n```javascript\nimport express from 'express';\nconst app = express();\n\napp.use(express.json());\n\n// GET /users - List\napp.get('/users', async (req, res) => {\n  const { page = 1, limit = 20 } = req.query;\n  const users = await db.getUsers(page, limit);\n  \n  res.json({\n    status: 'success',\n    data: users,\n    meta: {\n      pagination: {\n        page: parseInt(page),\n        limit: parseInt(limit),\n        total: await db.countUsers()\n      }\n    }\n  });\n});\n\n// GET /users/:id - Detail\napp.get('/users/:id', async (req, res) => {\n  const user = await db.getUserById(req.params.id);\n  \n  if (!user) {\n    return res.status(404).json({\n      status: 'error',\n      message: 'User not found'\n    });\n  }\n  \n  res.json({\n    status: 'success',\n    data: user\n  });\n});\n\n// POST /users - Create\napp.post('/users', async (req, res) => {\n  try {\n    const user = await db.createUser(req.body);\n    res.status(201).json({\n      status: 'success',\n      data: user\n    });\n  } catch (error) {\n    res.status(400).json({\n      status: 'error',\n      message: error.message\n    });\n  }\n});\n\n// PUT /users/:id - Replace\napp.put('/users/:id', async (req, res) => {\n  const user = await db.updateUser(req.params.id, req.body);\n  res.json({\n    status: 'success',\n    data: user\n  });\n});\n\n// PATCH /users/:id - Partial Update\napp.patch('/users/:id', async (req, res) => {\n  const user = await db.patchUser(req.params.id, req.body);\n  res.json({\n    status: 'success',\n    data: user\n  });\n});\n\n// DELETE /users/:id - Delete\napp.delete('/users/:id', async (req, res) => {\n  await db.deleteUser(req.params.id);\n  res.status(204).send();\n});\n```"
    },
    {
      "id": "validation-zod",
      "moduleId": "express-apis",
      "title": "Validation with Zod",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Zod is a TypeScript-first validation library\n- Defines schemas to validate data at runtime\n- Better DX (Developer Experience) than Joi/Yup\n- Automatically infers TypeScript types\n\n---\n\n# Validating with Zod\n\nZod allows you to define schemas and validate that data matches. This is crucial for:\n- Securing your API\n- Having clear error messages\n- Automatically typing with TypeScript\n\n## Installation\n\n```bash\nnpm install zod\n```\n\n## Basic Schemas\n\n```javascript\nimport { z } from 'zod';\n\n// Primitive types\nconst StringSchema = z.string();\nconst NumberSchema = z.number();\nconst BooleanSchema = z.boolean();\nconst DateSchema = z.date();\n\n// Validation\nStringSchema.parse('hello');     // ✅ 'hello'\nStringSchema.parse(123);         // ❌ Throws error\n```\n\n## Advanced Validation\n\n```javascript\n// Strings\nconst EmailSchema = z.string().email();\nconst UrlSchema = z.string().url();\nconst UuidSchema = z.string().uuid();\nconst MinLengthSchema = z.string().min(5).max(100);\nconst RegexSchema = z.string().regex(/^[a-z]+$/);\n\n// Numbers\nconst PositiveInt = z.number().int().positive();\nconst PortSchema = z.number().min(1).max(65535);\n\n// Optional and defaults\nconst OptionalName = z.string().optional();  // string | undefined\nconst DefaultName = z.string().default('Anonymous');\nconst NullableName = z.string().nullable();  // string | null\n```\n\n## Objects and API Validation\n\n```javascript\n// User schema\nconst UserSchema = z.object({\n  id: z.number().int().positive(),\n  email: z.string().email(),\n  name: z.string().min(2).max(50),\n  age: z.number().int().min(0).max(150).optional(),\n  role: z.enum(['user', 'admin', 'moderator']).default('user'),\n  createdAt: z.date().default(() => new Date())\n});\n\n// Schema for creation (without id)\nconst CreateUserSchema = UserSchema.omit({ id: true, createdAt: true });\n\n// Schema for update (all optional)\nconst UpdateUserSchema = UserSchema.omit({ id: true, createdAt: true }).partial();\n\n// Extract TypeScript type\ntype User = z.infer<typeof UserSchema>;\ntype CreateUser = z.infer<typeof CreateUserSchema>;\n```\n\n## Middleware for Express\n\n```javascript\n// middleware/validate.js\nimport { z } from 'zod';\n\nexport const validate = (schema) => {\n  return (req, res, next) => {\n    try {\n      // Validate body\n      schema.parse(req.body);\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          status: 'error',\n          message: 'Validation failed',\n          errors: error.errors.map(e => ({\n            field: e.path.join('.'),\n            message: e.message\n          }))\n        });\n      }\n      next(error);\n    }\n  };\n};\n\n// Usage in routes\nimport { CreateUserSchema, UpdateUserSchema } from './schemas/user.js';\n\napp.post('/users', validate(CreateUserSchema), async (req, res) => {\n  // req.body is validated and typed\n  const user = await db.createUser(req.body);\n  res.status(201).json({\n    status: 'success',\n    data: user\n  });\n});\n\napp.patch('/users/:id', validate(UpdateUserSchema), async (req, res) => {\n  const user = await db.updateUser(req.params.id, req.body);\n  res.json({\n    status: 'success',\n    data: user\n  });\n});\n```\n\n## Validation for Params and Query\n\n```javascript\nconst ParamsSchema = z.object({\n  id: z.string().regex(/^\\d+$/).transform(Number)\n});\n\nconst QuerySchema = z.object({\n  page: z.string().optional().default('1').transform(Number),\n  limit: z.string().optional().default('20').transform(Number),\n  search: z.string().optional()\n});\n\n// Validation middleware for all inputs\nexport const validateRequest = (schemas) => {\n  return (req, res, next) => {\n    try {\n      if (schemas.body) schemas.body.parse(req.body);\n      if (schemas.params) schemas.params.parse(req.params);\n      if (schemas.query) schemas.query.parse(req.query);\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          status: 'error',\n          message: 'Validation failed',\n          errors: error.errors\n        });\n      }\n      next(error);\n    }\n  };\n};\n\n// Usage\napp.get('/users',\n  validateRequest({ query: QuerySchema }),\n  async (req, res) => {\n    const { page, limit, search } = req.query;\n    // Already validated and transformed!\n  }\n);\n```\n\n## Best Practices\n\n1. **Validate everything**: body, params, query\n2. **Use specific error messages**\n3. **Transform when possible** (e.g., string -> number)\n4. **Don't expose internal details** in error messages\n5. **Use TypeScript inference** for automatic types"
    },
    {
      "id": "api-documentation",
      "moduleId": "express-apis",
      "title": "Documenting Your API",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Documenting your API is essential for consumers\n- OpenAPI (Swagger) is the standard\n- Tools generate docs and clients from the spec\n- Keep the doc up to date (it quickly becomes obsolete)\n\n---\n\n# API Documentation with OpenAPI/Swagger\n\nOpenAPI (formerly Swagger) is a standard specification for describing REST APIs. It allows you to:\n- Generate interactive documentation\n- Validate requests/responses\n- Generate SDK clients\n\n## Installation\n\n```bash\nnpm install swagger-ui-express swagger-jsdoc\n```\n\n## Basic Configuration\n\n```javascript\nimport swaggerUi from 'swagger-ui-express';\nimport swaggerJSDoc from 'swagger-jsdoc';\n\nconst swaggerOptions = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'My API',\n      version: '1.0.0',\n      description: 'Description of my API',\n      contact: {\n        name: 'Support',\n        email: 'support@example.com'\n      }\n    },\n    servers: [\n      {\n        url: 'http://localhost:3000/api',\n        description: 'Development server'\n      },\n      {\n        url: 'https://api.example.com',\n        description: 'Production server'\n      }\n    ]\n  },\n  apis: ['./routes/*.js', './controllers/*.js']  // Files with annotations\n};\n\nconst swaggerSpec = swaggerJSDoc(swaggerOptions);\n\n// Route for documentation\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));\n\n// Route to get raw JSON\napp.get('/api-docs.json', (req, res) => {\n  res.setHeader('Content-Type', 'application/json');\n  res.send(swaggerSpec);\n});\n```\n\nAccess http://localhost:3000/api-docs to see the interactive documentation!\n\n## Annotations in Code\n\n```javascript\n/**\n * @swagger\n * /users:\n *   get:\n *     summary: Get all users\n *     description: Returns a paginated list of users\n *     tags: [Users]\n *     parameters:\n *       - in: query\n *         name: page\n *         schema:\n *           type: integer\n *           default: 1\n *         description: Page number\n *       - in: query\n *         name: limit\n *         schema:\n *           type: integer\n *           default: 20\n *         description: Number of items per page\n *     responses:\n *       200:\n *         description: List of users\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 status:\n *                   type: string\n *                 data:\n *                   type: array\n *                   items:\n *                     $ref: '#/components/schemas/User'\n *       401:\n *         description: Unauthorized\n */\napp.get('/users', getUsers);\n\n/**\n * @swagger\n * /users:\n *   post:\n *     summary: Create a new user\n *     tags: [Users]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             $ref: '#/components/schemas/CreateUser'\n *     responses:\n *       201:\n *         description: User created\n *       400:\n *         description: Invalid data\n */\napp.post('/users', validate(CreateUserSchema), createUser);\n\n// Schema definitions\n/**\n * @swagger\n * components:\n *   schemas:\n *     User:\n *       type: object\n *       properties:\n *         id:\n *           type: integer\n *         email:\n *           type: string\n *         name:\n *           type: string\n *         createdAt:\n *           type: string\n *           format: date-time\n *     CreateUser:\n *       type: object\n *       required:\n *         - email\n *         - name\n *       properties:\n *         email:\n *           type: string\n *         name:\n *           type: string\n *         age:\n *           type: integer\n */\n```\n\n## Alternatives to JSDoc\n\n### Manual YAML/JSON\n\nCreate `openapi.yaml`:\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: My API\n  version: 1.0.0\npaths:\n  /users:\n    get:\n      summary: Get all users\n      responses:\n        '200':\n          description: OK\n```\n\n### Using Postman\n\n1. Create your API in Postman\n2. Export to OpenAPI format\n3. Import into your project\n\n## Best Practices\n\n1. **Document as you code**: Don't leave it for later\n2. **Use tags** to organize endpoints\n3. **Include examples** in schemas\n4. **Document errors** as well as successes\n5. **Keep it up to date**: Outdated docs are worse than no docs\n6. **Add authentication info**: How to obtain and use tokens"
    },
    {
      "id": "api-testing",
      "moduleId": "express-apis",
      "title": "Testing Your API",
      "order": 4,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Test your API endpoints automatically\n- Supertest to test HTTP without starting a server\n- Test both successes AND errors\n- Mock external dependencies (DB, APIs)\n\n---\n\n# Integration Testing for APIs\n\nAPI tests verify that your endpoints work correctly without having to manually start the server.\n\n## Setup with Jest and Supertest\n\n```bash\nnpm install --save-dev jest supertest\n```\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\"\n  }\n}\n```\n\n## Test Structure\n\n```javascript\n// tests/users.test.js\nimport request from 'supertest';\nimport app from '../src/app.js';\nimport { User } from '../src/models/User.js';\n\ndescribe('Users API', () => {\n  beforeEach(async () => {\n    // Clean DB before each test\n    await User.deleteMany();\n  });\n\n  describe('GET /api/users', () => {\n    it('should return empty array when no users', async () => {\n      const response = await request(app)\n        .get('/api/users')\n        .expect('Content-Type', /json/)\n        .expect(200);\n      \n      expect(response.body.data).toEqual([]);\n    });\n\n    it('should return list of users', async () => {\n      // Create test data\n      await User.create([\n        { name: 'John', email: 'john@test.com' },\n        { name: 'Jane', email: 'jane@test.com' }\n      ]);\n      \n      const response = await request(app)\n        .get('/api/users')\n        .expect(200);\n      \n      expect(response.body.data).toHaveLength(2);\n      expect(response.body.data[0].name).toBe('John');\n    });\n  });\n\n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      const newUser = {\n        name: 'Test User',\n        email: 'test@example.com',\n        password: 'password123'\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(newUser)\n        .expect('Content-Type', /json/)\n        .expect(201);\n      \n      expect(response.body.data.name).toBe('Test User');\n      expect(response.body.data.email).toBe('test@example.com');\n      expect(response.body.data.password).toBeUndefined(); // Should not return password\n    });\n\n    it('should return 400 for invalid data', async () => {\n      const invalidUser = {\n        name: 'A',  // Too short\n        email: 'invalid-email'\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(invalidUser)\n        .expect(400);\n      \n      expect(response.body.status).toBe('error');\n      expect(response.body.errors).toBeDefined();\n    });\n  });\n\n  describe('GET /api/users/:id', () => {\n    it('should return user by id', async () => {\n      const user = await User.create({\n        name: 'John',\n        email: 'john@test.com'\n      });\n      \n      const response = await request(app)\n        .get(`/api/users/${user.id}`)\n        .expect(200);\n      \n      expect(response.body.data.name).toBe('John');\n    });\n\n    it('should return 404 for non-existent user', async () => {\n      const response = await request(app)\n        .get('/api/users/999999')\n        .expect(404);\n      \n      expect(response.body.status).toBe('error');\n    });\n  });\n});\n```\n\n## Testing with Authentication\n\n```javascript\n// tests/auth.test.js\ndescribe('Protected Routes', () => {\n  let authToken;\n  let userId;\n\n  beforeEach(async () => {\n    // Create user and login\n    const user = await User.create({\n      email: 'test@test.com',\n      password: await hashPassword('password123')\n    });\n    userId = user.id;\n\n    const loginResponse = await request(app)\n      .post('/auth/login')\n      .send({ email: 'test@test.com', password: 'password123' });\n    \n    authToken = loginResponse.body.accessToken;\n  });\n\n  it('should access protected route with token', async () => {\n    const response = await request(app)\n      .get('/api/profile')\n      .set('Authorization', `Bearer ${authToken}`)\n      .expect(200);\n    \n    expect(response.body.data.email).toBe('test@test.com');\n  });\n\n  it('should reject request without token', async () => {\n    const response = await request(app)\n      .get('/api/profile')\n      .expect(401);\n    \n    expect(response.body.error).toBe('Token required');\n  });\n\n  it('should reject request with invalid token', async () => {\n    const response = await request(app)\n      .get('/api/profile')\n      .set('Authorization', 'Bearer invalid-token')\n      .expect(401);\n    \n    expect(response.body.error).toBe('Invalid or expired token');\n  });\n});\n```\n\n## Testing Best Practices\n\n1. **Use separate test database**\n2. **Clean up before/after tests**\n3. **Test both success and error cases**\n4. **Don't test implementation, test behavior**\n5. **Use realistic test data**\n6. **Test edge cases** (empty inputs, large data, etc.)\n7. **Mock external services** (emails, payments, etc.)"
    }
  ],
  "exercises": [
    {
      "id": "api-get-filter",
      "lessonId": "rest-principles",
      "moduleId": "express-apis",
      "title": "Complete the GET Endpoint",
      "difficulty": "easy",
      "description": "Complete a GET endpoint that filters users by age.",
      "instructions": "You're building a user API. Complete the `/api/users` endpoint that:\n1. Returns all users if no query param is provided\n2. Filters users by minimum age if `minAge` query param exists\n3. Returns proper JSON response with status field\n\nThe users array is already defined for you.",
      "starterCode": "import express from 'express';\nconst app = express();\n\nconst users = [\n  { id: 1, name: 'Alice', age: 25 },\n  { id: 2, name: 'Bob', age: 17 },\n  { id: 3, name: 'Charlie', age: 30 }\n];\n\napp.get('/api/users', (req, res) => {\n  // TODO: Get minAge from query params\n  // TODO: Filter users if minAge is provided\n  // TODO: Return JSON with status and data fields\n\n});",
      "solution": "import express from 'express';\nconst app = express();\n\nconst users = [\n  { id: 1, name: 'Alice', age: 25 },\n  { id: 2, name: 'Bob', age: 17 },\n  { id: 3, name: 'Charlie', age: 30 }\n];\n\napp.get('/api/users', (req, res) => {\n  const { minAge } = req.query;\n  \n  let filteredUsers = users;\n  if (minAge) {\n    filteredUsers = users.filter(u => u.age >= parseInt(minAge));\n  }\n  \n  res.json({\n    status: 'success',\n    data: filteredUsers\n  });\n});",
      "hints": [
        "Use req.query to get query parameters",
        "Remember to parse minAge to a number with parseInt()",
        "Use array.filter() to filter users by age"
      ],
      "validationPrompt": "Check that the solution: 1) Uses req.query to get minAge, 2) Filters users when minAge is provided using filter(), 3) Returns all users when no minAge is provided, 4) Returns proper JSON with status and data fields"
    },
    {
      "id": "api-fix-validation",
      "lessonId": "validation-zod",
      "moduleId": "express-apis",
      "title": "Fix the Broken Validation",
      "difficulty": "medium",
      "description": "An AI generated this POST route but the validation is broken. Fix it!",
      "instructions": "The AI generated a POST route for creating products, but there are several bugs:\n1. The Zod schema allows invalid prices (negative numbers)\n2. The name validation is too permissive\n3. The validation middleware doesn't handle errors properly\n\nFix all three issues:\n- Name should be 2-100 characters\n- Price must be positive\n- Validation errors should return 400 with proper error format",
      "starterCode": "import express from 'express';\nimport { z } from 'zod';\nconst app = express();\n\napp.use(express.json());\n\nconst ProductSchema = z.object({\n  name: z.string(),\n  price: z.number()\n});\n\nconst validate = (schema) => {\n  return (req, res, next) => {\n    schema.parse(req.body);\n    next();\n  };\n};\n\napp.post('/api/products', validate(ProductSchema), (req, res) => {\n  res.status(201).json({\n    status: 'success',\n    data: req.body\n  });\n});",
      "solution": "import express from 'express';\nimport { z } from 'zod';\nconst app = express();\n\napp.use(express.json());\n\nconst ProductSchema = z.object({\n  name: z.string().min(2).max(100),\n  price: z.number().positive()\n});\n\nconst validate = (schema) => {\n  return (req, res, next) => {\n    try {\n      schema.parse(req.body);\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          status: 'error',\n          message: 'Validation failed',\n          errors: error.errors\n        });\n      }\n      next(error);\n    }\n  };\n};\n\napp.post('/api/products', validate(ProductSchema), (req, res) => {\n  res.status(201).json({\n    status: 'success',\n    data: req.body\n  });\n});",
      "hints": [
        "Add .min(2).max(100) to the name string validation",
        "Add .positive() to the price number validation",
        "Wrap schema.parse() in try/catch to handle ZodError",
        "Check if error is instanceof z.ZodError before handling it"
      ],
      "validationPrompt": "Check that: 1) ProductSchema validates name with min(2) and max(100), 2) ProductSchema validates price as positive number, 3) validate middleware catches errors with try/catch, 4) ZodError returns 400 status with error details"
    },
    {
      "id": "api-debug-404",
      "lessonId": "rest-principles",
      "moduleId": "express-apis",
      "title": "Debug: Why Always 404?",
      "difficulty": "medium",
      "description": "This route always returns 404. Find and fix the bug!",
      "instructions": "A developer copied this code from ChatGPT but `/api/users/123` always returns 404 even though the user exists.\n\nDebug the code and fix the issue. The bug is in how the route compares the ID.",
      "starterCode": "import express from 'express';\nconst app = express();\n\nconst users = [\n  { id: 1, name: 'Alice' },\n  { id: 2, name: 'Bob' },\n  { id: 3, name: 'Charlie' }\n];\n\napp.get('/api/users/:id', (req, res) => {\n  const user = users.find(u => u.id === req.params.id);\n  \n  if (!user) {\n    return res.status(404).json({\n      status: 'error',\n      message: 'User not found'\n    });\n  }\n  \n  res.json({\n    status: 'success',\n    data: user\n  });\n});",
      "solution": "import express from 'express';\nconst app = express();\n\nconst users = [\n  { id: 1, name: 'Alice' },\n  { id: 2, name: 'Bob' },\n  { id: 3, name: 'Charlie' }\n];\n\napp.get('/api/users/:id', (req, res) => {\n  const user = users.find(u => u.id === parseInt(req.params.id));\n  \n  if (!user) {\n    return res.status(404).json({\n      status: 'error',\n      message: 'User not found'\n    });\n  }\n  \n  res.json({\n    status: 'success',\n    data: user\n  });\n});",
      "hints": [
        "req.params.id is always a string, not a number",
        "The user IDs in the array are numbers",
        "Use parseInt() to convert the string to a number",
        "Alternatively, you could use == instead of === for loose comparison"
      ],
      "validationPrompt": "Check that the solution converts req.params.id to a number (using parseInt or Number) before comparing with user.id, or uses loose equality (==) instead of strict equality (===)"
    },
    {
      "id": "api-error-handling",
      "lessonId": "rest-principles",
      "moduleId": "express-apis",
      "title": "Add Error Handling to Async Route",
      "difficulty": "medium",
      "description": "Add proper error handling to this async endpoint.",
      "instructions": "This async route can crash the server if the database throws an error. Add proper error handling:\n1. Wrap the async code in try/catch\n2. Return 500 status on errors\n3. Send proper error response format\n4. Don't expose internal error details to the client",
      "starterCode": "import express from 'express';\nconst app = express();\n\napp.use(express.json());\n\n// Simulated async database\nconst db = {\n  async createUser(data) {\n    // Simulates potential database errors\n    if (!data.email) throw new Error('Database: email is required');\n    return { id: Date.now(), ...data };\n  }\n};\n\napp.post('/api/users', async (req, res) => {\n  const user = await db.createUser(req.body);\n  res.status(201).json({\n    status: 'success',\n    data: user\n  });\n});",
      "solution": "import express from 'express';\nconst app = express();\n\napp.use(express.json());\n\n// Simulated async database\nconst db = {\n  async createUser(data) {\n    // Simulates potential database errors\n    if (!data.email) throw new Error('Database: email is required');\n    return { id: Date.now(), ...data };\n  }\n};\n\napp.post('/api/users', async (req, res) => {\n  try {\n    const user = await db.createUser(req.body);\n    res.status(201).json({\n      status: 'success',\n      data: user\n    });\n  } catch (error) {\n    res.status(500).json({\n      status: 'error',\n      message: 'Failed to create user'\n    });\n  }\n});",
      "hints": [
        "Use try/catch to wrap async operations",
        "Return 500 status code for server errors",
        "Don't send error.message directly - it might expose internal details",
        "Send a generic error message to the client"
      ],
      "validationPrompt": "Check that: 1) The async code is wrapped in try/catch, 2) The catch block returns 500 status, 3) Error response has proper format with status and message, 4) The error message is generic (not exposing internal error details)"
    }
  ]
}
