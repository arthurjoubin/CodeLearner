{
  "module": {
    "id": "auth-fundamentals",
    "title": "Auth: Fundamental Concepts",
    "description": "Understand authentication vs authorization, password hashing and best practices",
    "icon": "Shield",
    "requiredXp": 1100,
    "color": "from-red-500 to-orange-500",
    "courseId": "auth-security"
  },
  "lessons": [
    {
      "id": "auth-concepts",
      "moduleId": "auth-fundamentals",
      "title": "Authentication vs Authorization",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Authentication = Who are you? (identity verification)\n- Authorization = What can you do? (permissions)\n- Authentication ≠ Authorization\n- Typical flow: Login → Token → Access resources\n\n---\n\n# Fundamental Security Concepts\n\n## Authentication (AuthN)\n\nAuthentication verifies a user's identity. It answers the question: \"Are you really who you claim to be?\"\n\n### Authentication Methods\n\n1. **Password** (Something you know)\n   - Most common, but weakest\n   - Risks: phishing, brute force, reuse\n\n2. **Token** (Something you have)\n   - JWT, sessions, API keys\n   - Sent with each request after login\n\n3. **Biometrics** (Something you are)\n   - Fingerprint, facial recognition\n   - Used on mobile, rare on web\n\n4. **Multi-Factor Authentication (MFA/2FA)**\n   - Combines 2+ methods (password + SMS/app)\n   - Strongly recommended for production\n\n## Authorization (AuthZ)\n\nAuthorization determines what an authenticated user can do.\n\n### Authorization Types\n\n1. **RBAC** (Role-Based Access Control)\n   ```\n   User → Role → Permissions\n   \n   Alice → Admin → [create, read, update, delete]\n   Bob → User → [read, update_own]\n   ```\n\n2. **ABAC** (Attribute-Based Access Control)\n   ```\n   Access based on:\n   - User attributes (department, seniority)\n   - Resource attributes (owner, classification)\n   - Environment (time, location)\n   ```\n\n3. **ACL** (Access Control Lists)\n   ```\n   Resource X:\n   - Alice: read, write\n   - Bob: read\n   - Charlie: none\n   ```\n\n## Typical Authentication Flow\n\n```\n┌─────────┐         ┌──────────┐         ┌─────────┐\n│  Client │────────>│  Server  │────────>│   DB    │\n│         │  login  │          │ verify  │         │\n│         │────────>│          │────────>│         │\n│         │         │          │         │         │\n│         │<────────│          │<────────│         │\n│         │  token  │          │  user   │         │\n│         │         │          │         │         │\n│         │────────>│          │         │         │\n│         │request  │          │         │         │\n│         │+ token  │          │         │         │\n│         │<────────│          │         │         │\n│         │  data   │          │         │         │\n└─────────┘         └──────────┘         └─────────┘\n```\n\n## General Best Practices\n\n### 1. Never trust the client\n```javascript\n// ❌ Bad: believing what the client sends\napp.post('/update-profile', (req, res) => {\n  updateUser(req.body.userId, req.body.data);  // Danger!\n});\n\n// ✅ Good: verify identity server-side\napp.post('/update-profile', requireAuth, (req, res) => {\n  updateUser(req.userId, req.body.data);  // userId from verified token\n});\n```\n\n### 2. Validation at each layer\n- Client: Quick UX\n- API: Strict validation (Zod/Joi)\n- DB: Constraints and types\n\n### 3. Defense in depth\n- Multiple security layers\n- If one fails, others protect\n- Ex: Auth + Rate limiting + Input validation\n\n### 4. Least privilege\n- Grant only necessary permissions\n- Tokens with limited scope\n- DB user with restricted permissions\n\n### 5. Fail securely\n- In case of error, deny access\n- Never open by default\n- Log suspicious attempts"
    },
    {
      "id": "auth-passwords",
      "moduleId": "auth-fundamentals",
      "title": "Password Hashing",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- NEVER store passwords in plain text\n- Use bcrypt or Argon2 for hashing\n- Unique salt for each password\n- Constant-time comparisons (timing attacks)\n\n---\n\n# Why Hash Passwords?\n\n## ❌ NEVER do this\n\n```javascript\n// ABSOLUTE HORROR\nconst user = {\n  email: 'john@example.com',\n  password: 'mySuperPassword123'  // ⚠️ PLAIN TEXT!\n};\n```\n\nIf your database is compromised (SQL injection, leak, hack), all passwords are visible.\n\n## Consequences of a Password Leak\n\n1. **Direct access**: Attacker logs in with these credentials\n2. **Credential stuffing**: Tests on other sites (people reuse)\n3. **Reputation**: Loss of user trust\n4. **Legal**: GDPR, possible penalties\n\n## Hashing vs Encryption\n\n|  | Hashing | Encryption |\n|--|---------|-------------|\n| **Reversible** | ❌ No | ✅ Yes (with key) |\n| **Usage** | Passwords | Sensitive data |\n| **Examples** | bcrypt, Argon2 | AES, RSA |\n\n**Rule**: Passwords are hashed, not encrypted!\n\n## bcrypt: The Standard\n\n```bash\nnpm install bcrypt\n```\n\n```javascript\nimport bcrypt from 'bcrypt';\n\nconst SALT_ROUNDS = 12;  // 10-12 recommended\n\n// Hash a password\nasync function hashPassword(password) {\n  const salt = await bcrypt.genSalt(SALT_ROUNDS);\n  const hash = await bcrypt.hash(password, salt);\n  return hash;\n  // Result: $2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.VTtYA.qGZvKG6G\n  // Format: $2b$ = bcrypt, 12$ = cost factor, rest = salt + hash\n}\n\n// Verify a password\nasync function verifyPassword(password, hash) {\n  return bcrypt.compare(password, hash);\n  // Returns true/false\n}\n\n// Usage in application\napp.post('/register', async (req, res) => {\n  const { email, password } = req.body;\n  \n  const passwordHash = await hashPassword(password);\n  \n  const user = await db.createUser({\n    email,\n    passwordHash,  // Store the hash, never the password!\n  });\n  \n  res.json({ id: user.id, email: user.email });\n});\n\napp.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  const user = await db.findUserByEmail(email);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  const valid = await verifyPassword(password, user.passwordHash);\n  if (!valid) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Generate token/session...\n  const token = generateToken(user.id);\n  res.json({ token });\n});\n```\n\n## Argon2: The Future\n\nArgon2 is the winner of the Password Hashing Competition (2015).\n\n```bash\nnpm install argon2\n```\n\n```javascript\nimport argon2 from 'argon2';\n\n// Hash\nconst hash = await argon2.hash(password);\n\n// Verify\nconst valid = await argon2.verify(hash, password);\n```\n\n**Why Argon2 > bcrypt?**\n- Resistant to GPU/ASIC attacks\n- Configurable (memory, time, parallelism)\n- Winner of official competition\n\n## Best Practices\n\n### 1. Password validation\n```javascript\nimport z from 'zod';\n\nconst passwordSchema = z.string()\n  .min(8, 'Minimum 8 characters')\n  .regex(/[A-Z]/, 'At least one uppercase letter')\n  .regex(/[a-z]/, 'At least one lowercase letter')\n  .regex(/[0-9]/, 'At least one digit')\n  .regex(/[^A-Za-z0-9]/, 'At least one special character');\n```\n\n### 2. Don't log passwords\n```javascript\n// ❌ Bad\nconsole.log('Login attempt:', { email, password });\n\n// ✅ Good\nconsole.log('Login attempt:', { email });  // Never the password\n```\n\n### 3. Generic error messages\n```javascript\n// ❌ Bad (gives information)\nif (!user) return res.status(401).json({ error: 'Email not found' });\nif (!valid) return res.status(401).json({ error: 'Wrong password' });\n\n// ✅ Good (same message)\nif (!user || !valid) {\n  return res.status(401).json({ error: 'Invalid credentials' });\n}\n```\n\n### 4. Rate limiting on auth\n```javascript\nimport rateLimit from 'express-rate-limit';\n\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,  // 15 min\n  max: 5,  // 5 attempts\n  message: 'Too many attempts'\n});\n\napp.use('/auth/', authLimiter);\n```"
    },
    {
      "id": "auth-rbac",
      "moduleId": "auth-fundamentals",
      "title": "RBAC: Role-Based Access Control",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- RBAC = role-based access control\n- Users → Roles → Permissions\n- Start simple (user/admin), complexify if needed\n- Check permissions in middlewares\n\n---\n\n# Implementing RBAC\n\n## Basic Structure\n\n```sql\n-- Tables\nusers (id, email, password_hash, role_id)\nroles (id, name)  -- 'admin', 'user', 'moderator'\npermissions (id, name, resource, action)\nrole_permissions (role_id, permission_id)\n```\n\n## Simple Model (beginner)\n\n```javascript\n// Simplified DB schema\n// users: id, email, role ('user' | 'admin' | 'moderator')\n\n// Role verification middleware\nfunction requireRole(...allowedRoles) {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Not authenticated' });\n    }\n    \n    if (!allowedRoles.includes(req.user.role)) {\n      return res.status(403).json({ error: 'Insufficient permissions' });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.get('/admin/dashboard', \n  requireAuth, \n  requireRole('admin'), \n  adminController\n);\n\napp.post('/posts',\n  requireAuth,\n  requireRole('user', 'admin', 'moderator'),\n  createPost\n);\n\napp.delete('/posts/:id',\n  requireAuth,\n  requireRole('admin', 'moderator'),\n  deletePost\n);\n```\n\n## Advanced Model (granular permissions)\n\n```javascript\n// Detailed permissions\nconst PERMISSIONS = {\n  USERS: {\n    READ: 'users:read',\n    CREATE: 'users:create',\n    UPDATE: 'users:update',\n    DELETE: 'users:delete',\n    UPDATE_OWN: 'users:update:own'\n  },\n  POSTS: {\n    READ: 'posts:read',\n    CREATE: 'posts:create',\n    UPDATE: 'posts:update',\n    DELETE: 'posts:delete',\n    UPDATE_OWN: 'posts:update:own',\n    DELETE_OWN: 'posts:delete:own'\n  }\n};\n\n// Roles with permissions\nconst ROLES = {\n  admin: [\n    PERMISSIONS.USERS.READ,\n    PERMISSIONS.USERS.CREATE,\n    PERMISSIONS.USERS.UPDATE,\n    PERMISSIONS.USERS.DELETE,\n    PERMISSIONS.POSTS.READ,\n    PERMISSIONS.POSTS.CREATE,\n    PERMISSIONS.POSTS.UPDATE,\n    PERMISSIONS.POSTS.DELETE\n  ],\n  user: [\n    PERMISSIONS.USERS.READ,\n    PERMISSIONS.USERS.UPDATE_OWN,\n    PERMISSIONS.POSTS.READ,\n    PERMISSIONS.POSTS.CREATE,\n    PERMISSIONS.POSTS.UPDATE_OWN,\n    PERMISSIONS.POSTS.DELETE_OWN\n  ],\n  moderator: [\n    PERMISSIONS.USERS.READ,\n    PERMISSIONS.POSTS.READ,\n    PERMISSIONS.POSTS.CREATE,\n    PERMISSIONS.POSTS.UPDATE,\n    PERMISSIONS.POSTS.DELETE\n  ]\n};\n\n// Permission verification middleware\nfunction requirePermission(permission) {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Not authenticated' });\n    }\n    \n    const userPermissions = ROLES[req.user.role] || [];\n    \n    if (!userPermissions.includes(permission)) {\n      return res.status(403).json({ error: 'Permission denied' });\n    }\n    \n    next();\n  };\n}\n\n// Ownership middleware (check if resource belongs to user)\nfunction requireOwnershipOrPermission(getResource, permission) {\n  return async (req, res, next) => {\n    const resource = await getResource(req.params.id);\n    \n    const isOwner = resource.userId === req.user.id;\n    const hasPermission = ROLES[req.user.role]?.includes(permission);\n    \n    if (!isOwner && !hasPermission) {\n      return res.status(403).json({ error: 'Not authorized' });\n    }\n    \n    req.resource = resource;\n    next();\n  };\n}\n\n// Usage\napp.put('/posts/:id',\n  requireAuth,\n  requireOwnershipOrPermission(\n    id => db.posts.findById(id),\n    PERMISSIONS.POSTS.UPDATE\n  ),\n  updatePost\n);\n```\n\n## Role Hierarchy\n\n```javascript\n// Roles with levels\nconst ROLE_HIERARCHY = {\n  admin: 3,\n  moderator: 2,\n  user: 1,\n  guest: 0\n};\n\nfunction requireMinRole(minRole) {\n  return (req, res, next) => {\n    const userLevel = ROLE_HIERARCHY[req.user.role] || 0;\n    const requiredLevel = ROLE_HIERARCHY[minRole];\n    \n    if (userLevel < requiredLevel) {\n      return res.status(403).json({ error: 'Insufficient role level' });\n    }\n    \n    next();\n  };\n}\n\n// Usage: accessible to admin and moderator\napp.get('/moderator/dashboard',\n  requireAuth,\n  requireMinRole('moderator'),\n  moderatorController\n);\n```"
    }
  ],
  "exercises": [
    {
      "id": "auth-hash-password",
      "lessonId": "auth-passwords",
      "moduleId": "auth-fundamentals",
      "title": "Hash a Password with bcrypt",
      "difficulty": "easy",
      "description": "Complete a registration endpoint that properly hashes passwords.",
      "instructions": "You're building a user registration endpoint. Complete the `/auth/register` route that:\n1. Takes email and password from req.body\n2. Hashes the password using bcrypt with 12 salt rounds\n3. Creates a user with the hashed password (not the plain one!)\n4. Returns the user data without exposing the password hash\n\nThe createUser function and bcrypt are already imported.",
      "starterCode": "import express from 'express';\nimport bcrypt from 'bcrypt';\nconst app = express();\n\napp.use(express.json());\n\nconst users = [];\n\nfunction createUser(email, passwordHash) {\n  const user = { id: users.length + 1, email, passwordHash };\n  users.push(user);\n  return user;\n}\n\napp.post('/auth/register', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // TODO: Hash the password with bcrypt (12 salt rounds)\n  // TODO: Create user with hashed password\n  // TODO: Return user without password hash\n  \n});",
      "solution": "import express from 'express';\nimport bcrypt from 'bcrypt';\nconst app = express();\n\napp.use(express.json());\n\nconst users = [];\n\nfunction createUser(email, passwordHash) {\n  const user = { id: users.length + 1, email, passwordHash };\n  users.push(user);\n  return user;\n}\n\napp.post('/auth/register', async (req, res) => {\n  const { email, password } = req.body;\n  \n  const salt = await bcrypt.genSalt(12);\n  const passwordHash = await bcrypt.hash(password, salt);\n  \n  const user = createUser(email, passwordHash);\n  \n  res.status(201).json({\n    id: user.id,\n    email: user.email\n  });\n});",
      "hints": [
        "Use bcrypt.genSalt(12) to generate a salt first",
        "Then use bcrypt.hash(password, salt) to hash the password",
        "Store the hash, not the original password",
        "Don't return the passwordHash in the response"
      ],
      "validationPrompt": "Check that: 1) Code uses bcrypt.genSalt() to generate salt, 2) Uses bcrypt.hash() to hash the password with the salt, 3) Passes the hash to createUser (not the plain password), 4) Response doesn't include passwordHash field"
    },
    {
      "id": "auth-fix-bcrypt-bug",
      "lessonId": "auth-passwords",
      "moduleId": "auth-fundamentals",
      "title": "Fix the Broken Login",
      "difficulty": "medium",
      "description": "An AI wrote this login code but it has bcrypt bugs. Fix them!",
      "instructions": "ChatGPT generated this login endpoint but it's broken. Users can't log in even with correct passwords!\n\nThere are 3 bugs:\n1. Password comparison is synchronous but bcrypt.compare is async\n2. The function is missing await keyword\n3. Error messages reveal too much info (security issue)\n\nFix all three bugs so users can log in securely.",
      "starterCode": "import express from 'express';\nimport bcrypt from 'bcrypt';\nconst app = express();\n\napp.use(express.json());\n\nconst users = [\n  { \n    id: 1, \n    email: 'alice@test.com',\n    passwordHash: '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.VTtYA.qGZvKG6G'\n  }\n];\n\napp.post('/auth/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  const user = users.find(u => u.email === email);\n  if (!user) {\n    return res.status(401).json({ error: 'Email not found in database' });\n  }\n  \n  const valid = bcrypt.compare(password, user.passwordHash);\n  if (!valid) {\n    return res.status(401).json({ error: 'Password is incorrect' });\n  }\n  \n  res.json({ \n    message: 'Login successful',\n    userId: user.id \n  });\n});",
      "solution": "import express from 'express';\nimport bcrypt from 'bcrypt';\nconst app = express();\n\napp.use(express.json());\n\nconst users = [\n  { \n    id: 1, \n    email: 'alice@test.com',\n    passwordHash: '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.VTtYA.qGZvKG6G'\n  }\n];\n\napp.post('/auth/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  const user = users.find(u => u.email === email);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  const valid = await bcrypt.compare(password, user.passwordHash);\n  if (!valid) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  res.json({ \n    message: 'Login successful',\n    userId: user.id \n  });\n});",
      "hints": [
        "bcrypt.compare() returns a Promise, so you need to await it",
        "Never reveal whether an email exists or if the password is wrong",
        "Use generic error messages like 'Invalid credentials' for both cases",
        "This prevents attackers from enumerating valid email addresses"
      ],
      "validationPrompt": "Check that: 1) bcrypt.compare is called with await keyword, 2) Both error messages are identical and generic (like 'Invalid credentials'), 3) No information is leaked about whether email exists or password is wrong"
    },
    {
      "id": "auth-registration-validation",
      "lessonId": "auth-passwords",
      "moduleId": "auth-fundamentals",
      "title": "Build a Secure Registration Endpoint",
      "difficulty": "medium",
      "description": "Create a complete registration endpoint with validation and error handling.",
      "instructions": "Build a secure registration endpoint from scratch that:\n1. Validates email format and password strength (min 8 chars, has uppercase, lowercase, number)\n2. Checks if email already exists in the users array\n3. Hashes the password with bcrypt (12 rounds)\n4. Creates the user and returns proper response\n5. Handles all errors appropriately (400 for validation, 409 for duplicate email)\n\nYou can use a simple regex for validation or install Zod if you prefer.",
      "starterCode": "import express from 'express';\nimport bcrypt from 'bcrypt';\nconst app = express();\n\napp.use(express.json());\n\nconst users = [];\n\napp.post('/auth/register', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // TODO: Validate email format (simple regex or Zod)\n  // TODO: Validate password strength (min 8 chars, uppercase, lowercase, number)\n  // TODO: Check if email already exists (return 409 if exists)\n  // TODO: Hash password with bcrypt (12 rounds)\n  // TODO: Create user and add to users array\n  // TODO: Return created user (without password!)\n  \n});",
      "solution": "import express from 'express';\nimport bcrypt from 'bcrypt';\nconst app = express();\n\napp.use(express.json());\n\nconst users = [];\n\napp.post('/auth/register', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // Validate email\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!email || !emailRegex.test(email)) {\n    return res.status(400).json({ error: 'Invalid email format' });\n  }\n  \n  // Validate password strength\n  if (!password || password.length < 8) {\n    return res.status(400).json({ error: 'Password must be at least 8 characters' });\n  }\n  if (!/[A-Z]/.test(password)) {\n    return res.status(400).json({ error: 'Password must contain uppercase letter' });\n  }\n  if (!/[a-z]/.test(password)) {\n    return res.status(400).json({ error: 'Password must contain lowercase letter' });\n  }\n  if (!/[0-9]/.test(password)) {\n    return res.status(400).json({ error: 'Password must contain a number' });\n  }\n  \n  // Check if email exists\n  if (users.find(u => u.email === email)) {\n    return res.status(409).json({ error: 'Email already registered' });\n  }\n  \n  // Hash password\n  const salt = await bcrypt.genSalt(12);\n  const passwordHash = await bcrypt.hash(password, salt);\n  \n  // Create user\n  const user = {\n    id: users.length + 1,\n    email,\n    passwordHash\n  };\n  users.push(user);\n  \n  res.status(201).json({\n    id: user.id,\n    email: user.email\n  });\n});",
      "hints": [
        "Email regex: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/",
        "Check password length first, then check for uppercase/lowercase/numbers with regex",
        "Use users.find() to check if email exists",
        "Return 409 (Conflict) for duplicate email, 400 for validation errors",
        "Don't forget to await bcrypt.hash()"
      ],
      "validationPrompt": "Check that: 1) Email is validated with regex or Zod, 2) Password validation checks length (min 8) and requires uppercase, lowercase, and number, 3) Checks for duplicate email and returns 409 status, 4) Password is hashed with bcrypt before storing, 5) Response doesn't include passwordHash"
    },
    {
      "id": "auth-debug-session-cookie",
      "lessonId": "auth-concepts",
      "moduleId": "auth-fundamentals",
      "title": "Debug: Session Cookie Not Working",
      "difficulty": "medium",
      "description": "The session cookie isn't being saved. Find and fix the bugs!",
      "instructions": "A developer copied this authentication code from Stack Overflow but the session cookie isn't being saved in the browser.\n\nThere are multiple bugs in the cookie configuration:\n1. The cookie options are incorrect for production use\n2. Missing crucial security flags\n3. The session isn't being saved properly\n\nFix the bugs so the session cookie works correctly.",
      "starterCode": "import express from 'express';\nimport session from 'express-session';\nconst app = express();\n\napp.use(express.json());\n\napp.use(session({\n  secret: 'my-secret-key',\n  resave: true,\n  saveUninitialized: true,\n  cookie: { \n    maxAge: 24 * 60 * 60 * 1000,\n    httpOnly: false,\n    secure: false\n  }\n}));\n\napp.post('/auth/login', (req, res) => {\n  const { email, password } = req.body;\n  \n  // Simplified auth check\n  if (email === 'test@test.com' && password === 'password') {\n    req.session.userId = 1;\n    req.session.email = email;\n    \n    res.json({ message: 'Login successful' });\n  } else {\n    res.status(401).json({ error: 'Invalid credentials' });\n  }\n});\n\napp.get('/auth/me', (req, res) => {\n  if (!req.session.userId) {\n    return res.status(401).json({ error: 'Not authenticated' });\n  }\n  \n  res.json({\n    userId: req.session.userId,\n    email: req.session.email\n  });\n});",
      "solution": "import express from 'express';\nimport session from 'express-session';\nconst app = express();\n\napp.use(express.json());\n\napp.use(session({\n  secret: 'my-secret-key',\n  resave: false,\n  saveUninitialized: false,\n  cookie: { \n    maxAge: 24 * 60 * 60 * 1000,\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax'\n  }\n}));\n\napp.post('/auth/login', (req, res) => {\n  const { email, password } = req.body;\n  \n  // Simplified auth check\n  if (email === 'test@test.com' && password === 'password') {\n    req.session.userId = 1;\n    req.session.email = email;\n    \n    req.session.save((err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to save session' });\n      }\n      res.json({ message: 'Login successful' });\n    });\n  } else {\n    res.status(401).json({ error: 'Invalid credentials' });\n  }\n});\n\napp.get('/auth/me', (req, res) => {\n  if (!req.session.userId) {\n    return res.status(401).json({ error: 'Not authenticated' });\n  }\n  \n  res.json({\n    userId: req.session.userId,\n    email: req.session.email\n  });\n});",
      "hints": [
        "resave should be false (don't save unchanged sessions)",
        "saveUninitialized should be false (don't save empty sessions)",
        "httpOnly should be true (prevent JavaScript access)",
        "secure should be true in production, false in dev",
        "Call req.session.save() explicitly after setting session data"
      ],
      "validationPrompt": "Check that: 1) resave is false, 2) saveUninitialized is false, 3) httpOnly is true, 4) secure is conditional (true in production, false in dev), 5) req.session.save() is called after setting userId/email, 6) sameSite attribute is set (lax or strict)"
    }
  ]
}
