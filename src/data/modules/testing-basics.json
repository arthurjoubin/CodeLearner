{
  "module": {
    "id": "testing-basics",
    "title": "Testing Basics",
    "description": "Unit, Integration, and E2E testing fundamentals",
    "icon": "TestTube",
    "requiredXp": 3400,
    "color": "from-rose-400 to-rose-600",
    "courseId": "frontend-production"
  },
  "lessons": [
    {
      "id": "why-test",
      "moduleId": "testing-basics",
      "title": "Why Test Your Code?",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Tests catch bugs before users do\n- Tests document how code should work\n- Tests enable safe refactoring\n- Not all code needs tests\n\n---\n\n# The Case for Testing\n\n## What is Testing?\n\n**Testing** = Writing code that checks if your code works correctly.\n\n**Example:**\n```javascript\n// Your code\nfunction add(a, b) {\n  return a + b;\n}\n\n// Your test\ntest('add() works', () => {\n  expect(add(2, 3)).toBe(5);\n  expect(add(-1, 1)).toBe(0);\n});\n```\n\nIf test passes → Code works!\nIf test fails → Something's broken!\n\n## Why Bother Testing?\n\n### 1. Catch Bugs Early\n\n**Without tests:**\n```\nWrite code → Deploy → User finds bug → Fix → Deploy\n```\n\n**With tests:**\n```\nWrite code → Test fails → Fix → Test passes → Deploy\n```\n\nCatch bugs before users!\n\n### 2. Confidence to Change Code\n\n**Without tests:**\n\"If I change this, will it break something?\"\n\n**With tests:**\nChange code → Run tests → All pass? Safe to deploy!\n\n### 3. Documentation\n\nTests show HOW code should be used:\n\n```javascript\n// Test documents the API\ntest('user can login', () => {\n  const user = { email: 'test@example.com', password: 'password123' };\n  const result = login(user);\n  expect(result.success).toBe(true);\n});\n```\n\nBetter than comments!\n\n### 4. Better Design\n\nTestable code → Well-structured code\n\n**Hard to test:**\n```javascript\nfunction processUser() {\n  const data = fetchFromDatabase();\n  const user = parseData(data);\n  sendEmail(user);\n  updateUI(user);\n  logToAnalytics(user);\n}\n```\n\nDoes too much!\n\n**Easy to test:**\n```javascript\nfunction parseUser(data) {\n  return { /* ... */ };\n}\n\nfunction formatEmail(user) {\n  return { /* ... */ };\n}\n```\n\nSmall, focused functions!\n\n## When NOT to Test\n\n**Don't test:**\n- ❌ Simple getters/setters\n- ❌ Third-party libraries (they test themselves)\n- ❌ Prototypes you'll throw away\n- ❌ Static content\n\n**DO test:**\n- ✅ Business logic\n- ✅ Complex functions\n- ✅ Edge cases\n- ✅ Critical user flows\n\n## Types of Tests\n\n### Unit Tests\n\n**Test one function/component in isolation**\n\n```javascript\ntest('calculateTax() calculates correctly', () => {\n  expect(calculateTax(100, 0.2)).toBe(20);\n});\n```\n\n**Fast, specific**\n\n### Integration Tests\n\n**Test multiple parts working together**\n\n```javascript\ntest('user can add item to cart', () => {\n  const cart = new Cart();\n  const product = { id: 1, price: 10 };\n  cart.add(product);\n  expect(cart.total()).toBe(10);\n});\n```\n\n**More realistic**\n\n### End-to-End (E2E) Tests\n\n**Test entire user flow in real browser**\n\n```javascript\ntest('user can complete checkout', async () => {\n  await page.goto('/shop');\n  await page.click('[data-testid=\"add-to-cart\"]');\n  await page.click('[data-testid=\"checkout\"]');\n  await page.fill('#email', 'test@example.com');\n  await page.click('[data-testid=\"submit\"]');\n  \n  await expect(page).toHaveURL('/success');\n});\n```\n\n**Slow but thorough**\n\n## The Testing Pyramid\n\n```\n      /\\      E2E Tests (few)\n     /  \\     \n    /____\\    Integration Tests (some)\n   /      \\   \n  /________\\  Unit Tests (many)\n```\n\n**More unit tests, fewer E2E tests**\n\nWhy?\n- Unit tests: Fast, cheap, specific\n- E2E tests: Slow, expensive, flaky\n\n## How Much to Test?\n\n**Aim for: 70-80% coverage**\n\nNot 100%! Diminishing returns.\n\n**Focus on:**\n- Critical paths (login, checkout)\n- Complex logic\n- Bug-prone areas\n\n**Don't obsess over:**\n- Every line of code\n- Simple UI components\n- Configuration files\n\n## Testing Mindset\n\n**Tests are not:**\n- Proof your code is perfect\n- A waste of time\n- Only for big projects\n\n**Tests are:**\n- Safety net\n- Documentation\n- Investment in future\n\n## Getting Started\n\n**Start small:**\n1. Pick one complex function\n2. Write a test for it\n3. See it work\n4. Add more tests gradually\n\n**Don't:**\n- Try to test everything at once\n- Aim for 100% coverage day 1\n- Let tests slow you down\n\n## Remember\n\n- Tests save time long-term\n- Some tests > No tests\n- Test what matters\n- Keep tests simple",
      "codeExample": "// Example: Testing a simple function\n\n// Your code (calculator.js)\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function divide(a, b) {\n  if (b === 0) throw new Error('Cannot divide by zero');\n  return a / b;\n}\n\n// Your tests (calculator.test.js)\nimport { add, divide } from './calculator';\n\ntest('add() adds two numbers', () => {\n  expect(add(2, 3)).toBe(5);\n  expect(add(-1, 1)).toBe(0);\n  expect(add(0, 0)).toBe(0);\n});\n\ntest('divide() divides two numbers', () => {\n  expect(divide(10, 2)).toBe(5);\n  expect(divide(9, 3)).toBe(3);\n});\n\ntest('divide() throws on division by zero', () => {\n  expect(() => divide(10, 0)).toThrow('Cannot divide by zero');\n});\n\n// Run tests\n// $ npm test\n// ✓ add() adds two numbers\n// ✓ divide() divides two numbers  \n// ✓ divide() throws on division by zero\n//\n// 3 tests passed"
    },
    {
      "id": "unit-testing",
      "moduleId": "testing-basics",
      "title": "Unit Testing",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Unit test = Test one function/component in isolation\n- Popular frameworks: Jest, Vitest, Testing Library\n- AAA pattern: Arrange, Act, Assert\n- Keep tests simple and readable\n\n---\n\n# Unit Testing: The Foundation\n\n## What is a Unit Test?\n\n**Unit** = Smallest testable part (function, class, component)\n\n**Unit test** = Verify unit works correctly in isolation\n\n```javascript\n// Unit: Simple function\nfunction multiply(a, b) {\n  return a * b;\n}\n\n// Unit test\ntest('multiply() multiplies two numbers', () => {\n  expect(multiply(3, 4)).toBe(12);\n});\n```\n\nOne function, one test!\n\n## AAA Pattern\n\n**Arrange, Act, Assert**\n\n```javascript\ntest('user cart calculates total correctly', () => {\n  // Arrange: Set up test data\n  const cart = new ShoppingCart();\n  const item1 = { price: 10, quantity: 2 };\n  const item2 = { price: 5, quantity: 1 };\n  \n  // Act: Perform the action\n  cart.add(item1);\n  cart.add(item2);\n  const total = cart.getTotal();\n  \n  // Assert: Check the result\n  expect(total).toBe(25); // 10*2 + 5*1 = 25\n});\n```\n\nClear structure!\n\n## Popular Test Frameworks\n\n### Jest / Vitest\n\n**Most popular for JavaScript**\n\n```javascript\nimport { describe, test, expect } from 'vitest';\n\ndescribe('Math utilities', () => {\n  test('add() adds numbers', () => {\n    expect(add(2, 3)).toBe(5);\n  });\n  \n  test('subtract() subtracts numbers', () => {\n    expect(subtract(5, 3)).toBe(2);\n  });\n});\n```\n\n### React Testing Library\n\n**For testing React components**\n\n```javascript\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Button from './Button';\n\ntest('button shows correct text', () => {\n  render(<Button>Click me</Button>);\n  expect(screen.getByText('Click me')).toBeInTheDocument();\n});\n\ntest('button calls onClick when clicked', async () => {\n  const handleClick = vi.fn();\n  render(<Button onClick={handleClick}>Click me</Button>);\n  \n  await userEvent.click(screen.getByRole('button'));\n  expect(handleClick).toHaveBeenCalledTimes(1);\n});\n```\n\n## Common Assertions\n\n```javascript\n// Equality\nexpect(value).toBe(5);               // Strict equality (===)\nexpect(obj).toEqual({ a: 1 });       // Deep equality\n\n// Truthiness\nexpect(value).toBeTruthy();\nexpect(value).toBeFalsy();\nexpect(value).toBeNull();\nexpect(value).toBeUndefined();\n\n// Numbers\nexpect(value).toBeGreaterThan(3);\nexpect(value).toBeLessThanOrEqual(10);\nexpect(value).toBeCloseTo(0.3);      // Floating point\n\n// Strings\nexpect(str).toMatch(/hello/i);\nexpect(str).toContain('world');\n\n// Arrays\nexpect(arr).toHaveLength(3);\nexpect(arr).toContain(item);\n\n// Objects\nexpect(obj).toHaveProperty('name');\nexpect(obj).toMatchObject({ a: 1 });\n\n// Functions\nexpect(fn).toThrow('Error message');\nexpect(fn).toHaveBeenCalled();\nexpect(fn).toHaveBeenCalledWith(arg1, arg2);\n```\n\n## Mocking\n\n**Mock** = Fake implementation for testing\n\n### Mock Functions\n\n```javascript\nimport { vi } from 'vitest';\n\ntest('callback is called', () => {\n  const mockFn = vi.fn();\n  \n  someFunction(mockFn);\n  \n  expect(mockFn).toHaveBeenCalled();\n  expect(mockFn).toHaveBeenCalledWith('expected arg');\n});\n```\n\n### Mock Modules\n\n```javascript\n// Mock API calls\nvi.mock('./api', () => ({\n  fetchUser: vi.fn(() => Promise.resolve({ id: 1, name: 'Alice' }))\n}));\n\ntest('loads user data', async () => {\n  const user = await loadUser(1);\n  expect(user.name).toBe('Alice');\n});\n```\n\n## Testing Async Code\n\n```javascript\n// Async/await\ntest('fetches data', async () => {\n  const data = await fetchData();\n  expect(data).toEqual({ success: true });\n});\n\n// Promises\ntest('fetches data', () => {\n  return fetchData().then(data => {\n    expect(data).toEqual({ success: true });\n  });\n});\n\n// resolves/rejects\ntest('fetches data', async () => {\n  await expect(fetchData()).resolves.toEqual({ success: true });\n});\n\ntest('handles error', async () => {\n  await expect(fetchBadData()).rejects.toThrow('Error');\n});\n```\n\n## Best Practices\n\n### 1. One Assertion Per Test (Usually)\n\n```javascript\n// ❌ Bad: Testing too much\ntest('user functions', () => {\n  expect(createUser()).toBeTruthy();\n  expect(deleteUser()).toBeTruthy();\n  expect(updateUser()).toBeTruthy();\n});\n\n// ✅ Good: Focused tests\ntest('createUser() creates user', () => {\n  expect(createUser()).toBeTruthy();\n});\n\ntest('deleteUser() deletes user', () => {\n  expect(deleteUser()).toBeTruthy();\n});\n```\n\n### 2. Descriptive Test Names\n\n```javascript\n// ❌ Bad\ntest('user', () => { /* ... */ });\n\n// ✅ Good\ntest('user login fails with wrong password', () => { /* ... */ });\n```\n\n### 3. Don't Test Implementation Details\n\n```javascript\n// ❌ Bad: Testing internal state\ntest('counter increments internal value', () => {\n  const counter = new Counter();\n  counter.increment();\n  expect(counter._value).toBe(1); // Testing private detail!\n});\n\n// ✅ Good: Testing behavior\ntest('counter shows incremented value', () => {\n  const counter = new Counter();\n  counter.increment();\n  expect(counter.getValue()).toBe(1);\n});\n```\n\n### 4. Keep Tests Independent\n\n```javascript\n// ❌ Bad: Tests depend on each other\nlet user;\ntest('creates user', () => {\n  user = createUser();\n  expect(user).toBeTruthy();\n});\ntest('deletes user', () => {\n  deleteUser(user); // Depends on previous test!\n});\n\n// ✅ Good: Each test stands alone\ntest('creates user', () => {\n  const user = createUser();\n  expect(user).toBeTruthy();\n});\ntest('deletes user', () => {\n  const user = createUser();\n  deleteUser(user);\n  expect(userExists(user.id)).toBe(false);\n});\n```\n\n## Coverage\n\n**Code coverage** = % of code executed by tests\n\n```bash\n# Run tests with coverage\nnpm test -- --coverage\n\n# Output:\n# Statements: 85%\n# Branches: 75%\n# Functions: 90%\n# Lines: 85%\n```\n\n**Aim for 70-80%, not 100%**\n\n## Remember\n\n- Test behavior, not implementation\n- Keep tests simple and readable\n- Mock external dependencies\n- Run tests often",
      "codeExample": "// Complete unit testing example\n\n// Code to test: TodoList.js\nexport class TodoList {\n  constructor() {\n    this.todos = [];\n  }\n  \n  add(text) {\n    const todo = { id: Date.now(), text, done: false };\n    this.todos.push(todo);\n    return todo;\n  }\n  \n  toggle(id) {\n    const todo = this.todos.find(t => t.id === id);\n    if (!todo) throw new Error('Todo not found');\n    todo.done = !todo.done;\n    return todo;\n  }\n  \n  getAll() {\n    return this.todos;\n  }\n  \n  getCompleted() {\n    return this.todos.filter(t => t.done);\n  }\n}\n\n// Tests: TodoList.test.js\nimport { describe, test, expect, beforeEach } from 'vitest';\nimport { TodoList } from './TodoList';\n\ndescribe('TodoList', () => {\n  let todoList;\n  \n  // Run before each test\n  beforeEach(() => {\n    todoList = new TodoList();\n  });\n  \n  test('starts empty', () => {\n    expect(todoList.getAll()).toHaveLength(0);\n  });\n  \n  test('add() creates a new todo', () => {\n    const todo = todoList.add('Buy milk');\n    \n    expect(todo).toHaveProperty('id');\n    expect(todo.text).toBe('Buy milk');\n    expect(todo.done).toBe(false);\n    expect(todoList.getAll()).toHaveLength(1);\n  });\n  \n  test('toggle() marks todo as done', () => {\n    const todo = todoList.add('Buy milk');\n    \n    todoList.toggle(todo.id);\n    \n    expect(todo.done).toBe(true);\n  });\n  \n  test('toggle() throws when todo not found', () => {\n    expect(() => todoList.toggle(999)).toThrow('Todo not found');\n  });\n  \n  test('getCompleted() returns only completed todos', () => {\n    todoList.add('Task 1');\n    const todo2 = todoList.add('Task 2');\n    todoList.add('Task 3');\n    \n    todoList.toggle(todo2.id);\n    \n    const completed = todoList.getCompleted();\n    expect(completed).toHaveLength(1);\n    expect(completed[0].text).toBe('Task 2');\n  });\n});\n\n// Run: npm test\n// ✓ TodoList › starts empty\n// ✓ TodoList › add() creates a new todo\n// ✓ TodoList › toggle() marks todo as done\n// ✓ TodoList › toggle() throws when todo not found\n// ✓ TodoList › getCompleted() returns only completed todos"
    },
    {
      "id": "integration-testing",
      "moduleId": "testing-basics",
      "title": "Integration Testing",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Integration tests verify multiple units work together\n- Test realistic user scenarios\n- More valuable than unit tests for catching real bugs\n- Slower than unit tests but faster than E2E\n\n---\n\n# Integration Testing: The Middle Ground\n\n## What is Integration Testing?\n\n**Integration test** = Test multiple units working together\n\n**Unit test:**\n```javascript\ntest('formatCurrency() formats correctly', () => {\n  expect(formatCurrency(1000)).toBe('$10.00');\n});\n```\n\n**Integration test:**\n```javascript\ntest('user can add product to cart and see total', () => {\n  const cart = new Cart();\n  const product = { id: 1, price: 1000 }; // cents\n  \n  cart.add(product);\n  \n  expect(cart.getTotalFormatted()).toBe('$10.00');\n  // Tests Cart + formatCurrency() together!\n});\n```\n\n## Why Integration Tests?\n\n**Units might work alone but fail together:**\n\n```javascript\n// Both functions pass unit tests\nfunction parseUserInput(input) {\n  return input.trim().toLowerCase();\n}\n\nfunction validateEmail(email) {\n  return email.includes('@'); // Simple check\n}\n\n// But together, they might have issues:\nconst input = '  USER@EXAMPLE.COM  ';\nconst parsed = parseUserInput(input);     // 'user@example.com' ✓\nconst valid = validateEmail(parsed);       // true ✓\n\n// Works! But what if...\nconst input2 = 'not an email';\nconst parsed2 = parseUserInput(input2);   // 'not an email'\nconst valid2 = validateEmail(parsed2);     // false ✓\n\n// Integration test catches edge cases!\n```\n\n## What to Integration Test\n\n**Test user workflows:**\n- User registration\n- Checkout process\n- Search and filter\n- CRUD operations\n- Authentication flow\n\n**Example:**\n```javascript\ntest('user can register and login', async () => {\n  // Register\n  const user = await registerUser({\n    email: 'test@example.com',\n    password: 'password123'\n  });\n  expect(user.id).toBeDefined();\n  \n  // Login with same credentials\n  const session = await login({\n    email: 'test@example.com',\n    password: 'password123'\n  });\n  expect(session.userId).toBe(user.id);\n  expect(session.token).toBeDefined();\n});\n```\n\n## Testing with Database\n\n**Use test database:**\n\n```javascript\nimport { beforeEach, afterEach, test, expect } from 'vitest';\nimport { db } from './db';\n\nbeforeEach(async () => {\n  // Setup: Create test database\n  await db.migrate.latest();\n});\n\nafterEach(async () => {\n  // Cleanup: Reset database\n  await db.migrate.rollback();\n});\n\ntest('user can create and retrieve post', async () => {\n  // Create user\n  const user = await db.users.create({\n    email: 'test@example.com',\n    name: 'Alice'\n  });\n  \n  // Create post\n  const post = await db.posts.create({\n    userId: user.id,\n    title: 'Hello World',\n    content: 'My first post'\n  });\n  \n  // Retrieve post with user\n  const retrieved = await db.posts.findById(post.id, {\n    include: { user: true }\n  });\n  \n  expect(retrieved.title).toBe('Hello World');\n  expect(retrieved.user.name).toBe('Alice');\n});\n```\n\n## Testing API Endpoints\n\n**Use supertest for HTTP testing:**\n\n```javascript\nimport request from 'supertest';\nimport { app } from './app';\n\ntest('POST /api/users creates user', async () => {\n  const response = await request(app)\n    .post('/api/users')\n    .send({\n      email: 'test@example.com',\n      name: 'Alice'\n    })\n    .expect(201);\n  \n  expect(response.body).toMatchObject({\n    id: expect.any(Number),\n    email: 'test@example.com',\n    name: 'Alice'\n  });\n});\n\ntest('GET /api/users/:id returns user', async () => {\n  // Create user first\n  const created = await request(app)\n    .post('/api/users')\n    .send({ email: 'test@example.com', name: 'Alice' });\n  \n  // Get user\n  const response = await request(app)\n    .get(`/api/users/${created.body.id}`)\n    .expect(200);\n  \n  expect(response.body.name).toBe('Alice');\n});\n```\n\n## Testing React Components with Context\n\n```javascript\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { CartProvider, Cart } from './Cart';\n\ntest('user can add item to cart', async () => {\n  render(\n    <CartProvider>\n      <ProductPage />\n      <Cart />\n    </CartProvider>\n  );\n  \n  // Add item\n  await userEvent.click(screen.getByText('Add to Cart'));\n  \n  // Check cart updated\n  expect(screen.getByText('1 item in cart')).toBeInTheDocument();\n  expect(screen.getByText('$10.00')).toBeInTheDocument();\n});\n```\n\n## Mocking External Services\n\n```javascript\nimport { vi } from 'vitest';\nimport { sendEmail } from './email-service';\n\n// Mock email service\nvi.mock('./email-service', () => ({\n  sendEmail: vi.fn(() => Promise.resolve({ success: true }))\n}));\n\ntest('user registration sends welcome email', async () => {\n  const user = await registerUser({\n    email: 'test@example.com',\n    password: 'password123'\n  });\n  \n  expect(sendEmail).toHaveBeenCalledWith({\n    to: 'test@example.com',\n    subject: 'Welcome!',\n    body: expect.stringContaining('Welcome')\n  });\n});\n```\n\n## Best Practices\n\n### 1. Test Happy Path + Edge Cases\n\n```javascript\ntest('successful checkout', async () => {\n  // Happy path\n  const result = await checkout(cart, paymentInfo);\n  expect(result.success).toBe(true);\n});\n\ntest('checkout fails with invalid payment', async () => {\n  // Edge case\n  const result = await checkout(cart, invalidPayment);\n  expect(result.success).toBe(false);\n  expect(result.error).toBe('Invalid payment method');\n});\n```\n\n### 2. Setup/Teardown\n\n```javascript\nbeforeEach(async () => {\n  // Fresh state for each test\n  await db.reset();\n  await cache.clear();\n});\n\nafterEach(async () => {\n  // Cleanup\n  await db.close();\n});\n```\n\n### 3. Don't Mock Too Much\n\n```javascript\n// ❌ Bad: Mocking everything = not really integration test\nvi.mock('./database');\nvi.mock('./email');\nvi.mock('./payment');\nvi.mock('./analytics');\n\n// ✅ Good: Only mock external services\nvi.mock('./email'); // External service\nvi.mock('./payment'); // Third-party API\n// Use real database (test instance)\n// Use real internal code\n```\n\n## Integration vs Unit vs E2E\n\n**Unit:**\n```javascript\ntest('add() function', () => {\n  expect(add(2, 3)).toBe(5);\n});\n// Fast, specific, isolated\n```\n\n**Integration:**\n```javascript\ntest('cart total calculation', () => {\n  cart.add(item1);\n  cart.add(item2);\n  expect(cart.getTotal()).toBe(25);\n});\n// Medium speed, realistic scenarios\n```\n\n**E2E:**\n```javascript\ntest('complete checkout flow', async () => {\n  await browser.click('#add-to-cart');\n  await browser.click('#checkout');\n  // ...\n});\n// Slow, tests everything\n```\n\n## Remember\n\n- Integration tests catch more real bugs\n- Balance with unit and E2E tests\n- Use test database, not production!\n- Clean up after each test",
      "codeExample": "// Real-world integration test example\n\nimport { describe, test, expect, beforeEach } from 'vitest';\nimport request from 'supertest';\nimport { app } from './app';\nimport { db } from './db';\n\ndescribe('Blog API Integration', () => {\n  let authToken;\n  let userId;\n  \n  beforeEach(async () => {\n    // Reset database\n    await db.migrate.rollback();\n    await db.migrate.latest();\n  });\n  \n  test('complete user journey: register → login → create post → view post', async () => {\n    // 1. Register\n    const registerResponse = await request(app)\n      .post('/api/auth/register')\n      .send({\n        email: 'alice@example.com',\n        password: 'password123',\n        name: 'Alice'\n      })\n      .expect(201);\n    \n    userId = registerResponse.body.id;\n    expect(userId).toBeDefined();\n    \n    // 2. Login\n    const loginResponse = await request(app)\n      .post('/api/auth/login')\n      .send({\n        email: 'alice@example.com',\n        password: 'password123'\n      })\n      .expect(200);\n    \n    authToken = loginResponse.body.token;\n    expect(authToken).toBeDefined();\n    \n    // 3. Create post (authenticated)\n    const postResponse = await request(app)\n      .post('/api/posts')\n      .set('Authorization', `Bearer ${authToken}`)\n      .send({\n        title: 'My First Post',\n        content: 'Hello World!'\n      })\n      .expect(201);\n    \n    const postId = postResponse.body.id;\n    expect(postResponse.body.authorId).toBe(userId);\n    \n    // 4. Get post (public)\n    const getResponse = await request(app)\n      .get(`/api/posts/${postId}`)\n      .expect(200);\n    \n    expect(getResponse.body).toMatchObject({\n      id: postId,\n      title: 'My First Post',\n      content: 'Hello World!',\n      author: {\n        id: userId,\n        name: 'Alice'\n      }\n    });\n  });\n  \n  test('cannot create post without authentication', async () => {\n    await request(app)\n      .post('/api/posts')\n      .send({ title: 'Test', content: 'Test' })\n      .expect(401);\n  });\n});"
    },
    {
      "id": "e2e-testing",
      "moduleId": "testing-basics",
      "title": "End-to-End Testing",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- E2E tests simulate real user interactions in a browser\n- Popular tools: Playwright, Cypress, Puppeteer\n- Slower and more flaky than unit/integration tests\n- Focus on critical user flows\n\n---\n\n# E2E Testing: The Full Picture\n\n## What is E2E Testing?\n\n**E2E** = End-to-End = Test entire application like a real user\n\n**Example:**\n```javascript\ntest('user can purchase product', async () => {\n  // Real browser automation\n  await page.goto('https://myshop.com');\n  await page.click('[data-testid=\"product-1\"]');\n  await page.click('text=Add to Cart');\n  await page.click('text=Checkout');\n  await page.fill('#email', 'test@example.com');\n  await page.fill('#card', '4242424242424242');\n  await page.click('text=Pay Now');\n  \n  await expect(page).toHaveURL('/success');\n  await expect(page.locator('text=Thank you')).toBeVisible();\n});\n```\n\nTests EVERYTHING: Frontend + Backend + Database!\n\n## Popular E2E Tools\n\n### Playwright (Recommended)\n\n**Modern, fast, cross-browser**\n\n```javascript\nimport { test, expect } from '@playwright/test';\n\ntest('user can login', async ({ page }) => {\n  await page.goto('/login');\n  await page.fill('#email', 'alice@example.com');\n  await page.fill('#password', 'password123');\n  await page.click('button[type=\"submit\"]');\n  \n  await expect(page).toHaveURL('/dashboard');\n  await expect(page.locator('text=Welcome, Alice')).toBeVisible();\n});\n```\n\n### Cypress\n\n**Developer-friendly, great DX**\n\n```javascript\ndescribe('Login', () => {\n  it('user can login', () => {\n    cy.visit('/login');\n    cy.get('#email').type('alice@example.com');\n    cy.get('#password').type('password123');\n    cy.get('button[type=\"submit\"]').click();\n    \n    cy.url().should('include', '/dashboard');\n    cy.contains('Welcome, Alice').should('be.visible');\n  });\n});\n```\n\n## What to E2E Test\n\n**Critical user flows:**\n- ✅ User registration\n- ✅ Login/logout\n- ✅ Checkout and payment\n- ✅ Core features\n- ✅ Data persistence\n\n**Don't E2E test:**\n- ❌ Every button click\n- ❌ Simple UI changes\n- ❌ Things covered by unit/integration tests\n\n## Best Practices\n\n### 1. Use Data Attributes for Selectors\n\n```javascript\n// ❌ Bad: Fragile selectors\nawait page.click('.btn.btn-primary.mt-4');\n// Breaks if CSS classes change!\n\n// ✅ Good: Stable test IDs\nawait page.click('[data-testid=\"submit-button\"]');\n\n// In your HTML:\n<button data-testid=\"submit-button\" class=\"btn btn-primary mt-4\">\n  Submit\n</button>\n```\n\n### 2. Setup and Teardown\n\n```javascript\nimport { test, expect } from '@playwright/test';\n\ntest.beforeEach(async ({ page }) => {\n  // Reset database\n  await fetch('http://localhost:3000/test/reset');\n  \n  // Navigate to start page\n  await page.goto('/');\n});\n\ntest.afterEach(async ({ page }) => {\n  // Cleanup\n  await page.close();\n});\n```\n\n### 3. Wait for Elements\n\n```javascript\n// ❌ Bad: Race condition\nawait page.click('#submit');\nconst message = await page.textContent('#success-message');\n// Might fail if message loads slowly!\n\n// ✅ Good: Wait for element\nawait page.click('#submit');\nawait page.waitForSelector('#success-message');\nconst message = await page.textContent('#success-message');\n\n// ✅ Better: Built-in waiting\nawait page.click('#submit');\nawait expect(page.locator('#success-message')).toBeVisible();\n```\n\n### 4. Test Data Isolation\n\n```javascript\n// Create unique test data\nconst testEmail = `test-${Date.now()}@example.com`;\n\nawait page.fill('#email', testEmail);\n// Won't conflict with other tests!\n```\n\n## Common Patterns\n\n### Page Object Model\n\n**Encapsulate page interactions:**\n\n```javascript\n// pages/LoginPage.js\nexport class LoginPage {\n  constructor(page) {\n    this.page = page;\n    this.emailInput = page.locator('#email');\n    this.passwordInput = page.locator('#password');\n    this.submitButton = page.locator('button[type=\"submit\"]');\n  }\n  \n  async login(email, password) {\n    await this.emailInput.fill(email);\n    await this.passwordInput.fill(password);\n    await this.submitButton.click();\n  }\n}\n\n// test.spec.js\nimport { LoginPage } from './pages/LoginPage';\n\ntest('user can login', async ({ page }) => {\n  const loginPage = new LoginPage(page);\n  await page.goto('/login');\n  await loginPage.login('alice@example.com', 'password123');\n  \n  await expect(page).toHaveURL('/dashboard');\n});\n```\n\n### Fixtures for Auth\n\n```javascript\n// playwright.config.js\nimport { test as base } from '@playwright/test';\n\nconst test = base.extend({\n  authenticatedPage: async ({ page }, use) => {\n    // Login before test\n    await page.goto('/login');\n    await page.fill('#email', 'test@example.com');\n    await page.fill('#password', 'password123');\n    await page.click('button[type=\"submit\"]');\n    await page.waitForURL('/dashboard');\n    \n    // Use the authenticated page\n    await use(page);\n  }\n});\n\ntest('can access protected page', async ({ authenticatedPage }) => {\n  await authenticatedPage.goto('/settings');\n  await expect(authenticatedPage.locator('h1')).toHaveText('Settings');\n});\n```\n\n## Visual Regression Testing\n\n**Catch visual bugs:**\n\n```javascript\ntest('homepage looks correct', async ({ page }) => {\n  await page.goto('/');\n  await expect(page).toHaveScreenshot('homepage.png');\n});\n\n// First run: Creates baseline screenshot\n// Future runs: Compares against baseline\n// Fails if pixels differ!\n```\n\n## Debugging E2E Tests\n\n```javascript\n// 1. Slow down\ntest('debug test', async ({ page }) => {\n  await page.goto('/', { waitUntil: 'networkidle' });\n  await page.pause(); // Opens debugger!\n});\n\n// 2. Take screenshots\nawait page.screenshot({ path: 'debug.png' });\n\n// 3. Console logs\npage.on('console', msg => console.log('PAGE LOG:', msg.text()));\n\n// 4. Headed mode (see browser)\n// Run: npx playwright test --headed\n```\n\n## Speed Optimization\n\n```javascript\n// Run tests in parallel\n// playwright.config.js\nexport default {\n  workers: 4, // Run 4 tests at once\n  use: {\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure'\n  }\n};\n\n// Mock slow API calls\nawait page.route('**/api/slow-endpoint', route => {\n  route.fulfill({\n    status: 200,\n    body: JSON.stringify({ data: 'mocked' })\n  });\n});\n```\n\n## When E2E Tests Fail\n\n**Common causes:**\n1. **Timing issues** → Add proper waits\n2. **Flaky selectors** → Use data-testid\n3. **Network problems** → Mock APIs\n4. **State pollution** → Reset database\n5. **Real bugs!** → Fix them!\n\n## Remember\n\n- E2E tests are expensive (time + resources)\n- Focus on critical paths\n- Keep E2E test count low (< 50)\n- Supplement with unit/integration tests\n- Debug with headed mode + screenshots",
      "codeExample": "// Complete E2E test example (Playwright)\n\nimport { test, expect } from '@playwright/test';\n\n// Page Object Model\nclass CheckoutPage {\n  constructor(page) {\n    this.page = page;\n  }\n  \n  async addProductToCart(productId) {\n    await this.page.click(`[data-testid=\"add-to-cart-${productId}\"]`);\n    await expect(this.page.locator('[data-testid=\"cart-count\"]')).toHaveText('1');\n  }\n  \n  async proceedToCheckout() {\n    await this.page.click('[data-testid=\"cart-icon\"]');\n    await this.page.click('[data-testid=\"checkout-button\"]');\n  }\n  \n  async fillShippingInfo(info) {\n    await this.page.fill('#email', info.email);\n    await this.page.fill('#address', info.address);\n    await this.page.fill('#city', info.city);\n    await this.page.fill('#zip', info.zip);\n  }\n  \n  async fillPaymentInfo(card) {\n    await this.page.fill('#card-number', card.number);\n    await this.page.fill('#card-expiry', card.expiry);\n    await this.page.fill('#card-cvc', card.cvc);\n  }\n  \n  async submitOrder() {\n    await this.page.click('[data-testid=\"place-order\"]');\n  }\n}\n\ntest.describe('E-commerce Checkout Flow', () => {\n  let checkoutPage;\n  \n  test.beforeEach(async ({ page }) => {\n    // Reset test database\n    await page.request.post('http://localhost:3000/test/reset');\n    \n    checkoutPage = new CheckoutPage(page);\n    await page.goto('/');\n  });\n  \n  test('complete purchase flow', async ({ page }) => {\n    // 1. Add product to cart\n    await checkoutPage.addProductToCart('product-1');\n    \n    // 2. Go to checkout\n    await checkoutPage.proceedToCheckout();\n    await expect(page).toHaveURL('/checkout');\n    \n    // 3. Fill shipping info\n    await checkoutPage.fillShippingInfo({\n      email: 'test@example.com',\n      address: '123 Main St',\n      city: 'San Francisco',\n      zip: '94102'\n    });\n    await page.click('[data-testid=\"continue-to-payment\"]');\n    \n    // 4. Fill payment info\n    await checkoutPage.fillPaymentInfo({\n      number: '4242424242424242',\n      expiry: '12/25',\n      cvc: '123'\n    });\n    \n    // 5. Place order\n    await checkoutPage.submitOrder();\n    \n    // 6. Verify success\n    await expect(page).toHaveURL(/\\/success/);\n    await expect(page.locator('h1')).toHaveText('Order Confirmed!');\n    await expect(page.locator('[data-testid=\"order-number\"]')).toBeVisible();\n  });\n  \n  test('shows validation errors for invalid payment', async ({ page }) => {\n    await checkoutPage.addProductToCart('product-1');\n    await checkoutPage.proceedToCheckout();\n    \n    // Skip to payment\n    await checkoutPage.fillShippingInfo({\n      email: 'test@example.com',\n      address: '123 Main St',\n      city: 'SF',\n      zip: '94102'\n    });\n    await page.click('[data-testid=\"continue-to-payment\"]');\n    \n    // Invalid card\n    await checkoutPage.fillPaymentInfo({\n      number: '1111111111111111',\n      expiry: '12/25',\n      cvc: '123'\n    });\n    await checkoutPage.submitOrder();\n    \n    // Should show error\n    await expect(page.locator('[data-testid=\"payment-error\"]'))\n      .toHaveText('Invalid card number');\n  });\n});"
    }
  ],
  "exercises": [
    {
      "id": "test-ex-1",
      "lessonId": "why-test",
      "moduleId": "testing-basics",
      "title": "Testing Fundamentals",
      "difficulty": "easy",
      "type": "quiz",
      "questions": [
        {
          "question": "Main benefit of testing?",
          "options": ["Makes code slower", "Catches bugs before users do", "Required by law", "Makes code longer"],
          "correctAnswer": 1,
          "explanation": "Tests catch bugs during development, before users encounter them in production."
        },
        {
          "question": "What should you NOT test?",
          "options": ["Business logic", "Simple getters/setters", "Edge cases", "Critical user flows"],
          "correctAnswer": 1,
          "explanation": "Simple getters/setters provide little value when tested. Focus on complex logic and critical paths."
        },
        {
          "question": "Good test coverage goal?",
          "options": ["10%", "50%", "70-80%", "100% always"],
          "correctAnswer": 2,
          "explanation": "70-80% coverage is a good balance. 100% has diminishing returns and wastes time."
        }
      ]
    },
    {
      "id": "test-ex-2",
      "lessonId": "unit-testing",
      "moduleId": "testing-basics",
      "title": "Unit Testing Concepts",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "What is AAA pattern?",
          "options": ["Always Act Aggressively", "Arrange, Act, Assert", "Async, Await, Assert", "All Assertions Always"],
          "correctAnswer": 1,
          "explanation": "AAA = Arrange (setup), Act (do thing), Assert (check result). Standard test structure."
        },
        {
          "question": "What is mocking?",
          "options": ["Making fun of code", "Creating fake implementations for testing", "Testing slowly", "Deleting tests"],
          "correctAnswer": 1,
          "explanation": "Mocking creates fake versions of dependencies (APIs, databases) to isolate your test."
        },
        {
          "question": "Should tests depend on each other?",
          "options": ["Yes, for speed", "No, each test should be independent", "Only in production", "Only for E2E tests"],
          "correctAnswer": 1,
          "explanation": "Tests should be independent - able to run in any order without affecting each other."
        }
      ]
    },
    {
      "id": "test-ex-3",
      "lessonId": "integration-testing",
      "moduleId": "testing-basics",
      "title": "Integration Testing Concepts",
      "difficulty": "medium",
      "type": "quiz",
      "questions": [
        {
          "question": "What does integration testing test?",
          "options": ["One function only", "Multiple units working together", "UI only", "Database only"],
          "correctAnswer": 1,
          "explanation": "Integration tests verify multiple components/units work correctly together."
        },
        {
          "question": "Should you mock everything in integration tests?",
          "options": ["Yes, mock everything", "No, only external services", "Never mock", "Only mock the database"],
          "correctAnswer": 1,
          "explanation": "Mock external services (email, payment) but use real internal code and test database."
        }
      ]
    },
    {
      "id": "test-ex-4",
      "lessonId": "e2e-testing",
      "moduleId": "testing-basics",
      "title": "E2E Testing",
      "difficulty": "hard",
      "type": "quiz",
      "questions": [
        {
          "question": "What does E2E testing test?",
          "options": ["Only frontend", "Only backend", "Entire application in real browser", "Just the database"],
          "correctAnswer": 2,
          "explanation": "E2E tests simulate real user interactions, testing the complete application stack."
        },
        {
          "question": "Best selector for E2E tests?",
          "options": ["CSS classes", "IDs", "data-testid attributes", "XPath"],
          "correctAnswer": 2,
          "explanation": "data-testid attributes are stable and won't break when CSS/styling changes."
        },
        {
          "question": "How many E2E tests should you have?",
          "options": ["Hundreds", "Only critical paths (few)", "One per function", "Test everything E2E"],
          "correctAnswer": 1,
          "explanation": "E2E tests are slow and expensive. Focus on critical user flows, supplement with unit/integration tests."
        }
      ]
    }
  ]
}
