{
  "module": {
    "id": "vibe-coding-mastery",
    "title": "Vibe Coding Mastery",
    "description": "Master the art of working with AI-generated code: read, debug, and refactor like a pro",
    "icon": "Sparkles",
    "requiredXp": 50,
    "color": "from-purple-500 to-pink-600",
    "courseId": "internet-tools"
  },
  "lessons": [
    {
      "id": "reading-ai-code",
      "moduleId": "vibe-coding-mastery",
      "title": "Reading & Understanding AI-Generated Code",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- AI-generated code needs human review\n- Read code top-to-bottom, understand the flow\n- Look for patterns, not just syntax\n- Question everything: \"Why this approach?\"\n- The best developers READ more code than they WRITE\n\n---\n\n# How to Read AI-Generated Code\n\n## The Reality of AI Coding\n\nYou're using Cursor, v0, Bolt, or ChatGPT to generate code. **That's awesome!** But here's the truth:\n\n**AI is a junior developer that:**\n- ‚úÖ Writes code fast\n- ‚úÖ Knows many patterns\n- ‚úÖ Rarely makes syntax errors\n- ‚ùå Doesn't understand your business logic\n- ‚ùå Can't debug production issues\n- ‚ùå Doesn't know when it's wrong\n\n**You need to be the senior developer** who reviews and understands the code.\n\n## Reading Strategy: The 4-Pass Method\n\n### Pass 1: The Bird's Eye View (30 seconds)\n\n**Goal:** Understand WHAT the code does, not HOW.\n\n```javascript\n// AI generated this\nfunction processUserData(users) {\n  return users\n    .filter(u => u.age >= 18)\n    .map(u => ({ ...u, adult: true }))\n    .sort((a, b) => a.name.localeCompare(b.name));\n}\n```\n\n**Questions to ask:**\n- What goes in? (users array)\n- What comes out? (filtered, transformed, sorted users)\n- What's the purpose? (process adult users alphabetically)\n\n### Pass 2: The Logic Check (2 minutes)\n\n**Goal:** Verify the approach makes sense.\n\n**Red flags:**\n```javascript\n// üö© Nested loops (O(n¬≤) - performance issue)\nusers.forEach(user => {\n  users.forEach(other => { /* bad */ });\n});\n\n// üö© Hardcoded values\nif (user.age > 18) { /* should be configurable */ }\n\n// üö© No error handling\nconst data = await fetch(url);  // What if this fails?\n```\n\n### Pass 3: The Deep Dive (5-10 minutes)\n\n**Goal:** Understand HOW it works line-by-line.\n\n**Technique: Talk to yourself**\n\n```javascript\n// \"OK, we filter users where age >= 18\"\n.filter(u => u.age >= 18)\n\n// \"Then we add a property 'adult: true' to each\"\n.map(u => ({ ...u, adult: true }))\n\n// \"Finally sort alphabetically by name\"\n.sort((a, b) => a.name.localeCompare(b.name));\n```\n\n### Pass 4: The Critique (5 minutes)\n\n**Goal:** Find improvements.\n\n**Questions:**\n- Is this readable?\n- Could it break?\n- Is it maintainable?\n- Are there edge cases?\n\n## Pattern Recognition\n\nAI loves certain patterns. Learn to spot them:\n\n### Pattern 1: The Over-Abstraction\n\n```javascript\n// AI might generate this\nconst createUserProcessor = (config) => {\n  return (users) => {\n    return users.filter(config.filterFn).map(config.mapFn);\n  };\n};\n\nconst processor = createUserProcessor({\n  filterFn: u => u.age >= 18,\n  mapFn: u => ({ ...u, adult: true })\n});\n```\n\n**Ask yourself:** \"Do I need this abstraction NOW?\"\n\n**Simpler version:**\n```javascript\nconst adults = users\n  .filter(u => u.age >= 18)\n  .map(u => ({ ...u, adult: true }));\n```\n\n### Pattern 2: The Try-Catch Everything\n\n```javascript\n// AI loves wrapping everything in try-catch\ntry {\n  const result = doSomething();\n  return result;\n} catch (error) {\n  console.error(error);\n  return null;  // üö© Silent failure!\n}\n```\n\n**Better approach:**\n- Only catch errors you can handle\n- Let unexpected errors bubble up\n- Be explicit about error handling\n\n### Pattern 3: The Premature Optimization\n\n```javascript\n// AI might use useMemo for everything\nconst value = useMemo(() => a + b, [a, b]);\n```\n\n**Ask:** \"Is this actually slow without memo?\"\n\nMost of the time, you don't need it.\n\n## Common AI Mistakes to Spot\n\n### 1. Missing Edge Cases\n\n```javascript\n// AI generated\nfunction getFirst(arr) {\n  return arr[0];  // üö© What if arr is empty?\n}\n\n// Better\nfunction getFirst(arr) {\n  return arr?.[0];  // Returns undefined safely\n}\n```\n\n### 2. Ignoring Async Errors\n\n```javascript\n// AI generated\nasync function fetchUser(id) {\n  const response = await fetch(`/api/users/${id}`);\n  const data = await response.json();  // üö© What if response is 404?\n  return data;\n}\n\n// Better\nasync function fetchUser(id) {\n  const response = await fetch(`/api/users/${id}`);\n  if (!response.ok) {\n    throw new Error(`User ${id} not found`);\n  }\n  return response.json();\n}\n```\n\n### 3. Overcomplicated Logic\n\n```javascript\n// AI might generate\nconst isValid = condition ? true : false;\n\n// Just write\nconst isValid = condition;\n```\n\n## The \"Smell Test\"\n\nCode smells are signs something might be wrong:\n\n**üö© Smells:**\n- Functions longer than your screen\n- Variables named `temp`, `data`, `result`\n- Comments explaining WHAT (not WHY)\n- Magic numbers (hardcoded values)\n- Deep nesting (more than 3 levels)\n\n**‚úÖ Good signs:**\n- Clear function names\n- Small, focused functions\n- Obvious variable names\n- Consistent style\n\n## Practice Exercise\n\nHere's AI-generated code. Find 3 problems:\n\n```javascript\nfunction calc(users) {\n  let result = [];\n  for (let i = 0; i < users.length; i++) {\n    if (users[i].age > 18) {\n      let temp = users[i];\n      temp.adult = true;\n      result.push(temp);\n    }\n  }\n  return result;\n}\n```\n\n<details>\n<summary>Problems:</summary>\n\n1. **Bad naming**: `calc` and `temp` don't describe what they do\n2. **Mutating input**: `temp.adult = true` modifies the original user object\n3. **Old-school loop**: Use `.filter().map()` for readability\n\n**Better version:**\n```javascript\nfunction getAdultUsers(users) {\n  return users\n    .filter(user => user.age > 18)\n    .map(user => ({ ...user, adult: true }));\n}\n```\n</details>\n\n## Key Takeaways\n\n1. **AI code is a first draft** - You're the editor\n2. **Read before running** - Understand before executing\n3. **Question patterns** - Why this approach?\n4. **Spot smells** - Trust your instincts\n5. **Simplify** - Less code = less bugs\n\n**Remember:** The goal isn't to understand every line perfectly. It's to understand:\n- What it does\n- How it does it\n- Why it might break\n- How to fix it when it does"
    },
    {
      "id": "debugging-ai-code",
      "moduleId": "vibe-coding-mastery",
      "title": "Reading Error Messages & Stack Traces",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Error messages tell you WHAT broke and WHERE\n- Stack traces show the path to the error\n- Read from bottom to top for the root cause\n- Google the error message - you're not the first\n- Most bugs are simple mistakes, not deep mysteries\n\n---\n\n# Decoding Error Messages\n\n## The #1 Skill for Vibe Coders\n\n**Reality check:** AI generates code that breaks. A LOT.\n\nThe difference between a stuck beginner and a productive vibe coder is simple:\n\n**Beginners:** \"It doesn't work\" üò∞  \n**Vibe coders:** \"ReferenceError: user is not defined - line 42, fixing now\" üí™\n\n## Anatomy of an Error Message\n\nEvery error has 3 parts:\n\n```\nReferenceError: user is not defined\n    at processUser (app.js:42:15)\n    at handleRequest (app.js:28:5)\n    at Server.request (express.js:123:10)\n```\n\n**3 Parts:**\n1. **Error Type**: What kind of error (ReferenceError)\n2. **Error Message**: What went wrong (user is not defined)\n3. **Stack Trace**: Where it happened (app.js line 42)\n\n## Common Error Types\n\n### 1. ReferenceError\n**Meaning:** You're using a variable that doesn't exist.\n\n```javascript\nconsole.log(user);  // ReferenceError: user is not defined\n```\n\n**Fix:** Check spelling, make sure variable is declared.\n\n### 2. TypeError\n**Meaning:** You're using the wrong type.\n\n```javascript\nconst num = null;\nnum.toFixed(2);  // TypeError: Cannot read property 'toFixed' of null\n```\n\n**Fix:** Check if value exists before using it.\n\n```javascript\nconst num = null;\nnum?.toFixed(2);  // undefined (safe)\n```\n\n### 3. SyntaxError\n**Meaning:** Code isn't valid JavaScript.\n\n```javascript\nconst user = { name: 'John'  // SyntaxError: Unexpected end of input\n```\n\n**Fix:** Missing bracket, comma, or quote. Check syntax.\n\n### 4. Error (generic)\n**Meaning:** Something went wrong (usually your code threw it).\n\n```javascript\nthrow new Error('User not found');  // Error: User not found\n```\n\n**Fix:** Read the message, it tells you exactly what's wrong.\n\n## Reading Stack Traces\n\n**Rule:** Read from BOTTOM to TOP.\n\n```\nTypeError: Cannot read property 'name' of undefined\n    at getFullName (user.js:10:15)     ‚Üê Where it broke\n    at formatUser (user.js:5:20)       ‚Üê Who called it\n    at processUsers (app.js:42:10)     ‚Üê Who called that\n    at main (app.js:2:5)               ‚Üê Start of your code\n    at Module._compile (internal)       ‚Üê Ignore (framework code)\n```\n\n**How to read:**\n1. Start at the BOTTOM of YOUR code (line 2 in app.js)\n2. Work UP to where it broke (line 10 in user.js)\n3. Ignore framework code (internal, node_modules)\n\n**Translation:**\n\"I called `main()`, which called `processUsers()`, which called `formatUser()`, which called `getFullName()`, and THAT's where it crashed because something was undefined.\"\n\n## The Debugging Process\n\n### Step 1: READ the error (30 seconds)\n\n```\nTypeError: Cannot read property 'email' of undefined\n    at sendEmail (email.js:15:22)\n```\n\n**Translation:** \"On line 15 of email.js, I tried to read `.email` from something that was undefined.\"\n\n### Step 2: GO to the line (15 seconds)\n\n```javascript\n// email.js, line 15\nfunction sendEmail(user) {\n  const email = user.email;  // ‚Üê LINE 15: user is undefined!\n  // ...\n}\n```\n\n### Step 3: UNDERSTAND why (1 minute)\n\n**Ask:** \"Why is `user` undefined?\"\n\nCheck who called this function:\n\n```javascript\n// app.js\nconst user = getUserById(id);  // Returns undefined if not found\nsendEmail(user);  // Passing undefined!\n```\n\n### Step 4: FIX it (2 minutes)\n\n```javascript\nconst user = getUserById(id);\nif (!user) {\n  console.error('User not found');\n  return;\n}\nsendEmail(user);  // Now it's safe\n```\n\n## Common Mistakes & Fixes\n\n### Mistake 1: \"undefined is not a function\"\n\n```javascript\nconst user = null;\nuser.getName();  // TypeError: user.getName is not a function\n```\n\n**Why:** `user` is null, it has no methods.\n\n**Fix:** Check before calling:\n```javascript\nuser?.getName();  // undefined (safe)\n```\n\n### Mistake 2: \"Cannot read property 'X' of undefined\"\n\n```javascript\nconst user = undefined;\nconsole.log(user.name);  // Cannot read property 'name' of undefined\n```\n\n**Why:** Trying to access property on undefined.\n\n**Fix:** Use optional chaining:\n```javascript\nconsole.log(user?.name);  // undefined (safe)\n```\n\n### Mistake 3: \"X is not defined\"\n\n```javascript\nconsole.log(userName);  // ReferenceError: userName is not defined\n```\n\n**Why:** Variable doesn't exist (typo or not declared).\n\n**Fix:** Check spelling, add declaration:\n```javascript\nconst userName = 'John';\nconsole.log(userName);  // Works\n```\n\n## Browser DevTools\n\nWhen code breaks in the browser:\n\n**1. Open Console (F12)**\n\nYou'll see:\n```\nUncaught TypeError: Cannot read property 'value' of null\n    at app.js:42\n```\n\n**2. Click the filename** (app.js:42)\n\nIt takes you to the exact line.\n\n**3. Add console.logs BEFORE the error**\n\n```javascript\nconsole.log('user:', user);  // See what user is\nconst name = user.name;  // Error happens here\n```\n\n**4. Refresh and check**\n\nDid `user` log as undefined? That's your problem.\n\n## The Google Technique\n\n**Copy-paste the error message into Google.**\n\n```\nTypeError: Cannot read property 'map' of undefined react\n```\n\n**You'll find:**\n- StackOverflow answers\n- Similar bugs\n- Common solutions\n\n**Tip:** Add the framework/library name (\"react\", \"express\") for better results.\n\n## When AI Code Breaks\n\n**Scenario:** AI generated 50 lines. It breaks on line 30.\n\n**DON'T:** Delete everything and ask AI to regenerate.\n\n**DO:**\n1. Read the error\n2. Go to the line\n3. Add console.logs around it\n4. Understand what's undefined/wrong\n5. Fix that ONE thing\n\n**Example:**\n\nAI code:\n```javascript\nconst users = await fetchUsers();\nconst adults = users.filter(u => u.age >= 18);  // TypeError: users.filter is not a function\n```\n\nDebug:\n```javascript\nconst users = await fetchUsers();\nconsole.log('users:', users, typeof users);  // users: {data: [...]}, object\n// AH! fetchUsers returns {data: [...]} not an array!\n\nconst adults = users.data.filter(u => u.age >= 18);  // Fixed\n```\n\n## Red Flags in Errors\n\n### üö© \"Maximum call stack size exceeded\"\n**Meaning:** Infinite recursion.\n\n```javascript\nfunction foo() {\n  foo();  // Calls itself forever\n}\n```\n\n**Fix:** Add base case:\n```javascript\nfunction foo(n) {\n  if (n === 0) return;  // Stop condition\n  foo(n - 1);\n}\n```\n\n### üö© \"Promise rejection unhandled\"\n**Meaning:** Async function threw error, you didn't catch it.\n\n```javascript\nasync function fetchData() {\n  throw new Error('Failed');  // Unhandled!\n}\n```\n\n**Fix:** Add try-catch:\n```javascript\nasync function fetchData() {\n  try {\n    // code\n  } catch (error) {\n    console.error('Failed:', error);\n  }\n}\n```\n\n## Quick Reference\n\n**Error Types:**\n- `ReferenceError` ‚Üí Variable doesn't exist\n- `TypeError` ‚Üí Wrong type (null.something, etc.)\n- `SyntaxError` ‚Üí Invalid code\n\n**Debugging Steps:**\n1. Read error message\n2. Go to the line\n3. Add console.logs\n4. Understand the problem\n5. Fix it\n\n**Tools:**\n- Browser: F12 ‚Üí Console\n- VS Code: Breakpoints (click line number)\n- Terminal: Read the stack trace bottom-to-top\n\n**Remember:**\n- Errors are your friends - they tell you exactly what's wrong\n- Most errors are simple (typo, undefined, wrong type)\n- Google is your best friend\n- AI code breaks just like human code - learn to fix it"
    },
    {
      "id": "spotting-ai-mistakes",
      "moduleId": "vibe-coding-mastery",
      "title": "When AI is Wrong: Red Flags to Spot",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- AI confidently generates wrong code\n- Learn to spot common AI mistakes\n- Trust your instincts - if it feels wrong, it probably is\n- Verify security-sensitive code manually\n- The best AI users are the best AI critics\n\n---\n\n# Red Flags in AI-Generated Code\n\n## The Hard Truth\n\n**AI doesn't know when it's wrong.** It will confidently generate:\n- Code that doesn't work\n- Code with security holes\n- Code that's 10x more complex than needed\n- Code using deprecated APIs\n- Code that looks right but fails edge cases\n\n**Your job:** Be the critic.\n\n## Red Flag #1: Security Vulnerabilities\n\n### SQL Injection\n\nAI might generate:\n```javascript\n// üö© NEVER do this!\nconst query = `SELECT * FROM users WHERE id = ${req.params.id}`;\ndb.query(query);\n```\n\n**Why it's wrong:** User can inject: `1 OR 1=1` ‚Üí leaks all users.\n\n**Fix:** Use parameterized queries:\n```javascript\nconst query = 'SELECT * FROM users WHERE id = ?';\ndb.query(query, [req.params.id]);\n```\n\n### XSS (Cross-Site Scripting)\n\nAI might generate:\n```javascript\n// üö© Dangerous!\ndocument.getElementById('name').innerHTML = userInput;\n```\n\n**Why it's wrong:** User can inject `<script>alert('hacked')</script>`.\n\n**Fix:** Use textContent or escape HTML:\n```javascript\ndocument.getElementById('name').textContent = userInput;  // Safe\n```\n\n### Hardcoded Secrets\n\nAI loves doing this:\n```javascript\n// üö© NEVER commit this!\nconst API_KEY = 'sk_live_abc123secretkey';\nconst DB_PASSWORD = 'mypassword123';\n```\n\n**Fix:** Use environment variables:\n```javascript\nconst API_KEY = process.env.API_KEY;\n```\n\n## Red Flag #2: Performance Issues\n\n### N+1 Query Problem\n\nAI might generate:\n```javascript\n// üö© This does 1 + 100 queries!\nconst users = await db.getUsers();  // 1 query\nfor (const user of users) {\n  user.posts = await db.getPostsByUserId(user.id);  // 100 queries!\n}\n```\n\n**Fix:** Fetch in one query:\n```javascript\nconst users = await db.getUsersWithPosts();  // 1 query with JOIN\n```\n\n### Unnecessary Re-renders (React)\n\nAI generates:\n```javascript\n// üö© Re-creates function on every render\nfunction Component() {\n  const handleClick = () => console.log('clicked');\n  return <button onClick={handleClick}>Click</button>;\n}\n```\n\n**Fix:** Use useCallback when needed:\n```javascript\nfunction Component() {\n  const handleClick = useCallback(() => {\n    console.log('clicked');\n  }, []);\n  return <button onClick={handleClick}>Click</button>;\n}\n```\n\n## Red Flag #3: Wrong API Usage\n\n### Deprecated Methods\n\nAI might use old docs:\n```javascript\n// üö© Deprecated since React 18\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n**Fix:** Use new API:\n```javascript\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n\n### Mixing Async Patterns\n\nAI generates:\n```javascript\n// üö© Don't mix promises and async/await\nfetchData()\n  .then(async data => {\n    await processData(data);\n  });\n```\n\n**Fix:** Pick one pattern:\n```javascript\nconst data = await fetchData();\nawait processData(data);\n```\n\n## Red Flag #4: Over-Engineering\n\n### Premature Abstraction\n\nAI loves abstract patterns:\n```javascript\n// üö© Overkill for a simple task\nclass UserFactory {\n  createUser(type) {\n    switch(type) {\n      case 'admin': return new AdminUser();\n      case 'guest': return new GuestUser();\n      default: return new RegularUser();\n    }\n  }\n}\n\nconst factory = new UserFactory();\nconst user = factory.createUser('admin');\n```\n\n**Do you really need this?** Probably not:\n```javascript\nconst user = { type: 'admin', name: 'John' };\n```\n\n### Unnecessary Dependencies\n\nAI suggests:\n```javascript\nimport _ from 'lodash';\nconst doubled = _.map([1, 2, 3], n => n * 2);\n```\n\n**Fix:** Use native JavaScript:\n```javascript\nconst doubled = [1, 2, 3].map(n => n * 2);\n```\n\n## Red Flag #5: Silent Failures\n\n### Swallowing Errors\n\nAI generates:\n```javascript\n// üö© Error disappears\ntry {\n  await fetchData();\n} catch (error) {\n  console.log('Error occurred');  // No details!\n}\n```\n\n**Fix:** Log properly or throw:\n```javascript\ntry {\n  await fetchData();\n} catch (error) {\n  console.error('Failed to fetch:', error);\n  throw error;  // Don't hide it\n}\n```\n\n### Returning null Instead of Throwing\n\nAI does:\n```javascript\n// üö© Silent failure\nfunction getUser(id) {\n  try {\n    return db.findUser(id);\n  } catch (error) {\n    return null;  // Caller doesn't know something failed\n  }\n}\n```\n\n**Fix:** Let caller handle errors:\n```javascript\nfunction getUser(id) {\n  return db.findUser(id);  // Let error bubble up\n}\n```\n\n## Red Flag #6: Edge Cases Ignored\n\n### Arrays Without Length Check\n\nAI generates:\n```javascript\n// üö© What if array is empty?\nconst first = users[0].name;\n```\n\n**Fix:**\n```javascript\nconst first = users[0]?.name || 'No users';\n```\n\n### Division by Zero\n\nAI code:\n```javascript\n// üö© Could be Infinity or NaN\nconst average = total / count;\n```\n\n**Fix:**\n```javascript\nconst average = count > 0 ? total / count : 0;\n```\n\n## Red Flag #7: Testing for Wrong Things\n\nAI might check:\n```javascript\n// üö© Checks truthiness, not type\nif (value) {\n  // Fails for value = 0 or value = ''\n}\n```\n\n**Fix:** Be explicit:\n```javascript\nif (value !== null && value !== undefined) {\n  // Now 0 and '' work\n}\n```\n\n## How to Catch These\n\n### 1. The Pause Test\n\nBefore running AI code, pause and ask:\n- What could go wrong?\n- What if the input is empty?\n- What if the API fails?\n- Is this secure?\n\n### 2. The Simplicity Test\n\n**Ask:** \"Could I write this simpler?\"\n\nIf yes ‚Üí simplify it.\n\n### 3. The Security Checklist\n\n**Check for:**\n- [ ] User input validation\n- [ ] SQL parameterization\n- [ ] Environment variables (no hardcoded secrets)\n- [ ] HTTPS for sensitive data\n- [ ] Authentication on protected routes\n\n### 4. The Edge Case Test\n\n**Try:**\n- Empty arrays\n- null/undefined values\n- Zero/negative numbers\n- Very long strings\n- Special characters\n\n## When to Trust AI\n\nAI is good at:\n- ‚úÖ Boilerplate code\n- ‚úÖ Common patterns (map, filter, reduce)\n- ‚úÖ Framework setup\n- ‚úÖ Type definitions\n- ‚úÖ Standard CRUD operations\n\nAI is bad at:\n- ‚ùå Your specific business logic\n- ‚ùå Edge cases\n- ‚ùå Performance optimization\n- ‚ùå Security-critical code\n- ‚ùå Debugging production issues\n\n## Quick Reference\n\n**Security Red Flags:**\n- String concatenation in SQL\n- `innerHTML` with user input\n- Hardcoded API keys\n\n**Performance Red Flags:**\n- Nested database queries\n- Large lists without pagination\n- No memoization in heavy computations\n\n**Logic Red Flags:**\n- No null/undefined checks\n- Silent try-catch\n- Ignoring edge cases\n\n**Remember:**\n- AI is a tool, not a teammate\n- Trust but verify\n- If it feels wrong, it probably is\n- Security is your responsibility, not AI's"
    },
    {
      "id": "refactoring-ai-code",
      "moduleId": "vibe-coding-mastery",
      "title": "Refactoring AI Code for Maintainability",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- AI code works but is often messy\n- Refactor = make code cleaner WITHOUT changing behavior\n- Good code is easy to read, modify, and debug\n- Refactor in small steps, test after each\n- Future you will thank present you\n\n---\n\n# Refactoring AI-Generated Code\n\n## Why Refactor?\n\nAI gives you working code fast. But \"working\" ‚â† \"good\".\n\n**Problems with raw AI code:**\n- Hard to understand\n- Hard to modify later\n- Hard to debug when it breaks\n- Full of duplication\n- Longer than needed\n\n**Refactoring makes code:**\n- Readable (you understand it in 6 months)\n- Maintainable (easy to change)\n- Debuggable (easy to fix)\n- Reusable (DRY - Don't Repeat Yourself)\n\n## Refactoring Principle: Small Steps\n\n**Rule:** Change ONE thing, test, commit.\n\n**Don't:** Rewrite everything at once.\n**Do:** Improve incrementally.\n\n## Refactor #1: Extract Magic Numbers\n\n### Before (AI generated)\n```javascript\nfunction getDiscount(price) {\n  if (price > 100) return price * 0.15;\n  if (price > 50) return price * 0.10;\n  return 0;\n}\n```\n\n**Problem:** What do 100, 50, 0.15, 0.10 mean?\n\n### After\n```javascript\nconst PRICE_TIERS = {\n  PREMIUM: 100,\n  STANDARD: 50\n};\n\nconst DISCOUNT_RATES = {\n  PREMIUM: 0.15,  // 15%\n  STANDARD: 0.10  // 10%\n};\n\nfunction getDiscount(price) {\n  if (price > PRICE_TIERS.PREMIUM) {\n    return price * DISCOUNT_RATES.PREMIUM;\n  }\n  if (price > PRICE_TIERS.STANDARD) {\n    return price * DISCOUNT_RATES.STANDARD;\n  }\n  return 0;\n}\n```\n\n**Benefits:**\n- Clear what numbers represent\n- Easy to change rates later\n- Self-documenting\n\n## Refactor #2: Extract Functions\n\n### Before (AI generated)\n```javascript\napp.post('/users', async (req, res) => {\n  // Validation\n  if (!req.body.email || !req.body.email.includes('@')) {\n    return res.status(400).json({ error: 'Invalid email' });\n  }\n  if (!req.body.password || req.body.password.length < 8) {\n    return res.status(400).json({ error: 'Password too short' });\n  }\n  \n  // Hash password\n  const salt = await bcrypt.genSalt(10);\n  const hash = await bcrypt.hash(req.body.password, salt);\n  \n  // Save user\n  const user = await db.createUser({\n    email: req.body.email,\n    passwordHash: hash\n  });\n  \n  res.json({ id: user.id });\n});\n```\n\n**Problem:** Route handler does too much.\n\n### After\n```javascript\nfunction validateUser(email, password) {\n  if (!email?.includes('@')) {\n    throw new Error('Invalid email');\n  }\n  if (!password || password.length < 8) {\n    throw new Error('Password too short');\n  }\n}\n\nasync function hashPassword(password) {\n  const salt = await bcrypt.genSalt(10);\n  return bcrypt.hash(password, salt);\n}\n\napp.post('/users', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    \n    validateUser(email, password);\n    const passwordHash = await hashPassword(password);\n    const user = await db.createUser({ email, passwordHash });\n    \n    res.json({ id: user.id });\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n```\n\n**Benefits:**\n- Each function has one job\n- Easy to test separately\n- Reusable functions\n- Route handler is now readable\n\n## Refactor #3: Remove Duplication (DRY)\n\n### Before (AI generated)\n```javascript\nfunction getActiveUsers() {\n  return users.filter(u => u.active === true);\n}\n\nfunction getActiveAdmins() {\n  return users.filter(u => u.active === true && u.role === 'admin');\n}\n\nfunction getActivePremium() {\n  return users.filter(u => u.active === true && u.premium === true);\n}\n```\n\n**Problem:** `u.active === true` repeated 3 times.\n\n### After\n```javascript\nfunction getUsers(filters) {\n  return users.filter(u => {\n    if (filters.active !== undefined && u.active !== filters.active) {\n      return false;\n    }\n    if (filters.role && u.role !== filters.role) {\n      return false;\n    }\n    if (filters.premium !== undefined && u.premium !== filters.premium) {\n      return false;\n    }\n    return true;\n  });\n}\n\n// Usage\nconst activeUsers = getUsers({ active: true });\nconst activeAdmins = getUsers({ active: true, role: 'admin' });\nconst activePremium = getUsers({ active: true, premium: true });\n```\n\n**Benefits:**\n- One function instead of three\n- Easy to add new filters\n- No duplication\n\n## Refactor #4: Simplify Conditionals\n\n### Before (AI generated)\n```javascript\nfunction canAccess(user, resource) {\n  if (user.role === 'admin') {\n    return true;\n  } else {\n    if (resource.ownerId === user.id) {\n      return true;\n    } else {\n      if (resource.public === true) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }\n}\n```\n\n**Problem:** Nested if-else pyramid of doom.\n\n### After\n```javascript\nfunction canAccess(user, resource) {\n  if (user.role === 'admin') return true;\n  if (resource.ownerId === user.id) return true;\n  if (resource.public) return true;\n  return false;\n}\n```\n\n**Or even simpler:**\n```javascript\nfunction canAccess(user, resource) {\n  return user.role === 'admin' ||\n         resource.ownerId === user.id ||\n         resource.public;\n}\n```\n\n**Benefits:**\n- Flat, not nested\n- Easy to read top-to-bottom\n- Clear logic flow\n\n## Refactor #5: Better Naming\n\n### Before (AI generated)\n```javascript\nfunction calc(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum / arr.length;\n}\n```\n\n**Problem:** `calc` and `arr` don't describe what they do.\n\n### After\n```javascript\nfunction calculateAverage(numbers) {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  return sum / numbers.length;\n}\n```\n\n**Benefits:**\n- Function name describes what it does\n- Variable names are clear\n- Bonus: simpler implementation with reduce\n\n## Refactor #6: Early Returns\n\n### Before (AI generated)\n```javascript\nfunction processUser(user) {\n  if (user) {\n    if (user.active) {\n      if (user.verified) {\n        // Do work\n        return updateUser(user);\n      }\n    }\n  }\n  return null;\n}\n```\n\n**Problem:** Nested ifs create indentation hell.\n\n### After\n```javascript\nfunction processUser(user) {\n  if (!user) return null;\n  if (!user.active) return null;\n  if (!user.verified) return null;\n  \n  return updateUser(user);\n}\n```\n\n**Benefits:**\n- Flat structure\n- Guard clauses at top\n- Happy path at bottom\n\n## Refactor #7: Use Modern JavaScript\n\n### Before (AI might use old style)\n```javascript\nfunction getAdults(users) {\n  const result = [];\n  for (let i = 0; i < users.length; i++) {\n    if (users[i].age >= 18) {\n      result.push({\n        name: users[i].name,\n        age: users[i].age\n      });\n    }\n  }\n  return result;\n}\n```\n\n### After\n```javascript\nfunction getAdults(users) {\n  return users\n    .filter(user => user.age >= 18)\n    .map(({ name, age }) => ({ name, age }));\n}\n```\n\n**Benefits:**\n- Shorter, clearer\n- Functional style\n- Less error-prone\n\n## When to Stop Refactoring\n\n**Stop when:**\n- Code is readable\n- Functions are small (< 20 lines)\n- No duplication\n- Names are clear\n\n**Don't:**\n- Over-optimize\n- Make it \"too clever\"\n- Abstract too early\n- Change working code just because\n\n## Refactoring Workflow\n\n**Step 1:** Get AI code working\n**Step 2:** Read it top to bottom\n**Step 3:** Pick ONE smell to fix\n**Step 4:** Refactor\n**Step 5:** Test it still works\n**Step 6:** Commit\n**Step 7:** Repeat from step 3\n\n## Quick Reference\n\n**Common Refactorings:**\n- Extract magic numbers ‚Üí constants\n- Extract long function ‚Üí smaller functions\n- Remove duplication ‚Üí single reusable function\n- Simplify nested ifs ‚Üí early returns\n- Rename ‚Üí better names\n- Old loops ‚Üí map/filter/reduce\n\n**Red Flags to Refactor:**\n- Function longer than your screen\n- Nested if-else pyramids\n- Variables named `temp`, `data`, `result`\n- Code duplication\n- Magic numbers\n\n**Remember:**\n- Refactor = improve without changing behavior\n- Small steps, test after each\n- Readability > cleverness\n- Future you is your audience"
    },
    {
      "id": "better-ai-prompts",
      "moduleId": "vibe-coding-mastery",
      "title": "Writing Better Prompts for Better Code",
      "order": 5,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Better prompts = better code\n- Be specific about what you want\n- Give context and constraints\n- Ask for explanations, not just code\n- Iterate: refine your prompt based on output\n\n---\n\n# Getting Better Code from AI\n\n## The Prompt Makes the Difference\n\n**Bad prompt:**\n\"make a login form\"\n\n**Result:** Generic form, no validation, no error handling, maybe security holes.\n\n**Good prompt:**\n\"Create a React login form with email/password validation, proper error messages, and loading states. Use controlled inputs and prevent submission if fields are invalid.\"\n\n**Result:** Much closer to what you actually need.\n\n## Anatomy of a Good Prompt\n\nEvery good prompt has 3 parts:\n\n### 1. What (The Goal)\n**Tell AI what to build.**\n\n```\n\"Create a user registration form\"\n```\n\n### 2. How (The Constraints)\n**Tell AI how to build it.**\n\n```\n\"Using React hooks, with Zod validation, styled with Tailwind\"\n```\n\n### 3. Why (The Context)\n**Tell AI why it matters.**\n\n```\n\"For a production app, so include proper error handling and accessibility\"\n```\n\n### Complete Prompt\n\n```\nCreate a user registration form using React hooks,\nwith Zod validation for email/password,\nstyled with Tailwind.\n\nThis is for a production app, so include:\n- Proper error messages\n- Loading states\n- Accessibility (labels, ARIA)\n- Password strength indicator\n\nReturn the form component and the validation schema.\n```\n\n## Prompt Patterns\n\n### Pattern 1: The Specification\n\n**Structure:**\n```\nCreate [WHAT]\nUsing [TECH STACK]\nWith [REQUIREMENTS]\n```\n\n**Example:**\n```\nCreate an async function to fetch user data from an API\nUsing TypeScript and the Fetch API\nWith:\n- Error handling for network failures\n- Retry logic (3 attempts)\n- Timeout after 5 seconds\n- TypeScript types for the response\n```\n\n### Pattern 2: The Refactor\n\n**Structure:**\n```\nRefactor this code to [GOAL]\n[CODE]\nRequirements: [LIST]\n```\n\n**Example:**\n```\nRefactor this code to use modern React hooks instead of class components:\n\n[paste code]\n\nRequirements:\n- Use functional components\n- Use useState and useEffect\n- Keep the same functionality\n- Add TypeScript types\n```\n\n### Pattern 3: The Debug\n\n**Structure:**\n```\nThis code [PROBLEM]\n[CODE]\nError: [ERROR MESSAGE]\n\nWhat's wrong and how do I fix it?\n```\n\n**Example:**\n```\nThis code throws \"Cannot read property 'map' of undefined\"\n\nconst users = await fetchUsers();\nconst names = users.map(u => u.name);\n\nError: TypeError: Cannot read property 'map' of undefined\n\nWhat's wrong and how do I fix it?\n```\n\n### Pattern 4: The Explanation\n\n**Structure:**\n```\nExplain this code in simple terms:\n[CODE]\n\nSpecifically explain [SPECIFIC PART]\n```\n\n**Example:**\n```\nExplain this code in simple terms:\n\nconst memoized = useMemo(() => heavyComputation(data), [data]);\n\nSpecifically explain:\n1. What useMemo does\n2. When the computation runs\n3. What [data] means\n```\n\n## Adding Constraints\n\n### Tech Stack Constraints\n\n```\nUse React 18 with TypeScript\nStyle with Tailwind CSS v3\nState management with Zustand\nForm validation with Zod\n```\n\n### Quality Constraints\n\n```\nInclude:\n- TypeScript types for all functions\n- JSDoc comments for complex logic\n- Error handling with try-catch\n- Loading and error states\n- Accessibility attributes\n```\n\n### Performance Constraints\n\n```\nOptimize for:\n- Fast initial render\n- Minimal re-renders\n- Lazy loading for heavy components\n- Debounced API calls\n```\n\n### Security Constraints\n\n```\nEnsure:\n- Input validation\n- SQL injection prevention\n- XSS protection\n- HTTPS for sensitive data\n```\n\n## Examples: Bad vs Good Prompts\n\n### Example 1: Fetching Data\n\n**‚ùå Bad:**\n\"get users from api\"\n\n**‚úÖ Good:**\n```\nCreate an async function to fetch users from /api/users\nusing TypeScript and the Fetch API.\n\nRequirements:\n- Handle loading, error, and success states\n- Retry failed requests up to 3 times\n- Throw descriptive errors\n- Return typed User[] array\n\nType definition:\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n```\n\n### Example 2: Form Validation\n\n**‚ùå Bad:**\n\"validate email\"\n\n**‚úÖ Good:**\n```\nCreate a Zod schema to validate a registration form with:\n- Email (valid format)\n- Password (min 8 chars, 1 uppercase, 1 number)\n- Confirm password (must match password)\n- Age (must be 18+)\n\nReturn the schema and TypeScript type.\n```\n\n### Example 3: Button Component\n\n**‚ùå Bad:**\n\"make a button component\"\n\n**‚úÖ Good:**\n```\nCreate a reusable React button component with TypeScript.\n\nProps:\n- children (button text)\n- onClick handler\n- variant ('primary' | 'secondary' | 'danger')\n- disabled (boolean)\n- loading (boolean, shows spinner)\n\nStyle with Tailwind.\nInclude accessibility (aria-label, aria-busy).\n```\n\n## Iterating on Prompts\n\n**First attempt:**\n\"Create a search bar\"\n\n**AI gives:** Basic input field.\n\n**Refine:**\n\"Create a search bar with debounced input, loading indicator, and results dropdown\"\n\n**AI gives:** Better, but missing types.\n\n**Refine again:**\n\"Create a TypeScript search bar component with:\n- Debounced input (300ms)\n- Loading indicator during search\n- Dropdown showing results\n- Keyboard navigation (arrow keys)\n- Accessibility (ARIA labels)\"\n\n**AI gives:** Much better!\n\n## Asking for Explanations\n\nDon't just ask for code. Ask AI to explain:\n\n**Good prompts:**\n```\n\"Explain why this approach is better than X\"\n\"What are the trade-offs of this solution?\"\n\"Walk me through this code line by line\"\n\"What could go wrong with this code?\"\n\"How would I test this function?\"\n```\n\n## When AI Gives Bad Code\n\n**DON'T:** Accept it and move on.\n\n**DO:** Give feedback in your next prompt.\n\n**Example:**\n```\nThe code you gave has these issues:\n1. No error handling\n2. Missing TypeScript types\n3. Hardcoded values\n\nPlease fix these issues and return the updated code.\n```\n\n## Prompt Templates\n\n### Component Template\n```\nCreate a [COMPONENT NAME] React component with TypeScript.\n\nProps:\n- [PROP]: [TYPE] - [DESCRIPTION]\n- [PROP]: [TYPE] - [DESCRIPTION]\n\nBehavior:\n- [WHAT IT DOES]\n- [EDGE CASES TO HANDLE]\n\nStyling: [TAILWIND/CSS/etc]\nAccessibility: [REQUIREMENTS]\n```\n\n### Function Template\n```\nCreate a [FUNCTION NAME] function in TypeScript.\n\nInput: [TYPE] - [DESCRIPTION]\nOutput: [TYPE] - [DESCRIPTION]\n\nRequirements:\n- [REQUIREMENT 1]\n- [REQUIREMENT 2]\n\nError handling:\n- [WHAT ERRORS TO CATCH]\n\nInclude JSDoc comment and unit test example.\n```\n\n### API Template\n```\nCreate an API endpoint: [METHOD] [PATH]\n\nRequest body:\n- [FIELD]: [TYPE] - [VALIDATION]\n\nResponse:\n- Success: [STATUS CODE] [RESPONSE SHAPE]\n- Error: [ERROR CODES AND MESSAGES]\n\nValidation:\n- [VALIDATION RULES]\n\nSecurity:\n- [AUTH REQUIREMENTS]\n- [INPUT SANITIZATION]\n```\n\n## Quick Reference\n\n**Good Prompt Structure:**\n1. What to build\n2. Tech stack\n3. Requirements (features)\n4. Constraints (quality, security)\n5. Context (why it matters)\n\n**Add These for Better Code:**\n- \"Include TypeScript types\"\n- \"Add error handling\"\n- \"Include loading states\"\n- \"Make it accessible\"\n- \"Add comments for complex logic\"\n\n**Red Flags in AI Output:**\n- No error handling ‚Üí Ask for it\n- No types ‚Üí Request TypeScript\n- Hardcoded values ‚Üí Ask for constants\n- No validation ‚Üí Specify requirements\n\n**Remember:**\n- Specific prompts = better code\n- Context helps AI understand\n- Iterate on prompts\n- Ask for explanations\n- Give feedback on bad output"
    }
  ],
  "exercises": []
}
