{
  "module": {
    "id": "nextjs-middleware",
    "title": "Middleware",
    "description": "Control request flow with Next.js Middleware",
    "icon": "Filter",
    "requiredXp": 7000,
    "color": "from-indigo-500 to-purple-600",
    "courseId": "nextjs"
  },
  "lessons": [
    {
      "id": "middleware-intro",
      "moduleId": "nextjs-middleware",
      "title": "Middleware Basics",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Middleware runs before every request\n- Create middleware.js in project root\n- Use matcher config to filter routes\n- Can rewrite, redirect, or modify responses\n- Perfect for auth, i18n, logging\n\n---\n\n# Next.js Middleware\n\n## What is Middleware?\n\nMiddleware in Next.js runs **before** a request is completed. It allows you to:\n- Authenticate users\n- Redirect based on conditions\n- Rewrite URLs\n- Add headers\n- Handle A/B testing\n- Manage internationalization\n- Rate limit requests\n\n## Creating Middleware\n\n```javascript\n// middleware.js (in project root)\nimport { NextResponse } from 'next/server';\n\nexport function middleware(request) {\n  // This runs on every request\n  console.log('Request:', request.url);\n  \n  // Continue to the requested page\n  return NextResponse.next();\n}\n\n// Optional: Configure which routes middleware runs on\nexport const config = {\n  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']\n};\n```\n\n## The matcher Config\n\nControl which routes use middleware:\n\n```javascript\n// Run on specific routes only\nexport const config = {\n  matcher: ['/dashboard/:path*', '/admin/:path*']\n};\n\n// Exclude certain patterns\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except:\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     * - public folder\n     */\n    '/((?!_next/static|_next/image|favicon.ico|public).*)'\n  ]\n};\n\n// Multiple matchers\nexport const config = {\n  matcher: [\n    '/dashboard/:path*',\n    '/profile/:path*',\n    '/api/protected/:path*'\n  ]\n};\n```\n\n## Authentication Middleware\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nexport function middleware(request) {\n  const token = request.cookies.get('token');\n  const { pathname } = request.nextUrl;\n  \n  // Public paths that don't require auth\n  const publicPaths = ['/login', '/register', '/'];\n  const isPublicPath = publicPaths.includes(pathname);\n  \n  // If no token and trying to access protected route\n  if (!token && !isPublicPath) {\n    return NextResponse.redirect(new URL('/login', request.url));\n  }\n  \n  // If has token and trying to access login/register\n  if (token && isPublicPath && pathname !== '/') {\n    return NextResponse.redirect(new URL('/dashboard', request.url));\n  }\n  \n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']\n};\n```\n\n## Redirects\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nexport function middleware(request) {\n  const { pathname } = request.nextUrl;\n  \n  // Redirect old URLs to new ones\n  if (pathname.startsWith('/old-blog/')) {\n    const newPath = pathname.replace('/old-blog/', '/blog/');\n    return NextResponse.redirect(new URL(newPath, request.url), 301);\n  }\n  \n  // Redirect based on user agent\n  const userAgent = request.headers.get('user-agent') || '';\n  if (/Mobile/.test(userAgent) && pathname === '/') {\n    return NextResponse.redirect(new URL('/mobile', request.url));\n  }\n  \n  return NextResponse.next();\n}\n```\n\n## URL Rewrites\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nexport function middleware(request) {\n  const { pathname } = request.nextUrl;\n  \n  // Rewrite /product-123 to /products/123\n  if (pathname.startsWith('/product-')) {\n    const id = pathname.replace('/product-', '');\n    const url = request.nextUrl.clone();\n    url.pathname = `/products/${id}`;\n    return NextResponse.rewrite(url);\n  }\n  \n  // A/B testing\n  const bucket = request.cookies.get('bucket')?.value || 'a';\n  if (pathname === '/landing') {\n    const url = request.nextUrl.clone();\n    url.pathname = bucket === 'a' ? '/landing-a' : '/landing-b';\n    return NextResponse.rewrite(url);\n  }\n  \n  return NextResponse.next();\n}\n```\n\n## Adding Headers\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nexport function middleware(request) {\n  const requestHeaders = new Headers(request.headers);\n  \n  // Add custom header\n  requestHeaders.set('x-request-id', crypto.randomUUID());\n  \n  // Add user info from token (if authenticated)\n  const token = request.cookies.get('token');\n  if (token) {\n    const user = decodeToken(token);\n    requestHeaders.set('x-user-id', user.id);\n  }\n  \n  return NextResponse.next({\n    request: {\n      headers: requestHeaders\n    }\n  });\n}\n```\n\n## Internationalization (i18n)\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nconst locales = ['en', 'es', 'fr'];\nconst defaultLocale = 'en';\n\nexport function middleware(request) {\n  const { pathname } = request.nextUrl;\n  \n  // Check if pathname starts with a locale\n  const pathnameHasLocale = locales.some(\n    locale => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`\n  );\n  \n  if (pathnameHasLocale) return NextResponse.next();\n  \n  // Detect user's preferred locale\n  const locale = request.headers.get('accept-language')?.split(',')[0].split('-')[0] || defaultLocale;\n  const finalLocale = locales.includes(locale) ? locale : defaultLocale;\n  \n  // Redirect to locale-prefixed path\n  request.nextUrl.pathname = `/${finalLocale}${pathname}`;\n  return NextResponse.redirect(request.nextUrl);\n}\n\nexport const config = {\n  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']\n};\n```\n\n## Edge Runtime\n\nMiddleware runs on the Edge Runtime:\n\n```javascript\n// middleware.js\nexport const runtime = 'edge'; // Explicitly set edge runtime\n\nexport function middleware(request) {\n  // This runs at the edge, close to the user\n  const country = request.geo?.country || 'US';\n  \n  // Redirect based on country\n  if (country === 'GB') {\n    return NextResponse.redirect('https://uk.example.com');\n  }\n  \n  return NextResponse.next();\n}\n```\n\n## Middleware Response\n\nModify the response before sending to browser:\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nexport async function middleware(request) {\n  const response = NextResponse.next();\n  \n  // Add security headers to all responses\n  response.headers.set('X-DNS-Prefetch-Control', 'on');\n  response.headers.set('Strict-Transport-Security', 'max-age=63072000');\n  response.headers.set('X-Frame-Options', 'SAMEORIGIN');\n  response.headers.set('X-Content-Type-Options', 'nosniff');\n  response.headers.set('Referrer-Policy', 'origin-when-cross-origin');\n  \n  // Add cache header for static assets\n  if (request.nextUrl.pathname.startsWith('/static/')) {\n    response.headers.set('Cache-Control', 'public, max-age=31536000, immutable');\n  }\n  \n  return response;\n}\n```"
    },
    {
      "id": "middleware-advanced",
      "moduleId": "nextjs-middleware",
      "title": "Advanced Middleware Patterns",
      "order": 2,
      "difficulty": "advanced",
      "content": "# Essential to know\n- Middleware can run at the edge for low latency\n- Chain multiple middleware functions\n- Use middleware for feature flags\n- Implement bot protection\n- Handle complex routing logic\n\n---\n\n# Advanced Middleware Techniques\n\n## Chaining Middleware\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\nimport { authMiddleware } from './middleware/auth';\nimport { i18nMiddleware } from './middleware/i18n';\nimport { loggingMiddleware } from './middleware/logging';\n\nexport async function middleware(request) {\n  // Run middleware in sequence\n  const response = await loggingMiddleware(request, async () => {\n    return await i18nMiddleware(request, async () => {\n      return await authMiddleware(request);\n    });\n  });\n  \n  return response;\n}\n\n// middleware/auth.js\nexport async function authMiddleware(request, next) {\n  const token = request.cookies.get('token');\n  \n  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {\n    return NextResponse.redirect(new URL('/login', request.url));\n  }\n  \n  return next ? await next() : NextResponse.next();\n}\n\n// middleware/i18n.js\nexport async function i18nMiddleware(request, next) {\n  const locale = request.cookies.get('locale')?.value || 'en';\n  request.headers.set('x-locale', locale);\n  \n  return next ? await next() : NextResponse.next();\n}\n\n// middleware/logging.js\nexport async function loggingMiddleware(request, next) {\n  const start = Date.now();\n  const response = next ? await next() : NextResponse.next();\n  const duration = Date.now() - start;\n  \n  console.log(`${request.method} ${request.url} - ${duration}ms`);\n  \n  return response;\n}\n```\n\n## Feature Flags\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nconst features = {\n  newDashboard: {\n    enabled: true,\n    rollout: 0.5 // 50% of users\n  },\n  betaFeature: {\n    enabled: false\n  }\n};\n\nexport function middleware(request) {\n  const { pathname } = request.nextUrl;\n  \n  // Check if user should see new dashboard\n  if (pathname === '/dashboard' && features.newDashboard.enabled) {\n    const userId = request.cookies.get('userId')?.value;\n    const hash = hashString(userId || '');\n    \n    if (hash < features.newDashboard.rollout) {\n      request.nextUrl.pathname = '/dashboard-v2';\n      return NextResponse.rewrite(request.nextUrl);\n    }\n  }\n  \n  return NextResponse.next();\n}\n```\n\n## Bot Detection\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nconst botPatterns = [\n  'bot',\n  'crawler',\n  'spider',\n  'slurp',\n  'baidu',\n  'yandex'\n];\n\nexport function middleware(request) {\n  const userAgent = request.headers.get('user-agent')?.toLowerCase() || '';\n  const isBot = botPatterns.some(pattern => userAgent.includes(pattern));\n  \n  if (isBot) {\n    // Add header for bot detection\n    const requestHeaders = new Headers(request.headers);\n    requestHeaders.set('x-is-bot', 'true');\n    \n    return NextResponse.next({\n      request: {\n        headers: requestHeaders\n      }\n    });\n  }\n  \n  return NextResponse.next();\n}\n```\n\n## A/B Testing\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nconst experiments = {\n  checkoutFlow: {\n    variants: ['control', 'simplified'],\n    weights: [0.5, 0.5]\n  }\n};\n\nexport function middleware(request) {\n  const { pathname } = request.nextUrl;\n  \n  if (pathname === '/checkout') {\n    // Check if user already has variant assigned\n    let variant = request.cookies.get('exp-checkout')?.value;\n    \n    if (!variant) {\n      // Assign variant based on weights\n      const random = Math.random();\n      variant = random < 0.5 ? 'control' : 'simplified';\n      \n      // Set cookie to persist variant\n      const response = NextResponse.rewrite(\n        new URL(`/checkout-${variant}`, request.url)\n      );\n      response.cookies.set('exp-checkout', variant, {\n        maxAge: 60 * 60 * 24 * 30 // 30 days\n      });\n      \n      return response;\n    }\n    \n    return NextResponse.rewrite(\n      new URL(`/checkout-${variant}`, request.url)\n    );\n  }\n  \n  return NextResponse.next();\n}\n```\n\n## Dynamic Configuration\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\n// This can be updated at runtime\nlet maintenanceMode = false;\n\nexport function middleware(request) {\n  // Check maintenance mode\n  if (maintenanceMode && !request.nextUrl.pathname.startsWith('/maintenance')) {\n    return NextResponse.redirect(new URL('/maintenance', request.url));\n  }\n  \n  // API to toggle maintenance mode (protected)\n  if (request.nextUrl.pathname === '/api/admin/maintenance') {\n    const auth = request.headers.get('authorization');\n    if (auth === `Bearer ${process.env.ADMIN_TOKEN}`) {\n      maintenanceMode = !maintenanceMode;\n      return NextResponse.json({ maintenanceMode });\n    }\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n  \n  return NextResponse.next();\n}\n```\n\n## Conditional Middleware\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\nexport function middleware(request) {\n  const { pathname } = request.nextUrl;\n  \n  // Only run certain logic for specific paths\n  if (pathname.startsWith('/api/')) {\n    return handleApiMiddleware(request);\n  }\n  \n  if (pathname.startsWith('/dashboard')) {\n    return handleDashboardMiddleware(request);\n  }\n  \n  return NextResponse.next();\n}\n\nfunction handleApiMiddleware(request) {\n  // API-specific logic\n  const response = NextResponse.next();\n  response.headers.set('x-api-version', 'v1');\n  return response;\n}\n\nfunction handleDashboardMiddleware(request) {\n  // Dashboard-specific logic\n  const token = request.cookies.get('token');\n  \n  if (!token) {\n    return NextResponse.redirect(new URL('/login', request.url));\n  }\n  \n  return NextResponse.next();\n}\n```\n\n## Rate Limiting in Middleware\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server';\n\n// Simple in-memory store (use Redis in production)\nconst rateLimit = new Map();\n\nexport function middleware(request) {\n  const { pathname } = request.nextUrl;\n  \n  // Only rate limit API routes\n  if (!pathname.startsWith('/api/')) {\n    return NextResponse.next();\n  }\n  \n  const ip = request.ip || 'anonymous';\n  const now = Date.now();\n  const windowStart = now - 60000; // 1 minute window\n  \n  // Get requests from this IP\n  const requests = rateLimit.get(ip) || [];\n  const recentRequests = requests.filter(time => time > windowStart);\n  \n  if (recentRequests.length >= 60) {\n    return NextResponse.json(\n      { error: 'Rate limit exceeded' },\n      {\n        status: 429,\n        headers: {\n          'X-RateLimit-Limit': '60',\n          'X-RateLimit-Remaining': '0',\n          'Retry-After': '60'\n        }\n      }\n    );\n  }\n  \n  recentRequests.push(now);\n  rateLimit.set(ip, recentRequests);\n  \n  const response = NextResponse.next();\n  response.headers.set('X-RateLimit-Limit', '60');\n  response.headers.set('X-RateLimit-Remaining', (60 - recentRequests.length).toString());\n  \n  return response;\n}\n```\n\n## Edge Runtime APIs\n\n```javascript\n// middleware.js\nexport const runtime = 'edge';\n\nexport function middleware(request) {\n  // Access Edge Runtime APIs\n  \n  // Geolocation\n  const country = request.geo?.country;\n  const city = request.geo?.city;\n  const region = request.geo?.region;\n  \n  // IP address\n  const ip = request.ip;\n  \n  // Use Web APIs available in Edge\n  const url = new URL(request.url);\n  const headers = new Headers(request.headers);\n  \n  // Use crypto (available in Edge)\n  const uuid = crypto.randomUUID();\n  \n  // Use TextEncoder/Decoder\n  const encoder = new TextEncoder();\n  const data = encoder.encode('Hello');\n  \n  return NextResponse.next();\n}\n```"
    }
  ],
  "exercises": [
    {
      "id": "middleware-ex-1",
      "type": "quiz",
      "lessonId": "middleware-intro",
      "moduleId": "nextjs-middleware",
      "title": "Middleware Fundamentals",
      "difficulty": "easy",
      "questions": [
        {
          "question": "Where should you place the middleware.js file?",
          "options": [
            "In the app directory",
            "In the project root (same level as app)",
            "In the pages directory",
            "In the public directory"
          ],
          "correctAnswer": 1,
          "explanation": "The middleware.js file should be placed in the project root (at the same level as the app directory), not inside the app folder."
        },
        {
          "question": "What is the purpose of the matcher config?",
          "options": [
            "To match database queries",
            "To define which routes the middleware runs on",
            "To match regular expressions",
            "To configure webpack"
          ],
          "correctAnswer": 1,
          "explanation": "The matcher config in middleware.js defines which routes the middleware should run on, using path patterns."
        }
      ]
    }
  ]
}
