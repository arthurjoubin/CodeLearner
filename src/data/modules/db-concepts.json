{
  "module": {
    "id": "db-concepts",
    "title": "Databases: Concepts and Choices",
    "description": "Understand different types of databases and choose the right solution for each use case",
    "icon": "Database",
    "requiredXp": 600,
    "color": "from-blue-500 to-indigo-600",
    "courseId": "databases"
  },
  "lessons": [
    {
      "id": "db-why",
      "moduleId": "db-concepts",
      "title": "Why a Database?",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- JSON files are not enough for real applications\n- Data persistence beyond the app lifecycle\n- Concurrent access (multiple simultaneous users)\n- Complex and performant querying\n- Data security and integrity\n\n---\n\n# The Problem with Files\n\nImagine storing your data in a JSON file:\n\n```javascript\n// ❌ Bad idea in production\nconst users = JSON.parse(readFileSync('users.json'));\nusers.push(newUser);\nwriteFileSync('users.json', JSON.stringify(users));\n```\n\n**Problems:**\n1. **Concurrency**: If 2 users write simultaneously = corrupted data\n2. **Performance**: Loading entire file for one query = slow with 1M+ rows\n3. **Search**: Finding a user = scanning entire file\n4. **Integrity**: Nothing prevents 2 users with same email\n5. **Security**: Accessible file = data stolen\n\n## Why a Database?\n\n### 1. Persistence\nData survives app restart. Even after a crash, your data is there.\n\n### 2. Concurrency\nThousands of users can read/write simultaneously without conflicts thanks to transactions and locks.\n\n### 3. Performance\n- Indexing: Find data in milliseconds even on millions of rows\n- Optimized queries: DB engine chooses best execution plan\n- Caching: Frequently used data in memory\n\n### 4. Integrity\n- Constraints: Uniqueness, foreign keys, data types\n- Transactions: Everything succeeds or everything fails (atomicity)\n- Validations: CHECK constraints, triggers\n\n### 5. Powerful Querying\nSQL allows complex queries:\n- Joins between tables\n- Aggregations (COUNT, SUM, AVG)\n- Complex filtering\n- Sorting and ranking\n\n## When to Use What?\n\n| Solution | Use Case | Limit |\n|----------|----------|-------|\n| JSON File | Config, local cache, tests | Concurrency, volume |\n| SQLite | Mobile apps, IoT, tests | Single writer only |\n| PostgreSQL | Web apps, SaaS, complex data | Requires server |\n| MySQL | Classic web apps, WordPress | Fewer advanced features |\n| MongoDB | Flexible data, prototyping | Eventual consistency |\n| Redis | Cache, sessions, real-time | RAM only |\n\n## ACID: Essential Properties\n\nRelational databases guarantee ACID:\n\n### Atomicity\nA transaction is indivisible. Everything succeeds or everything fails.\n\n```\nBank transfer:\n1. Debit account A\n2. Credit account B\n\nIf 2 fails → 1 is rolled back (ROLLBACK)\n```\n\n### Consistency\nDB moves from one valid state to another valid state. Constraints always respected.\n\n### Isolation\nConcurrent transactions don't interfere. Result identical to sequential execution.\n\n### Durability\nOnce a transaction commits, it persists even on crash.\n\n## Types of Databases\n\n### SQL (Relational)\n**Structure**: Tables with typed columns, relationships via foreign keys\n**Language**: SQL\n**Examples**: PostgreSQL, MySQL, SQLite, SQL Server\n**Use Case**: Structured data, business apps\n\n### NoSQL (Non-relational)\n**Document** (MongoDB): JSON-like, flexible schema\n**Key-Value** (Redis): Hash map, ultra-fast\n**Wide Column** (Cassandra): Massive distributed data\n**Graphs** (Neo4j): Complex relationships\n\n**Use Case**: Big Data, unstructured content, horizontal scaling, rapid prototyping\n\n## Big Picture: Typical Architecture\n\n```\n┌─────────────────┐\n│   Client Web    │\n│   (React/Vue)   │\n└────────┬────────┘\n         │ HTTP/HTTPS\n┌────────▼────────┐\n│  API Node.js    │\n│   (Express)     │\n└────────┬────────┘\n         │\n    ┌────┴────┬──────────┐\n    │         │          │\n┌───▼───┐ ┌──▼───┐ ┌────▼────┐\n│Postgre│ │Redis ││   S3    │\n│  SQL  │ │Cache ││  (Files)│\n└───────┘ └──────┘ └─────────┘\n```\n\n- **PostgreSQL**: Main data (users, orders)\n- **Redis**: Cache, sessions, rate limiting\n- **S3**: Files (images, documents)"
    },
    {
      "id": "db-sql-vs-nosql",
      "moduleId": "db-concepts",
      "title": "SQL vs NoSQL: When to Choose?",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- SQL = rigid structure, complex relations, ACID guaranteed\n- NoSQL = flexibility, horizontal scaling, raw performance\n- Choice depends on data, team, constraints\n- Hybrid is often best solution\n\n---\n\n# SQL vs NoSQL: The Match\n\n## SQL (Relational)\n\n### ✅ Advantages\n- **Strict schema**: Data validation guaranteed\n- **Powerful relations**: Complex JOINs, referential integrity\n- **ACID**: Reliable transactions\n- **SQL universal**: Standard language, portable\n- **Mature**: Abundant tools, ORMs, documentation\n- **Ad-hoc queries**: Complex analysis possible\n\n### ❌ Disadvantages\n- **Vertical scaling**: Bigger server = expensive\n- **Rigid schema**: Migrations needed for structure changes\n- **Complexity**: Relational modeling requires experience\n\n## NoSQL (Document, Key-Value, etc.)\n\n### ✅ Advantages\n- **Flexibility**: Dynamic schema, no migrations\n- **Horizontal scaling**: Add servers easily\n- **Performance**: Fast read/write on simple queries\n- **Hierarchical data**: Nested JSON documents natural\n- **Rapid development**: No schema to define first\n\n### ❌ Disadvantages\n- **No JOINs**: Related data = multiple queries or duplication\n- **Eventual consistency**: Temporarily inconsistent data\n- **Fewer tools**: Less mature ORMs\n- **Limited queries**: Hard to analyze without schema\n- **Storage**: Data duplication = more space\n\n## Practical Comparison\n\n### Case: Blog with Articles and Comments\n\n**SQL (PostgreSQL)**:\n```sql\n-- Separate tables\nCREATE TABLE articles (\n  id SERIAL PRIMARY KEY,\n  title VARCHAR(255),\n  content TEXT,\n  author_id INTEGER REFERENCES users(id)\n);\n\nCREATE TABLE comments (\n  id SERIAL PRIMARY KEY,\n  article_id INTEGER REFERENCES articles(id),\n  content TEXT,\n  author_id INTEGER REFERENCES users(id)\n);\n\n-- Query with JOIN\nSELECT a.*, c.* FROM articles a\nLEFT JOIN comments c ON c.article_id = a.id\nWHERE a.id = 1;\n```\n\n**NoSQL (MongoDB)**:\n```javascript\n// Nested document\n{\n  _id: ObjectId('...'),\n  title: 'My article',\n  content: '...',\n  author_id: ObjectId('...'),\n  comments: [\n    { content: 'Great!', author_id: ObjectId('...'), date: ISODate() },\n    { content: 'Thanks', author_id: ObjectId('...'), date: ISODate() }\n  ]\n}\n\n// One query to get everything\ndb.articles.findOne({ _id: articleId })\n```\n\n### When to Choose SQL?\n\n✅ **Choose SQL if:**\n- Your data is strongly structured\n- You need complex transactions (banking, e-commerce)\n- Multiple relations between entities (frequent JOINs)\n- Complex analysis required (reporting, BI)\n- Experienced SQL team\n- Examples: Finance, ERP, CRM, Traditional e-commerce\n\n### When to Choose NoSQL?\n\n✅ **Choose NoSQL if:**\n- Flexible or unknown data structure\n- Massive scaling needed (millions of users)\n- Simple hierarchical data\n- Rapid prototyping (schema evolves)\n- Need raw speed on simple reads\n- Examples: Social networks, IoT, Caching, Logs\n\n## Best of Both Worlds\n\nOften, modern apps use both:\n\n```\nPostgreSQL (main data)\n  ├── Users\n  ├── Orders\n  ├── Payments\n  └── Products\n\nMongoDB (flexible data)\n  ├── Product catalogs (variable specs)\n  └── Content management\n\nRedis (performance)\n  ├── Sessions\n  ├── Cache\n  └── Rate limiting\n\nElasticsearch (search)\n  └── Full-text search\n```\n\n## Decision Tree\n\n```\nNeed complex transactions?\n├── YES → SQL (PostgreSQL/MySQL)\n└── NO →\n    Data strongly linked with JOINs?\n    ├── YES → SQL\n    └── NO →\n        Schema stable and known?\n        ├── YES → SQL\n        └── NO →\n            Horizontal scaling essential?\n            ├── YES → NoSQL (MongoDB/Cassandra)\n            └── NO → SQL or NoSQL by preference\n```\n\n## Our Recommendation\n\nFor a beginner backend developer:\n\n1. **Start with PostgreSQL**\n   - Learn fundamentals (tables, relations, SQL)\n   - Transferable to 90% of jobs\n   - Best practices structure\n\n2. **Add Redis for caching**\n   - Simple and immediately useful\n\n3. **Learn MongoDB later**\n   - When you have specific use case\n   - Understand trade-offs\n\n4. **Polyglot architecture**\n   - PostgreSQL + Redis for most apps\n   - Add other DBs when needed"
    },
    {
      "id": "db-choosing",
      "moduleId": "db-concepts",
      "title": "Selection Guide: Which Database for My Project?",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- SQLite: Development, tests, embedded apps\n- PostgreSQL: Production, serious applications\n- MySQL: Traditional, WordPress, shared hosting\n- MongoDB: Prototyping, flexible data, scaling\n- Redis: Cache, sessions, queues\n\n---\n\n# Guide by Use Case\n\n## 1. SQLite - The Lightweight Database\n\n### Characteristics\n- **Single file** (.db or .sqlite)\n- **Zero-config**: No server installation\n- **Embedded**: Works in the application\n- **Limitation**: One writer at a time\n\n### Perfect For\n- ✅ Local development\n- ✅ Automated tests\n- ✅ Desktop/mobile applications\n- ✅ IoT and embedded\n- ✅ Static sites with little data\n- ✅ Rapid prototyping\n\n### Example Node.js\n```javascript\nimport sqlite3 from 'sqlite3';\n\nconst db = new sqlite3.Database('./myapp.db');\n\ndb.run(`\n  CREATE TABLE IF NOT EXISTS users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    email TEXT UNIQUE,\n    name TEXT\n  )\n`);\n```\n\n## 2. PostgreSQL - The Professional Database\n\n### Characteristics\n- **Open source** and mature (30+ years)\n- **Advanced features**: JSON, arrays, full-text search\n- **Extensible**: PostGIS (geo), TimescaleDB (time-series)\n- **Industry standard** for modern apps\n\n### Perfect For\n- ✅ Web applications production\n- ✅ Complex and relational data\n- ✅ Analytics and reporting\n- ✅ Geospatial needs\n- ✅ Startups and enterprises\n\n### Why Choose PostgreSQL?\n- JSONB: Store JSON with indexing\n- Arrays and custom types\n- Full ACID and MVCC (optimized concurrency)\n- Excellent ecosystem (ORMs, tools, cloud)\n\n## 3. MySQL / MariaDB\n\n### Characteristics\n- **Widespread** (WordPress, Drupal)\n- **Simple** to install and manage\n- **Good support** on shared hosting\n- **MariaDB**: Open source fork of MySQL\n\n### Perfect For\n- ✅ Traditional PHP applications\n- ✅ Shared hosting\n- ✅ WordPress and CMS\n- ✅ When PostgreSQL unavailable\n\n### PostgreSQL vs MySQL Today\n- PostgreSQL has more modern features\n- MySQL remains relevant for LAMP ecosystem\n- For new app: choose PostgreSQL\n\n## 4. MongoDB - The Document Store\n\n### Characteristics\n- **JSON documents** (BSON internally)\n- **Flexible schema**: Each doc can differ\n- **Horizontal scaling** native (sharding)\n- **Rich queries** on documents\n\n### Perfect For\n- ✅ Rapid prototyping (schema evolves)\n- ✅ Product catalogs (variable specs)\n- ✅ CMS with flexible content\n- ✅ IoT and time-series (with time-series collections)\n- ✅ Unpredictable schema\n\n### When to Avoid MongoDB\n- ❌ Complex multi-document transactions\n- ❌ Complex relations needing JOINs\n- ❌ Complex analytics and reporting\n\n## 5. Redis - The Cache and Beyond\n\n### Characteristics\n- **In-memory** (RAM): Ultra-fast\n- **Key-value**: Strings, lists, sets, hashes\n- **Optional persistence**\n- **Pub/Sub**: Real-time messaging\n\n### Perfect For\n- ✅ Database query cache\n- ✅ User sessions\n- ✅ Rate limiting\n- ✅ Task queues\n- ✅ Real-time counters\n- ✅ Leaderboards (sorted sets)\n\n### Typical Usage with PostgreSQL\n```javascript\n// 1. Check cache\nlet user = await redis.get(`user:${id}`);\n\n// 2. If not cached, query DB\nif (!user) {\n  user = await db.query('SELECT * FROM users WHERE id = $1', [id]);\n  // 3. Cache for next time\n  await redis.setex(`user:${id}`, 3600, JSON.stringify(user));\n}\n```\n\n## Quick Decision Matrix\n\n| Project | Recommendation | Why |\n|---------|---------------|-----|\n| MVP / Prototype | SQLite → PostgreSQL | Start simple, migrate if successful |\n| SaaS B2B | PostgreSQL | Structured data, ACID essential |\n| E-commerce | PostgreSQL + Redis | Transactions + Cache |\n| Blog / CMS | PostgreSQL or MongoDB | Depends on content structure |\n| Social Network | PostgreSQL + Redis | Relations + Real-time feed |\n| IoT / Time-series | PostgreSQL + TimescaleDB or MongoDB | Massive data volume |\n| Mobile App | SQLite (local) + API with PostgreSQL | Sync when connected |\n\n## Our Recommended Stack\n\nFor most modern web applications:\n\n```\n┌─────────────────────────────────────┐\n│         PostgreSQL                  │\n│    (Main Data)                      │\n└─────────────────────────────────────┘\n                  │\n                  ▼\n┌─────────────────────────────────────┐\n│         Redis                       │\n│  (Cache, Sessions, Rate Limit)      │\n└─────────────────────────────────────┘\n```\n\nThis combination covers 90% of use cases with:\n- Safe and structured data (PostgreSQL)\n- Optimal performance (Redis)\n- Simplicity of management\n- Abundant documentation and tools"
    }
  ],
  "exercises": []
}
