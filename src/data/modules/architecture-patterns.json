{
  "module": {
    "id": "architecture-patterns",
    "title": "Architecture Patterns",
    "description": "MVC, microservices, serverless, API-first, and JAMstack",
    "icon": "Boxes",
    "requiredXp": 1750,
    "color": "from-violet-400 to-violet-600",
    "courseId": "production"
  },
  "lessons": [
    {
      "id": "mvc-pattern",
      "moduleId": "architecture-patterns",
      "title": "MVC Pattern",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- MVC = Model-View-Controller (separation of concerns)\n- Model = Data/business logic, View = UI, Controller = Request handling\n- Classic pattern for web applications\n- Helps organize code and make it maintainable\n\n---\n\n# MVC: Organized Architecture\n\n## What is MVC?\n\n**MVC** (Model-View-Controller) is a design pattern that separates application into three interconnected parts.\n\n**Goal:** Separate concerns for better organization and maintainability.\n\n## The Three Parts\n\n### Model (Data)\n**Responsibilities:**\n- Database structure\n- Business logic\n- Data validation\n- State management\n\n**Example:**\n```javascript\n// User model\nclass User {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n  \n  validate() {\n    if (!this.email.includes('@')) {\n      throw new Error('Invalid email');\n    }\n  }\n  \n  save() {\n    // Save to database\n    database.insert(this);\n  }\n}\n```\n\n### View (Presentation)\n**Responsibilities:**\n- Display data to user\n- HTML/UI rendering\n- User interface logic\n- No business logic!\n\n**Example:**\n```html\n<!-- User profile view -->\n<div class=\"user-profile\">\n  <h1>{{ user.name }}</h1>\n  <p>{{ user.email }}</p>\n  <button>Edit Profile</button>\n</div>\n```\n\n### Controller (Coordinator)\n**Responsibilities:**\n- Handle requests\n- Call models\n- Choose views\n- Glue between Model and View\n\n**Example:**\n```javascript\n// User controller\nclass UserController {\n  async getProfile(req, res) {\n    // 1. Get data from model\n    const user = await User.findById(req.params.id);\n    \n    // 2. Send to view\n    res.render('profile', { user });\n  }\n  \n  async updateProfile(req, res) {\n    // 1. Get model\n    const user = await User.findById(req.params.id);\n    \n    // 2. Update\n    user.name = req.body.name;\n    user.save();\n    \n    // 3. Redirect\n    res.redirect('/profile');\n  }\n}\n```\n\n## Data Flow\n\n```\n1. User clicks \"Edit Profile\"\n   ‚Üì\n2. Request goes to CONTROLLER\n   ‚Üì\n3. Controller asks MODEL for data\n   ‚Üì\n4. Model returns user data\n   ‚Üì\n5. Controller passes data to VIEW\n   ‚Üì\n6. View renders HTML\n   ‚Üì\n7. User sees the page\n```\n\n## Why MVC?\n\n**‚úÖ Separation of concerns**\n- UI changes don't affect business logic\n- Database changes don't affect UI\n\n**‚úÖ Reusability**\n- Same model for web and mobile\n- Multiple views for same data\n\n**‚úÖ Testability**\n- Test models independently\n- Test controllers without UI\n\n**‚úÖ Team collaboration**\n- Designer works on views\n- Backend dev works on models\n- No conflicts!\n\n## MVC in Different Frameworks\n\n### Express.js (Manual MVC)\n```\nproject/\n  models/\n    User.js\n  views/\n    profile.ejs\n  controllers/\n    userController.js\n  routes/\n    userRoutes.js\n```\n\n### Django (Built-in MVT)\n```\napp/\n  models.py      # Model\n  views.py       # Controller (yes, confusing!)\n  templates/     # View\n    profile.html\n```\n\nDjango calls it **MVT** (Model-View-Template) but it's the same concept.\n\n### Ruby on Rails (Strict MVC)\n```\napp/\n  models/\n    user.rb\n  views/\n    users/\n      show.html.erb\n  controllers/\n    users_controller.rb\n```\n\n## Modern Variations\n\n### API-Only (No Views)\nModern apps often separate frontend:\n\n```\nBackend (API):\n- Models ‚úÖ\n- Controllers ‚úÖ\n- Views ‚ùå (returns JSON)\n\nFrontend (React/Vue):\n- Handles all views\n```\n\n### MVVM (Model-View-ViewModel)\nUsed in React, Vue, Angular:\n\n- **Model:** Data\n- **View:** React components\n- **ViewModel:** State management (Redux, etc.)\n\n## Common Mistakes\n\n**‚ùå Fat controllers**\n```javascript\n// BAD: Business logic in controller\napp.post('/users', (req, res) => {\n  if (!req.body.email.includes('@')) {\n    return res.error('Invalid email');\n  }\n  // ... lots of logic ...\n});\n```\n\n**‚úÖ Thin controllers**\n```javascript\n// GOOD: Logic in model\napp.post('/users', (req, res) => {\n  const user = new User(req.body);\n  user.save();\n  res.json(user);\n});\n```\n\n**‚ùå Business logic in views**\n```html\n<!-- BAD: Logic in template -->\n<div>\n  {% if user.age >= 18 and user.verified %}\n    <!-- Complex logic here -->\n  {% endif %}\n</div>\n```\n\n**‚úÖ Logic in model**\n```javascript\n// GOOD: Logic in model\nclass User {\n  canAccessContent() {\n    return this.age >= 18 && this.verified;\n  }\n}\n```\n\n## When to Use MVC?\n\n**‚úÖ Good for:**\n- Traditional web applications\n- Server-rendered pages\n- CRUD applications\n- Team collaboration\n\n**‚ö†Ô∏è Might be overkill:**\n- Simple static sites\n- Pure APIs (use simpler structure)\n- Single-page apps (use component architecture)\n\n## Pros & Cons\n\n**Pros:**\n- üèóÔ∏è Clear organization\n- üîÑ Reusable components\n- üß™ Easy to test\n- üë• Good for teams\n- üìö Well-understood pattern\n\n**Cons:**\n- üìà More files/folders\n- ü§î Can be overkill for simple apps\n- üîÄ Sometimes unclear where code goes\n\n## Tips\n\nüìå **Keep controllers thin** - delegate to models\nüìå **No business logic in views** - views only display\nüìå **Models are independent** - shouldn't know about views\nüìå **Use services for complex logic** - between controller and model\nüìå **Follow your framework's conventions**",
      "codeExample": "// Complete MVC example (Express.js)\n\n// models/User.js\nclass User {\n  constructor(data) {\n    this.id = data.id;\n    this.name = data.name;\n    this.email = data.email;\n  }\n  \n  validate() {\n    if (!this.email.includes('@')) {\n      throw new Error('Invalid email');\n    }\n    if (this.name.length < 2) {\n      throw new Error('Name too short');\n    }\n  }\n  \n  async save() {\n    this.validate();\n    // Save to database\n    await database.users.insert(this);\n  }\n  \n  static async findById(id) {\n    const data = await database.users.findOne({ id });\n    return new User(data);\n  }\n  \n  static async findAll() {\n    const data = await database.users.find();\n    return data.map(u => new User(u));\n  }\n}\n\nmodule.exports = User;\n\n// controllers/userController.js\nconst User = require('../models/User');\n\nexports.listUsers = async (req, res) => {\n  const users = await User.findAll();\n  res.render('users/index', { users });\n};\n\nexports.showUser = async (req, res) => {\n  const user = await User.findById(req.params.id);\n  res.render('users/show', { user });\n};\n\nexports.createUser = async (req, res) => {\n  try {\n    const user = new User(req.body);\n    await user.save();\n    res.redirect(`/users/${user.id}`);\n  } catch (error) {\n    res.render('users/new', { error: error.message });\n  }\n};\n\n// routes/userRoutes.js\nconst express = require('express');\nconst userController = require('../controllers/userController');\nconst router = express.Router();\n\nrouter.get('/users', userController.listUsers);\nrouter.get('/users/:id', userController.showUser);\nrouter.post('/users', userController.createUser);\n\nmodule.exports = router;\n\n// views/users/show.ejs\n<!DOCTYPE html>\n<html>\n<head>\n  <title>User Profile</title>\n</head>\n<body>\n  <h1><%= user.name %></h1>\n  <p>Email: <%= user.email %></p>\n  <a href=\"/users/<%= user.id %>/edit\">Edit</a>\n</body>\n</html>\n\n// app.js\nconst express = require('express');\nconst userRoutes = require('./routes/userRoutes');\n\nconst app = express();\napp.set('view engine', 'ejs');\napp.use(express.json());\napp.use(userRoutes);\n\napp.listen(3000);"
    },
    {
      "id": "monolith-vs-microservices",
      "moduleId": "architecture-patterns",
      "title": "Monolith vs Microservices",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Monolith = One codebase, all features together\n- Microservices = Many small services, each doing one thing\n- Monoliths are simpler to start, microservices scale better\n- Most apps should start as monoliths\n\n---\n\n# Monolith vs Microservices\n\n## What is a Monolith?\n\n**Monolith** = Entire application as a single codebase and deployment unit.\n\n**Structure:**\n```\nMyApp/\n  ‚îú‚îÄ‚îÄ auth/\n  ‚îú‚îÄ‚îÄ users/\n  ‚îú‚îÄ‚îÄ products/\n  ‚îú‚îÄ‚îÄ orders/\n  ‚îî‚îÄ‚îÄ payments/\n  \nAll deployed together as ONE application\n```\n\n**Characteristics:**\n- Single codebase\n- One database (usually)\n- Deploy all at once\n- Runs as one process\n\n## What are Microservices?\n\n**Microservices** = Application split into small, independent services.\n\n**Structure:**\n```\nauth-service/       (port 3001)\nuser-service/       (port 3002)\nproduct-service/    (port 3003)\norder-service/      (port 3004)\npayment-service/    (port 3005)\n\nEach is a separate application!\n```\n\n**Characteristics:**\n- Multiple codebases\n- Each has own database\n- Deploy independently\n- Communicate via APIs\n\n## Side-by-Side Comparison\n\n| Aspect | Monolith | Microservices |\n|--------|----------|---------------|\n| Complexity | Simple | Complex |\n| Development | Fast initially | Slower setup |\n| Deployment | All at once | Independent |\n| Scaling | Scale everything | Scale individual parts |\n| Testing | Easier | Harder |\n| Team Size | Small-medium | Large teams |\n| Debugging | Easier | Harder |\n| Technology | One stack | Mix and match |\n| Database | Shared | Per service |\n\n## Monolith: Pros & Cons\n\n**Pros:**\n- ‚úÖ **Simple to develop** - everything in one place\n- ‚úÖ **Easy to deploy** - one deployment\n- ‚úÖ **Easy to test** - run entire app\n- ‚úÖ **No network latency** - direct function calls\n- ‚úÖ **Transactions are easy** - single database\n- ‚úÖ **Better for small teams**\n\n**Cons:**\n- ‚ùå **Scaling is all-or-nothing** - can't scale just one part\n- ‚ùå **Slow builds** as app grows\n- ‚ùå **Technology lock-in** - same stack everywhere\n- ‚ùå **Team conflicts** - everyone in same codebase\n- ‚ùå **Risky deployments** - everything changes at once\n\n## Microservices: Pros & Cons\n\n**Pros:**\n- ‚úÖ **Independent scaling** - scale only what's needed\n- ‚úÖ **Independent deployment** - update one service\n- ‚úÖ **Technology diversity** - use best tool per service\n- ‚úÖ **Team independence** - own services\n- ‚úÖ **Fault isolation** - one service fails, others continue\n- ‚úÖ **Easier to understand** - each service is small\n\n**Cons:**\n- ‚ùå **Complex infrastructure** - need orchestration (Kubernetes)\n- ‚ùå **Network overhead** - services call each other over network\n- ‚ùå **Data consistency** - distributed transactions are hard\n- ‚ùå **Testing is harder** - need to run multiple services\n- ‚ùå **Debugging is harder** - trace across services\n- ‚ùå **More DevOps work** - manage many deployments\n\n## When to Use Each?\n\n### Start with Monolith if:\n- üë• **Small team** (< 10 developers)\n- üöÄ **MVP/prototype** - need to move fast\n- üìä **Unknown requirements** - might pivot\n- üí∞ **Limited resources** - simpler to manage\n- üéØ **Simple domain** - not many distinct areas\n\n### Consider Microservices if:\n- üë• **Large team** (> 20 developers)\n- üìà **Proven product** - know what you're building\n- ‚ö° **Different scaling needs** - some parts need more resources\n- üîß **Different technologies needed** - ML, real-time, etc.\n- üåê **High availability critical** - can't afford downtime\n- üè¢ **Multiple teams** - want independence\n\n## The Migration Path\n\n**Most successful companies:**\n\n```\n1. Start as Monolith\n   ‚Üì\n2. Grow and identify pain points\n   ‚Üì\n3. Extract first service (usually auth or payments)\n   ‚Üì\n4. Gradually extract more services\n   ‚Üì\n5. End up with hybrid (some monolith + services)\n```\n\n**Amazon, Netflix, Uber all started as monoliths!**\n\n## Communication Patterns\n\n### Monolith\n```javascript\n// Direct function call\nfunction createOrder(userId, items) {\n  const user = getUserById(userId);\n  const total = calculateTotal(items);\n  processPayment(user, total);\n  sendConfirmation(user.email);\n}\n```\n\n### Microservices\n```javascript\n// HTTP calls between services\nfunction createOrder(userId, items) {\n  const user = await fetch(`http://user-service/users/${userId}`);\n  const total = await fetch('http://product-service/calculate', { items });\n  await fetch('http://payment-service/charge', { user, total });\n  await fetch('http://email-service/send', { email: user.email });\n}\n```\n\n## Data Management\n\n### Monolith: Shared Database\n```\nApplication\n    ‚Üì\n  Database\n  ‚îú‚îÄ‚îÄ users\n  ‚îú‚îÄ‚îÄ products\n  ‚îî‚îÄ‚îÄ orders\n```\n\n### Microservices: Database per Service\n```\nUser Service ‚Üí User DB\nProduct Service ‚Üí Product DB\nOrder Service ‚Üí Order DB\n```\n\n**Challenge:** How to query across services?\n- Use APIs\n- Event-driven sync\n- Accept eventual consistency\n\n## Hybrid Approach (Best of Both)\n\n**Modular Monolith:**\n- One codebase, clear boundaries\n- Can extract to microservices later\n- Get benefits of both\n\n```\napp/\n  modules/\n    auth/       (could become service)\n    users/      (could become service)\n    products/   (could become service)\n    orders/     (could become service)\n```\n\n## Real-World Examples\n\n**Monoliths (that work fine):**\n- Basecamp\n- GitHub (mostly)\n- Shopify (started as one)\n\n**Microservices:**\n- Netflix (> 500 services)\n- Uber (> 1000 services)\n- Amazon (thousands)\n\n## Common Mistakes\n\n**‚ùå Microservices too early**\n```\nStartup with 3 developers building 10 microservices\n‚Üí Massive overhead, slow development\n```\n\n**‚ùå Too granular services**\n```\nSeparate service for every tiny feature\n‚Üí Network calls everywhere, complexity\n```\n\n**‚ùå Shared database in microservices**\n```\nServices share a database\n‚Üí Defeats the purpose, creates coupling\n```\n\n**‚ùå Never breaking up monolith**\n```\nGrow to millions of lines, hundreds of devs\n‚Üí Deployments take hours, conflicts everywhere\n```\n\n## Decision Framework\n\n**Ask yourself:**\n\n1. **Team size?**\n   - < 10: Monolith\n   - > 20: Consider microservices\n\n2. **Traffic patterns?**\n   - Uniform: Monolith\n   - Spiky in parts: Microservices\n\n3. **Release frequency?**\n   - Weekly: Monolith fine\n   - Multiple daily: Microservices help\n\n4. **DevOps maturity?**\n   - Low: Stick with monolith\n   - High: Can handle microservices\n\n## The Rule of Thumb\n\nüìå **Start with a monolith**\nüìå **Make it modular** (clear boundaries)\nüìå **Extract when you have pain** (not before)\nüìå **Don't cargo-cult Netflix** (they have 1000+ engineers)\nüìå **Remember: monoliths can scale** (Instagram was a monolith for years)",
      "codeExample": "// Example: Monolith vs Microservices\n\n// MONOLITH APPROACH\n// app.js - Everything in one application\nconst express = require('express');\nconst app = express();\n\n// All services in one app\nconst authService = require('./services/auth');\nconst userService = require('./services/users');\nconst orderService = require('./services/orders');\n\napp.post('/orders', async (req, res) => {\n  // Direct function calls (fast, simple)\n  const user = await userService.getUser(req.userId);\n  const order = await orderService.createOrder(req.body);\n  await authService.logActivity(user, 'order_created');\n  \n  res.json(order);\n});\n\napp.listen(3000);\n\n// ---\n\n// MICROSERVICES APPROACH\n// order-service/app.js\nconst express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/orders', async (req, res) => {\n  try {\n    // HTTP calls to other services (slower, more complex)\n    const user = await axios.get(`http://user-service:3001/users/${req.userId}`);\n    const order = await createOrder(req.body);\n    await axios.post('http://auth-service:3002/activity', {\n      userId: user.id,\n      action: 'order_created'\n    });\n    \n    res.json(order);\n  } catch (error) {\n    // Network failures, timeouts, etc.\n    console.error('Service call failed:', error);\n    res.status(500).json({ error: 'Service unavailable' });\n  }\n});\n\napp.listen(3003);\n\n// user-service/app.js (separate application)\nconst express = require('express');\nconst app = express();\n\napp.get('/users/:id', async (req, res) => {\n  const user = await database.users.findById(req.params.id);\n  res.json(user);\n});\n\napp.listen(3001);\n\n// auth-service/app.js (separate application)\nconst express = require('express');\nconst app = express();\n\napp.post('/activity', async (req, res) => {\n  await database.activity.insert(req.body);\n  res.json({ success: true });\n});\n\napp.listen(3002);\n\n// docker-compose.yml (needed for microservices)\nversion: '3'\nservices:\n  user-service:\n    build: ./user-service\n    ports:\n      - \"3001:3001\"\n  \n  auth-service:\n    build: ./auth-service\n    ports:\n      - \"3002:3002\"\n  \n  order-service:\n    build: ./order-service\n    ports:\n      - \"3003:3003\""
    },
    {
      "id": "api-first-development",
      "moduleId": "architecture-patterns",
      "title": "API-First Development",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- API-first = Design API before implementation\n- Backend and frontend develop in parallel\n- API is the contract between teams\n- Enables web, mobile, and third-party integration\n\n---\n\n# API-First: Design Before Code\n\n## What is API-First?\n\n**API-First** means designing your API specification **before** writing any code.\n\nThe API becomes the **contract** that frontend and backend teams agree on.\n\n## Traditional vs API-First\n\n### Traditional Approach\n```\n1. Build backend\n2. Build frontend\n3. Integrate (find issues)\n4. Fix and repeat\n```\n\n### API-First Approach\n```\n1. Design API spec (OpenAPI/Swagger)\n2. Everyone agrees on contract\n3. Backend builds to spec\n4. Frontend builds to spec\n5. Integration works first try!\n```\n\n## Why API-First?\n\n**‚úÖ Parallel development**\n- Frontend and backend work simultaneously\n- No waiting for \"backend to be ready\"\n\n**‚úÖ Clear contract**\n- No ambiguity about data format\n- Fewer integration issues\n\n**‚úÖ Better testing**\n- Mock API from spec\n- Test before code exists\n\n**‚úÖ Documentation**\n- API docs generated from spec\n- Always up to date\n\n**‚úÖ Multiple clients**\n- Web, mobile, desktop use same API\n- Third-party integrations easier\n\n## The API-First Workflow\n\n### Step 1: Design API Spec\n\n**Create OpenAPI specification:**\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: User API\n  version: 1.0.0\n\npaths:\n  /users:\n    get:\n      summary: Get all users\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/User'\n  \n  /users/{id}:\n    get:\n      summary: Get user by ID\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Success\n        '404':\n          description: User not found\n\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n        name:\n          type: string\n        email:\n          type: string\n```\n\n### Step 2: Review & Agree\n\n**Stakeholders review:**\n- Frontend team: \"Can I build UI with this?\"\n- Backend team: \"Can I implement this?\"\n- Product: \"Does this meet requirements?\"\n- Mobile team: \"Works for our app?\"\n\n### Step 3: Generate Code\n\n**Auto-generate:**\n- Server stubs\n- Client SDKs\n- Documentation\n- Mock servers\n\n### Step 4: Implement\n\n**Backend:** Fill in the stubs\n**Frontend:** Use mock server initially\n\n### Step 5: Integrate\n\nFrontend switches from mock to real API - should work!\n\n## Tools for API-First\n\n### Design Tools\n- **Swagger Editor** - Design OpenAPI specs\n- **Stoplight Studio** - Visual API designer\n- **Postman** - Design and test APIs\n- **Insomnia** - API design and testing\n\n### Mock Servers\n- **Prism** - Mock from OpenAPI spec\n- **JSON Server** - Quick mock API\n- **MockServer** - Advanced mocking\n\n### Code Generation\n- **OpenAPI Generator** - Generate servers/clients\n- **Swagger Codegen** - Multi-language support\n\n## API Specification Formats\n\n### OpenAPI (Swagger)\nMost popular, great tooling\n```yaml\nopenapi: 3.0.0\npaths:\n  /users:\n    get:\n      responses:\n        '200':\n          description: Success\n```\n\n### GraphQL Schema\n```graphql\ntype User {\n  id: ID!\n  name: String!\n  email: String!\n}\n\ntype Query {\n  user(id: ID!): User\n  users: [User!]!\n}\n```\n\n### gRPC Protocol Buffers\n```protobuf\nsyntax = \"proto3\";\n\nservice UserService {\n  rpc GetUser (UserRequest) returns (User);\n}\n\nmessage User {\n  int32 id = 1;\n  string name = 2;\n  string email = 3;\n}\n```\n\n## Benefits for Teams\n\n### For Frontend Developers\n‚úÖ Start immediately with mocks\n‚úÖ Know exact data structure\n‚úÖ No \"waiting for backend\"\n‚úÖ Fewer integration surprises\n\n### For Backend Developers\n‚úÖ Clear requirements\n‚úÖ Know what to build\n‚úÖ Auto-generate boilerplate\n‚úÖ Validation built-in\n\n### For Product/Design\n‚úÖ See what's possible\n‚úÖ Provide feedback early\n‚úÖ Understand data model\n\n### For QA/Testing\n‚úÖ Test contracts\n‚úÖ Validate responses\n‚úÖ Automated testing\n\n## Example: Real-World Flow\n\n**Week 1: Design**\n- Product defines requirements\n- Teams design API spec together\n- Review and finalize\n\n**Week 2-3: Development**\n- Backend implements endpoints\n- Frontend builds UI with mocks\n- Mobile team builds with mocks\n\n**Week 4: Integration**\n- Switch from mocks to real API\n- Run integration tests\n- Fix any issues\n\n**Week 5: Launch**\n- Deploy to production\n- Monitor API usage\n\n## Best Practices\n\n**üìå Version your API**\n```\n/v1/users\n/v2/users\n```\n\n**üìå Use consistent naming**\n```\nGET  /users       (not /getUsers)\nPOST /users       (not /createUser)\nGET  /users/123   (not /user?id=123)\n```\n\n**üìå Return proper status codes**\n```\n200 - Success\n201 - Created\n400 - Bad request\n404 - Not found\n500 - Server error\n```\n\n**üìå Include examples in spec**\nHelps everyone understand the data\n\n**üìå Keep spec in version control**\nTrack changes over time\n\n## When to Use API-First?\n\n**‚úÖ Great for:**\n- Multiple clients (web, mobile, desktop)\n- Large teams\n- Third-party integrations\n- Microservices\n- Long-term projects\n\n**‚ö†Ô∏è Might be overkill:**\n- Solo projects\n- Simple CRUD apps\n- Rapid prototypes\n- Internal tools\n\n## Pros & Cons\n\n**Pros:**\n- üöÄ Parallel development\n- üìù Clear documentation\n- üß™ Easy to test\n- üîÑ Reusable across platforms\n- üë• Better team collaboration\n\n**Cons:**\n- ‚è±Ô∏è Upfront design time\n- üîß Learning curve for specs\n- üìä Overhead for simple projects\n- üîÑ Changes require spec updates\n\n## Tips\n\nüìå Involve all stakeholders in API design\nüìå Start simple, iterate\nüìå Use real examples in specs\nüìå Keep API consistent (naming, structure)\nüìå Update spec when API changes\nüìå Use API versioning for breaking changes",
      "codeExample": "// API-First Example: OpenAPI Spec\n\n// api-spec.yaml\nopenapi: 3.0.0\ninfo:\n  title: Todo API\n  description: A simple todo list API\n  version: 1.0.0\n\npaths:\n  /todos:\n    get:\n      summary: List all todos\n      parameters:\n        - name: completed\n          in: query\n          schema:\n            type: boolean\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Todo'\n              example:\n                - id: 1\n                  title: \"Buy groceries\"\n                  completed: false\n                - id: 2\n                  title: \"Write docs\"\n                  completed: true\n    \n    post:\n      summary: Create a todo\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/TodoCreate'\n            example:\n              title: \"New task\"\n              completed: false\n      responses:\n        '201':\n          description: Created\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Todo'\n        '400':\n          description: Invalid input\n\n  /todos/{id}:\n    get:\n      summary: Get a todo\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Success\n        '404':\n          description: Not found\n    \n    delete:\n      summary: Delete a todo\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      responses:\n        '204':\n          description: Deleted\n        '404':\n          description: Not found\n\ncomponents:\n  schemas:\n    Todo:\n      type: object\n      required:\n        - id\n        - title\n        - completed\n      properties:\n        id:\n          type: integer\n          description: Unique identifier\n        title:\n          type: string\n          description: Todo description\n        completed:\n          type: boolean\n          description: Completion status\n        createdAt:\n          type: string\n          format: date-time\n    \n    TodoCreate:\n      type: object\n      required:\n        - title\n      properties:\n        title:\n          type: string\n          minLength: 1\n          maxLength: 200\n        completed:\n          type: boolean\n          default: false\n\n// Now frontend can use mock server:\n// npx @stoplight/prism-cli mock api-spec.yaml\n\n// Frontend code (works with mock, then real API)\nconst API_URL = process.env.API_URL || 'http://localhost:4010';\n\nasync function getTodos() {\n  const response = await fetch(`${API_URL}/todos`);\n  return response.json();\n}\n\nasync function createTodo(title) {\n  const response = await fetch(`${API_URL}/todos`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ title })\n  });\n  return response.json();\n}"
    },
    {
      "id": "serverless-architecture",
      "moduleId": "architecture-patterns",
      "title": "Serverless Architecture",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Serverless = You write functions, cloud runs them\n- No server management (cloud handles scaling, updates)\n- Pay only for execution time (not idle servers)\n- Great for event-driven and variable workloads\n\n---\n\n# Serverless: No Servers to Manage\n\n## What is Serverless?\n\n**Serverless** doesn't mean \"no servers\" - it means **you don't manage servers**.\n\nYou write **functions**, cloud provider handles everything else.\n\n## Traditional vs Serverless\n\n### Traditional Server\n```\n1. Rent server (runs 24/7)\n2. Install OS, Node.js\n3. Deploy your app\n4. Configure scaling\n5. Handle updates, security\n6. Pay for server even when idle\n```\n\n### Serverless\n```\n1. Write a function\n2. Deploy to cloud\n3. Cloud runs it when triggered\n4. Auto-scales automatically\n5. Pay only for executions\n```\n\n## How It Works\n\n**Example: AWS Lambda**\n```javascript\n// Your function\nexports.handler = async (event) => {\n  const name = event.name || 'World';\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ message: `Hello ${name}!` })\n  };\n};\n\n// Cloud handles:\n// - Running the function\n// - Scaling (1 to 10,000 concurrent executions)\n// - Load balancing\n// - Logging\n// - Security updates\n```\n\n## Serverless Platforms\n\n### AWS Lambda\nMost mature, huge ecosystem\n```javascript\nexports.handler = async (event) => {\n  // Your code\n};\n```\n\n### Vercel/Netlify Functions\nEasiest for web developers\n```javascript\nexport default async (req, res) => {\n  res.json({ message: 'Hello!' });\n};\n```\n\n### Google Cloud Functions\n```javascript\nexports.helloWorld = (req, res) => {\n  res.send('Hello!');\n};\n```\n\n### Azure Functions\n```javascript\nmodule.exports = async function (context, req) {\n  context.res = { body: 'Hello!' };\n};\n```\n\n## Use Cases\n\n### 1. API Endpoints\n```javascript\n// GET /users/:id\nexport default async (req, res) => {\n  const user = await db.users.findById(req.query.id);\n  res.json(user);\n};\n```\n\n### 2. Image Processing\n```javascript\n// Trigger: New image uploaded to S3\nexports.handler = async (event) => {\n  const image = event.Records[0].s3.object.key;\n  await resizeImage(image);\n  await createThumbnail(image);\n};\n```\n\n### 3. Scheduled Tasks\n```javascript\n// Run every day at midnight\nexports.handler = async () => {\n  await sendDailyReport();\n  await cleanupOldData();\n};\n```\n\n### 4. Webhooks\n```javascript\n// Stripe payment webhook\nexports.handler = async (event) => {\n  const payment = JSON.parse(event.body);\n  await processPayment(payment);\n};\n```\n\n### 5. Event Processing\n```javascript\n// Process messages from queue\nexports.handler = async (event) => {\n  for (const record of event.Records) {\n    await processMessage(record.body);\n  }\n};\n```\n\n## Serverless Architecture Example\n\n```\nUser Request\n    ‚Üì\nAPI Gateway ‚Üí Lambda (auth)\n    ‚Üì\nLambda (business logic)\n    ‚Üì\nDynamoDB (database)\n    ‚Üì\nS3 (file storage)\n    ‚Üì\nSNS (notifications)\n```\n\n## Pricing Model\n\n**Traditional Server:**\n```\n$50/month for server\n(whether you get 10 or 10,000 requests)\n```\n\n**Serverless:**\n```\n$0.20 per 1 million requests\n+ $0.00001667 per GB-second of compute\n\n= Pay only for what you use!\n```\n\n**Example:**\n- 100,000 requests/month\n- 100ms execution time each\n- Cost: ~$0.20/month\n\n**Free tier (AWS Lambda):**\n- 1 million requests/month\n- 400,000 GB-seconds compute\n\n## Pros & Cons\n\n**Pros:**\n- ‚úÖ **No server management** - focus on code\n- ‚úÖ **Auto-scaling** - handles any load\n- ‚úÖ **Pay per use** - cost-effective for variable load\n- ‚úÖ **Fast deployment** - just upload code\n- ‚úÖ **High availability** - built-in\n- ‚úÖ **No idle costs** - pay only for executions\n\n**Cons:**\n- ‚ùå **Cold starts** - first request can be slow\n- ‚ùå **Timeouts** - limited execution time (15 min max)\n- ‚ùå **Vendor lock-in** - platform-specific\n- ‚ùå **Debugging harder** - distributed system\n- ‚ùå **Limited control** - can't customize environment\n- ‚ùå **Cost at scale** - can be expensive with constant traffic\n\n## Cold Starts Explained\n\n**Problem:**\nFirst request is slow (100-1000ms)\n\n**Why:**\nCloud needs to start container for your function\n\n**Solutions:**\n- Keep functions warm (ping periodically)\n- Use provisioned concurrency (AWS)\n- Accept trade-off for cost savings\n\n## When to Use Serverless?\n\n**‚úÖ Perfect for:**\n- Variable/unpredictable traffic\n- Event-driven workloads\n- Microservices\n- Scheduled tasks\n- Webhooks/integrations\n- Low to medium traffic sites\n\n**‚ùå Not ideal for:**\n- Constant high traffic (servers cheaper)\n- Long-running tasks (> 15 min)\n- Stateful applications\n- When you need full control\n- WebSocket connections (limited)\n\n## Serverless Frameworks\n\n### Serverless Framework\n```yaml\nservice: my-service\n\nfunctions:\n  hello:\n    handler: handler.hello\n    events:\n      - http:\n          path: hello\n          method: get\n```\n\n### AWS SAM\n```yaml\nResources:\n  HelloFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      Handler: index.handler\n      Runtime: nodejs18.x\n      Events:\n        Api:\n          Type: Api\n          Properties:\n            Path: /hello\n            Method: get\n```\n\n## Real-World Examples\n\n**Companies using serverless:**\n- Netflix (video encoding)\n- Coca-Cola (vending machine data)\n- iRobot (Roomba data processing)\n- Nordstrom (retail systems)\n\n## Best Practices\n\n**üìå Keep functions small and focused**\nOne function, one purpose\n\n**üìå Optimize for cold starts**\nMinimize dependencies, lazy load\n\n**üìå Use environment variables**\nDon't hardcode config\n\n**üìå Implement proper logging**\nCloudWatch or similar\n\n**üìå Set memory appropriately**\nMore memory = faster, but costs more\n\n**üìå Handle errors gracefully**\nRetry logic, dead letter queues\n\n## Serverless + Traditional\n\n**You can mix!**\n\n```\nMain app: Traditional server\nImage processing: Serverless\nScheduled tasks: Serverless\nWebhooks: Serverless\n```\n\nUse best tool for each job!\n\n## The Future\n\n**Edge Functions:**\nRun serverless at CDN edge (even faster)\n\n**Example: Vercel Edge Functions**\n```javascript\nexport const config = { runtime: 'edge' };\n\nexport default async (req) => {\n  return new Response('Hello from the edge!');\n};\n```\n\nRuns in 300+ locations worldwide!",
      "codeExample": "// Serverless Examples\n\n// 1. AWS Lambda - API Endpoint\nexports.handler = async (event) => {\n  const { httpMethod, path, body } = event;\n  \n  // Parse request\n  const data = JSON.parse(body || '{}');\n  \n  // Handle different routes\n  if (httpMethod === 'GET' && path === '/users') {\n    const users = await db.users.findAll();\n    return {\n      statusCode: 200,\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(users)\n    };\n  }\n  \n  if (httpMethod === 'POST' && path === '/users') {\n    const user = await db.users.create(data);\n    return {\n      statusCode: 201,\n      body: JSON.stringify(user)\n    };\n  }\n  \n  return {\n    statusCode: 404,\n    body: JSON.stringify({ error: 'Not found' })\n  };\n};\n\n// 2. Vercel Serverless Function\n// pages/api/hello.js\nexport default async function handler(req, res) {\n  if (req.method === 'GET') {\n    res.status(200).json({ message: 'Hello!' });\n  } else {\n    res.status(405).json({ error: 'Method not allowed' });\n  }\n}\n\n// 3. Image Processing (S3 Trigger)\nexports.handler = async (event) => {\n  const bucket = event.Records[0].s3.bucket.name;\n  const key = event.Records[0].s3.object.key;\n  \n  // Download image from S3\n  const image = await s3.getObject({ Bucket: bucket, Key: key }).promise();\n  \n  // Resize\n  const resized = await sharp(image.Body)\n    .resize(800, 600)\n    .toBuffer();\n  \n  // Upload thumbnail\n  await s3.putObject({\n    Bucket: bucket,\n    Key: `thumbnails/${key}`,\n    Body: resized\n  }).promise();\n  \n  console.log(`Processed ${key}`);\n};\n\n// 4. Scheduled Task (Cron)\nexports.handler = async () => {\n  // Runs every day at 9 AM\n  const users = await db.users.findInactive();\n  \n  for (const user of users) {\n    await sendEmail(user.email, 'We miss you!');\n  }\n  \n  return {\n    statusCode: 200,\n    body: `Sent ${users.length} emails`\n  };\n};\n\n// 5. Webhook Handler\nexports.handler = async (event) => {\n  const signature = event.headers['stripe-signature'];\n  \n  // Verify webhook\n  const payload = JSON.parse(event.body);\n  const valid = verifySignature(payload, signature);\n  \n  if (!valid) {\n    return { statusCode: 401, body: 'Invalid signature' };\n  }\n  \n  // Process payment\n  if (payload.type === 'payment_intent.succeeded') {\n    await processPayment(payload.data.object);\n  }\n  \n  return { statusCode: 200, body: 'OK' };\n};"
    },
    {
      "id": "jamstack",
      "moduleId": "architecture-patterns",
      "title": "JAMstack Architecture",
      "order": 5,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- JAMstack = JavaScript, APIs, Markup (pre-built static sites)\n- Deploy to CDN for blazing fast performance\n- Decouple frontend from backend\n- Great for content sites, blogs, marketing pages\n\n---\n\n# JAMstack: Modern Web Architecture\n\n## What is JAMstack?\n\n**JAMstack** stands for:\n- **J**avaScript (dynamic functionality)\n- **A**PIs (server-side operations)\n- **M**arkup (pre-built HTML)\n\n**Core idea:** Build site at build time, serve static files from CDN.\n\n## Traditional vs JAMstack\n\n### Traditional (Server-Side)\n```\nUser requests page\n    ‚Üì\nServer processes request\n    ‚Üì\nQuery database\n    ‚Üì\nRender HTML\n    ‚Üì\nReturn to user\n\n(Happens every single request)\n```\n\n### JAMstack\n```\nBuild time:\n  Fetch data ‚Üí Generate HTML ‚Üí Deploy to CDN\n\nRequest time:\n  User requests page ‚Üí CDN serves HTML (instant!)\n  \n(HTML already built, just serve it)\n```\n\n## JAMstack Architecture\n\n```\nBuild:\n  Content (Markdown, CMS) ‚Üí Static Site Generator ‚Üí HTML/CSS/JS\n\nDeploy:\n  HTML/CSS/JS ‚Üí CDN (Cloudflare, Netlify, Vercel)\n\nRuntime:\n  User ‚Üí CDN (static files)\n  Dynamic features ‚Üí APIs (serverless functions)\n```\n\n## Key Principles\n\n### 1. Pre-rendering\n**Build HTML at build time, not request time**\n\n```bash\n# Build step\nnpm run build\n‚Üí Generates static HTML for all pages\n\n# Deploy\nUpload to CDN\n```\n\n### 2. CDN Distribution\n**Serve from edge locations worldwide**\n\n```\nUser in Tokyo ‚Üí CDN server in Tokyo (fast!)\nUser in London ‚Üí CDN server in London (fast!)\n```\n\n### 3. API-Driven\n**Dynamic features via APIs**\n\n```javascript\n// Static HTML + Dynamic data\nconst posts = await fetch('/api/posts');\n```\n\n## JAMstack Tools\n\n### Static Site Generators\n\n**Next.js (React):**\n```javascript\n// pages/index.js\nexport async function getStaticProps() {\n  const posts = await getPosts();\n  return { props: { posts } };\n}\n\nexport default function Home({ posts }) {\n  return <div>{/* Render posts */}</div>;\n}\n```\n\n**Gatsby (React):**\n```javascript\n// Uses GraphQL at build time\nexport const query = graphql`\n  query {\n    allMarkdownRemark {\n      edges {\n        node { frontmatter { title } }\n      }\n    }\n  }\n`;\n```\n\n**Astro (Multi-framework):**\n```astro\n---\nconst posts = await fetch('/api/posts').then(r => r.json());\n---\n<ul>\n  {posts.map(post => <li>{post.title}</li>)}\n</ul>\n```\n\n**Hugo (Go):**\nFastest build times\n\n**11ty (Eleventy):**\nSimple, flexible\n\n### Headless CMS\n\n**Contentful, Sanity, Strapi:**\nManage content, expose via API\n\n```javascript\n// Build time: Fetch from CMS\nconst content = await contentful.getEntries();\n\n// Generate static pages\ncontent.items.forEach(item => {\n  generatePage(item);\n});\n```\n\n### Hosting Platforms\n\n- **Vercel** - Best for Next.js\n- **Netlify** - Great all-around\n- **Cloudflare Pages** - Fast, free\n- **GitHub Pages** - Simple, free\n\n## Example: Blog Architecture\n\n**Build Process:**\n```\n1. Write blog post (Markdown)\n2. Run build: npm run build\n3. Generator fetches posts\n4. Generates HTML for each post\n5. Deploy to Netlify\n6. Cached on CDN worldwide\n```\n\n**User Experience:**\n```\nUser visits yoursite.com/blog/my-post\n‚Üí CDN serves pre-built HTML (instant!)\n‚Üí Comments loaded via API (dynamic)\n```\n\n## Dynamic Features\n\n**How to add interactivity?**\n\n### Client-Side JavaScript\n```javascript\n// Static page + dynamic data\nconst comments = await fetch('/api/comments?post=123');\n```\n\n### Serverless Functions\n```javascript\n// pages/api/submit-form.js\nexport default async (req, res) => {\n  await saveToDatabase(req.body);\n  res.json({ success: true });\n};\n```\n\n### Third-Party Services\n- Comments: Disqus, Utterances\n- Forms: Formspree, Netlify Forms\n- Search: Algolia\n- Auth: Auth0, Supabase\n- Payments: Stripe\n\n## Use Cases\n\n**‚úÖ Perfect for:**\n- Blogs\n- Marketing sites\n- Documentation\n- Portfolios\n- Landing pages\n- E-commerce (with APIs)\n\n**‚ùå Not ideal for:**\n- Highly dynamic apps (social networks)\n- Real-time collaborative tools\n- Personalized content for millions\n- Frequent updates (thousands/day)\n\n## Benefits\n\n**‚ö° Performance:**\n- Pre-built HTML = instant load\n- CDN = served from nearest location\n- No server processing per request\n\n**üîí Security:**\n- No servers to hack\n- No databases exposed\n- Static files = small attack surface\n\n**üí∞ Cost:**\n- Cheap hosting (or free)\n- No servers to maintain\n- Scale for free with CDN\n\n**üìà Scalability:**\n- Handle traffic spikes easily\n- CDN scales automatically\n- No database bottlenecks\n\n**üë®‚Äçüíª Developer Experience:**\n- Simple deployment\n- Git-based workflow\n- Preview deployments\n- Easy rollbacks\n\n## Incremental Static Regeneration (ISR)\n\n**Problem:** Re-build entire site for one change?\n\n**Solution:** Re-generate only changed pages\n\n```javascript\n// Next.js ISR\nexport async function getStaticProps() {\n  const data = await fetchData();\n  \n  return {\n    props: { data },\n    revalidate: 60 // Re-generate after 60 seconds\n  };\n}\n```\n\n**Benefits:**\n- Best of both worlds\n- Static performance\n- Fresh content\n\n## Deployment Workflow\n\n```bash\n# 1. Make changes locally\ngit add .\ngit commit -m \"New blog post\"\n\n# 2. Push to GitHub\ngit push\n\n# 3. Auto-deploy (Vercel/Netlify)\n‚Üí Build triggered\n‚Üí Site generated\n‚Üí Deployed to CDN\n‚Üí Live in seconds!\n```\n\n**Features:**\n- Preview deployments for PRs\n- Automatic HTTPS\n- Git-based workflow\n- Easy rollbacks\n\n## Hybrid Approaches\n\n**Mix static + dynamic:**\n\n```javascript\n// Next.js\nexport async function getStaticProps() {\n  // Static at build time\n  return { props: { post } };\n}\n\n// Client-side dynamic\nfunction Post({ post }) {\n  const [comments, setComments] = useState([]);\n  \n  useEffect(() => {\n    fetch('/api/comments').then(setComments);\n  }, []);\n  \n  return (\n    <>\n      <article>{post.content}</article>\n      <Comments data={comments} />\n    </>\n  );\n}\n```\n\n## Real-World Examples\n\n**JAMstack sites:**\n- Smashing Magazine\n- React docs\n- Vue docs\n- FreeCodeCamp\n- Many corporate sites\n\n## Best Practices\n\nüìå **Use a CDN** - Core of JAMstack\nüìå **Atomic deploys** - All or nothing\nüìå **Immutable deploys** - Don't modify live files\nüìå **Cache invalidation** - Clear CDN cache on deploy\nüìå **Preview branches** - Test before production\nüìå **Environment variables** - Manage configs\n\n## JAMstack vs Traditional\n\n| Aspect | Traditional | JAMstack |\n|--------|-------------|----------|\n| Speed | Slow | Fast |\n| Scaling | Complex | Easy |\n| Cost | Higher | Lower |\n| Security | More surface | Less surface |\n| Hosting | Server needed | CDN only |\n| Build Time | None | Required |\n| Updates | Instant | Rebuild needed |\n\n## The Bottom Line\n\n**JAMstack is great when:**\n- Content doesn't change every second\n- Performance is critical\n- Want simple deployment\n- Need to scale easily\n\n**Not when:**\n- Highly personalized content\n- Real-time collaboration\n- Can't afford build times",
      "codeExample": "// JAMstack Example: Blog with Next.js\n\n// pages/index.js\nexport async function getStaticProps() {\n  // Runs at BUILD time (not request time)\n  const posts = await fetch('https://api.example.com/posts')\n    .then(r => r.json());\n  \n  return {\n    props: { posts },\n    revalidate: 3600 // ISR: Regenerate every hour\n  };\n}\n\nexport default function Home({ posts }) {\n  return (\n    <div>\n      <h1>My Blog</h1>\n      {posts.map(post => (\n        <article key={post.id}>\n          <h2>{post.title}</h2>\n          <p>{post.excerpt}</p>\n        </article>\n      ))}\n    </div>\n  );\n}\n\n// pages/blog/[slug].js\nexport async function getStaticPaths() {\n  // Tell Next.js which pages to pre-build\n  const posts = await fetch('https://api.example.com/posts')\n    .then(r => r.json());\n  \n  const paths = posts.map(post => ({\n    params: { slug: post.slug }\n  }));\n  \n  return { paths, fallback: 'blocking' };\n}\n\nexport async function getStaticProps({ params }) {\n  const post = await fetch(`https://api.example.com/posts/${params.slug}`)\n    .then(r => r.json());\n  \n  return { props: { post } };\n}\n\nexport default function BlogPost({ post }) {\n  const [comments, setComments] = useState([]);\n  \n  // Dynamic comments (client-side)\n  useEffect(() => {\n    fetch(`/api/comments?post=${post.id}`)\n      .then(r => r.json())\n      .then(setComments);\n  }, [post.id]);\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n      \n      <section>\n        <h2>Comments</h2>\n        {comments.map(c => (\n          <div key={c.id}>{c.text}</div>\n        ))}\n      </section>\n    </article>\n  );\n}\n\n// pages/api/comments.js (Serverless function)\nexport default async function handler(req, res) {\n  const postId = req.query.post;\n  const comments = await database.comments.find({ postId });\n  res.json(comments);\n}\n\n// Deploy:\n// 1. git push\n// 2. Vercel auto-builds and deploys\n// 3. Site live on CDN worldwide!"
    }
  ],
  "exercises": [
    {
      "id": "arch-ex-1",
      "lessonId": "mvc-pattern",
      "moduleId": "architecture-patterns",
      "title": "Understanding MVC",
      "difficulty": "medium",
      "description": "Test your MVC pattern knowledge.",
      "type": "quiz",
      "questions": [
        {
          "question": "Where should database queries go in MVC?",
          "options": ["View", "Controller", "Model", "Anywhere"],
          "correctAnswer": 2,
          "explanation": "Database operations belong in the Model, which handles data and business logic."
        },
        {
          "question": "What is the Controller's main responsibility?",
          "options": ["Display HTML", "Store data", "Handle requests and coordinate Model/View", "Validate input"],
          "correctAnswer": 2,
          "explanation": "Controllers handle requests and coordinate between Models (data) and Views (presentation)."
        },
        {
          "question": "Should business logic go in the View?",
          "options": ["Yes, always", "No, Views should only display data", "Only simple logic", "Depends on the framework"],
          "correctAnswer": 1,
          "explanation": "Views should only handle presentation. Business logic belongs in Models or Services."
        },
        {
          "question": "What's a 'fat controller' anti-pattern?",
          "options": ["Controller that handles many routes", "Controller with too much business logic", "Large controller file", "Controller with many parameters"],
          "correctAnswer": 1,
          "explanation": "Fat controllers have too much business logic. Logic should be in Models to keep controllers thin."
        }
      ]
    },
    {
      "id": "arch-ex-2",
      "lessonId": "monolith-vs-microservices",
      "moduleId": "architecture-patterns",
      "title": "Monolith vs Microservices Decisions",
      "difficulty": "hard",
      "description": "Choose the right architecture for different scenarios.",
      "type": "quiz",
      "questions": [
        {
          "question": "A startup with 3 developers building an MVP. Which architecture?",
          "options": ["Microservices", "Monolith", "Serverless", "Hybrid"],
          "correctAnswer": 1,
          "explanation": "Startups should start with a monolith - simpler, faster to develop, easier to change when pivoting."
        },
        {
          "question": "A company with 50+ developers and different teams owning features. Which architecture?",
          "options": ["Monolith", "Microservices", "JAMstack", "Serverless only"],
          "correctAnswer": 1,
          "explanation": "Large teams benefit from microservices - allows team independence and separate deployments."
        },
        {
          "question": "What's the main drawback of microservices?",
          "options": ["Slower performance", "Can't scale", "Increased complexity", "Higher development speed"],
          "correctAnswer": 2,
          "explanation": "Microservices add significant complexity - distributed systems, network calls, data consistency, etc."
        },
        {
          "question": "How should most companies start?",
          "options": ["Microservices from day 1", "Monolith, then migrate if needed", "Serverless only", "Build both in parallel"],
          "correctAnswer": 1,
          "explanation": "Start with a modular monolith, then extract services when you have proven pain points."
        },
        {
          "question": "Can you have a shared database in microservices?",
          "options": ["Yes, recommended", "No, defeats the purpose", "Only for read-only data", "Yes, but only during migration"],
          "correctAnswer": 1,
          "explanation": "Shared databases create coupling and defeat the purpose of independent microservices."
        }
      ]
    },
    {
      "id": "arch-ex-3",
      "lessonId": "api-first-development",
      "moduleId": "architecture-patterns",
      "title": "API-First Approach",
      "difficulty": "medium",
      "description": "Understanding API-first development.",
      "type": "quiz",
      "questions": [
        {
          "question": "What do you design first in API-first development?",
          "options": ["Database schema", "API specification", "Frontend UI", "Backend code"],
          "correctAnswer": 1,
          "explanation": "API-first means designing the API specification before writing any implementation code."
        },
        {
          "question": "Main benefit of API-first for teams?",
          "options": ["Faster backend", "Better UI", "Frontend and backend can work in parallel", "Smaller code"],
          "correctAnswer": 2,
          "explanation": "With an agreed API spec, frontend and backend teams can develop simultaneously using mocks."
        },
        {
          "question": "What format is commonly used for API specifications?",
          "options": ["JSON", "XML", "OpenAPI/Swagger", "YAML only"],
          "correctAnswer": 2,
          "explanation": "OpenAPI (formerly Swagger) is the industry standard for API specifications."
        },
        {
          "question": "How does frontend develop before backend is ready?",
          "options": ["Wait for backend", "Use mock servers from API spec", "Build without data", "Guess the API"],
          "correctAnswer": 1,
          "explanation": "Mock servers can be generated from the API spec, allowing frontend to develop independently."
        }
      ]
    },
    {
      "id": "arch-ex-4",
      "lessonId": "serverless-architecture",
      "moduleId": "architecture-patterns",
      "title": "Serverless Use Cases",
      "difficulty": "medium",
      "description": "Identify when serverless makes sense.",
      "type": "quiz",
      "questions": [
        {
          "question": "What is a 'cold start' in serverless?",
          "options": ["Server reboot", "First request delay while function loads", "Function error", "Database connection issue"],
          "correctAnswer": 1,
          "explanation": "Cold start is the delay when a function hasn't been used recently and needs to be initialized."
        },
        {
          "question": "When is serverless most cost-effective?",
          "options": ["Constant high traffic", "Variable/unpredictable traffic", "Real-time apps", "Database-heavy apps"],
          "correctAnswer": 1,
          "explanation": "Serverless is cheapest for variable traffic since you only pay for actual executions, not idle time."
        },
        {
          "question": "What's the typical maximum execution time for serverless functions?",
          "options": ["No limit", "5 minutes", "15 minutes", "1 hour"],
          "correctAnswer": 2,
          "explanation": "Most serverless platforms limit execution time (AWS Lambda max is 15 minutes)."
        },
        {
          "question": "Best use case for serverless?",
          "options": ["WebSocket server", "Image processing on upload", "Database server", "Game server"],
          "correctAnswer": 1,
          "explanation": "Event-driven tasks like image processing are perfect - triggered by upload, process, then done."
        },
        {
          "question": "When should you avoid serverless?",
          "options": ["Variable traffic", "Event-driven tasks", "Constant high traffic (cheaper with servers)", "API endpoints"],
          "correctAnswer": 2,
          "explanation": "With constant high traffic, traditional servers are often cheaper than per-request serverless pricing."
        }
      ]
    },
    {
      "id": "arch-ex-5",
      "lessonId": "jamstack",
      "moduleId": "architecture-patterns",
      "title": "Static Site Generation with JAMstack",
      "difficulty": "medium",
      "description": "Understanding JAMstack benefits and use cases.",
      "type": "quiz",
      "questions": [
        {
          "question": "What does JAM stand for in JAMstack?",
          "options": ["Java, API, MySQL", "JavaScript, APIs, Markup", "JSON, Admin, Microservices", "Just Amazing Marketing"],
          "correctAnswer": 1,
          "explanation": "JAMstack = JavaScript, APIs, and Markup (pre-rendered static files)."
        },
        {
          "question": "When are JAMstack pages built?",
          "options": ["On every request", "At build time (before deployment)", "When user visits", "Randomly"],
          "correctAnswer": 1,
          "explanation": "JAMstack pre-builds pages at build time, then serves static HTML from CDN."
        },
        {
          "question": "Main performance benefit of JAMstack?",
          "options": ["Faster database", "Pre-built HTML served from CDN", "Better JavaScript", "More servers"],
          "correctAnswer": 1,
          "explanation": "Pre-built static files served from CDN edge locations = instant page loads."
        },
        {
          "question": "Best use case for JAMstack?",
          "options": ["Social media platform", "Real-time chat", "Blog or marketing site", "Video editing app"],
          "correctAnswer": 2,
          "explanation": "JAMstack excels at content-focused sites (blogs, docs, marketing) where content doesn't change every second."
        },
        {
          "question": "How do you add dynamic features to JAMstack sites?",
          "options": ["Can't have dynamic features", "Client-side JavaScript + APIs", "Server-side rendering", "WebSockets only"],
          "correctAnswer": 1,
          "explanation": "Static HTML + client-side JavaScript calling APIs for dynamic data (comments, forms, etc.)."
        }
      ]
    }
  ]
}
