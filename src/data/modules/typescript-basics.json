{
  "module": {
    "id": "typescript-basics",
    "title": "TypeScript: The Fundamentals",
    "description": "Introduction to TypeScript: types, interfaces, generics and configuration",
    "icon": "Code",
    "requiredXp": 300,
    "color": "from-blue-500 to-indigo-600",
    "courseId": "javascript-core"
  },
  "lessons": [
    {
      "id": "typescript-why",
      "moduleId": "typescript-basics",
      "title": "Why TypeScript?",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- TypeScript is a typed superset of JavaScript\n- Catches errors at compile time, not runtime\n- Provides powerful IDE autocomplete and intellisense\n- Compiles to standard JavaScript that runs anywhere\n- Makes refactoring safer and easier\n\n---\n\n# Why Use TypeScript?\n\n## The Problem with JavaScript\n\nJavaScript is dynamically typed, which means bugs often only surface at runtime:\n\n```javascript\n// JavaScript - this compiles fine but fails at runtime\nfunction calculateTotal(price, quantity) {\n  return price + quantity;  // Oops! Should be price * quantity\n}\n\nconst result = calculateTotal('10', 5);  // No error here!\nconsole.log(result);  // \"105\" - string concatenation!\n```\n\n## TypeScript to the Rescue\n\n```typescript\n// TypeScript - catches errors before running\nfunction calculateTotal(price: number, quantity: number): number {\n  return price + quantity;  // Wait... IDE shows this is wrong!\n}\n\n// Error: Argument of type 'string' is not assignable to parameter of type 'number'\nconst result = calculateTotal('10', 5);\n```\n\n## Key Benefits\n\n### 1. Type Safety\nTypeScript enforces types at compile time, preventing entire categories of bugs:\n\n```typescript\n// TypeScript catches typos\nconst user = { name: 'John', age: 30 };\nconsole.log(user.nam);  // Error: Property 'nam' does not exist on type...\n\n// TypeScript catches undefined access\nconst users = ['Alice', 'Bob'];\nconsole.log(users[10].toUpperCase());  // Error: Object is possibly 'undefined'\n```\n\n### 2. Intelligent Autocomplete\n\n```typescript\ninterface User {\n  name: string;\n  email: string;\n  age: number;\n}\n\nconst user: User = {\n  name: 'John',\n  email: 'john@example.com',\n  age: 30\n};\n\n// TypeScript knows all properties of User\nuser.  // IDE shows: name, email, age, methods...\n```\n\n### 3. Self-Documenting Code\n\n```typescript\n// Clear intent - no need for comments\ninterface APIResponse {\n  status: number;\n  data: User[];\n  error?: string;\n}\n\nasync function fetchUsers(): Promise<APIResponse> {\n  // Return type is clear from the signature\n}\n```\n\n### 4. Safe Refactoring\n\n```typescript\n// Rename a property across your entire codebase\ninterface User {\n  fullName: string;  // Changed from 'name'\n  email: string;\n}\n\n// TypeScript highlights every place that needs updating\n```\n\n## How TypeScript Works\n\nTypeScript is a **compile-time** tool. It does not run in the browser - it compiles to JavaScript:\n\n```typescript\n// TypeScript code\ninterface Point {\n  x: number;\n  y: number;\n}\n\nconst p: Point = { x: 10, y: 20 };\nconsole.log(p.x);\n```\n\n```javascript\n// Compiled JavaScript (types are removed!)\nconst p = { x: 10, y: 20 };\nconsole.log(p.x);\n```\n\nThis means:\n- Zero runtime overhead\n- Can gradually adopt in existing projects\n- Can use any JavaScript library\n\n## Installing TypeScript\n\n```bash\n# Global installation\nnpm install -g typescript\n\n# Project installation (recommended)\nnpm install --save-dev typescript\n\n# Check version\nnpx tsc --version\n```\n\n## Your First TypeScript File\n\n```typescript\n// hello.ts\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n\nconst message: string = greet('TypeScript');\nconsole.log(message);\n```\n\nCompile and run:\n```bash\nnpx tsc hello.ts\nnode hello.js\n```",
      "codeExample": "// Try it yourself!\n// Define a function with proper types\n\nfunction greet(name: string, greeting?: string): string {\n  const actualGreeting = greeting || 'Hello';\n  return `${actualGreeting}, ${name}!`;\n}\n\n// TypeScript will catch these errors:\n// console.log(greet(123));        // Error: number not assignable to string\n// console.log(greet('John', 456)); // Error: number not assignable to string\n\nconsole.log(greet('TypeScript'));\nconsole.log(greet('World', 'Hi'));"
    },
    {
      "id": "typescript-basic-types",
      "moduleId": "typescript-basics",
      "title": "Basic Types",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Primitive types: string, number, boolean, null, undefined, symbol, bigint\n- Arrays: type[] or Array<type>\n- Objects: define shapes with interfaces or type aliases\n- any: opt-out of type checking (avoid!)\n- unknown: type-safe alternative to any\n- Type inference: TypeScript can often guess types\n\n---\n\n# Basic Types in TypeScript\n\n## Primitive Types\n\n```typescript\n// Explicit type annotations\nlet name: string = 'John';\nlet age: number = 30;\nlet isActive: boolean = true;\nlet nothing: null = null;\nlet notDefined: undefined = undefined;\n\n// Type inference (TypeScript guesses the type)\nlet inferredName = 'John';  // TypeScript knows this is string\n// inferredName = 42;       // Error: Type 'number' is not assignable to type 'string'\n```\n\n## Arrays\n\n```typescript\n// Two ways to declare arrays\nlet numbers: number[] = [1, 2, 3, 4, 5];\nlet names: Array<string> = ['Alice', 'Bob', 'Charlie'];\n\n// Mixed arrays with union types\nlet mixed: (string | number)[] = ['one', 2, 'three', 4];\n\n// Nested arrays\nlet matrix: number[][] = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n```\n\n## Tuples\n\nTuples are arrays with fixed length and specific types per position:\n\n```typescript\n// A tuple representing a point\nlet point: [number, number] = [10, 20];\n\n// A tuple with different types\nlet person: [string, number, boolean] = ['Alice', 30, true];\n\n// Accessing tuple elements\nconst name = person[0];  // TypeScript knows this is string\nconst age = person[1];   // TypeScript knows this is number\n```\n\n## Objects\n\n```typescript\n// Object type annotation\nlet user: {\n  name: string;\n  age: number;\n  isAdmin: boolean;\n} = {\n  name: 'John',\n  age: 30,\n  isAdmin: false\n};\n\n// Optional properties\nlet product: {\n  name: string;\n  price: number;\n  description?: string;  // Optional\n} = {\n  name: 'Laptop',\n  price: 999.99\n};\n\n// Readonly properties\nlet config: {\n  readonly apiKey: string;\n  readonly timeout: number;\n} = {\n  apiKey: 'abc123',\n  timeout: 5000\n};\n\n// config.apiKey = 'new-key';  // Error: Cannot assign to 'apiKey' because it is a read-only property\n```\n\n## Enums\n\n```typescript\n// Numeric enum\nenum Direction {\n  Up,      // 0\n  Down,    // 1\n  Left,    // 2\n  Right    // 3\n}\n\n// String enum (preferred)\nenum Status {\n  Pending = 'PENDING',\n  Approved = 'APPROVED',\n  Rejected = 'REJECTED'\n}\n\nconst currentStatus: Status = Status.Pending;\n```\n\n## The any Type (Avoid!)\n\n```typescript\n// any disables type checking\nlet anything: any = 4;\nanything = 'string';      // OK\nanything = true;          // OK\nanything.someMethod();    // OK (but might crash at runtime!)\n\n// Only use any when:\n// 1. Migrating JavaScript to TypeScript\n// 2. Working with third-party libraries without types\n// 3. Temporary workaround (add a TODO comment!)\n```\n\n## The unknown Type (Use Instead of any)\n\n```typescript\n// unknown is type-safe version of any\nlet safe: unknown = 4;\n// safe.toFixed();  // Error: Object is of type 'unknown'\n\n// Must narrow the type before using\nif (typeof safe === 'number') {\n  console.log(safe.toFixed(2));  // OK, TypeScript knows it's a number now\n}\n\n// Type narrowing with unknown\nfunction processData(data: unknown): void {\n  if (typeof data === 'string') {\n    console.log(data.toUpperCase());\n  } else if (Array.isArray(data)) {\n    console.log(data.length);\n  } else if (typeof data === 'object' && data !== null) {\n    console.log(Object.keys(data));\n  }\n}\n```\n\n## Special Types\n\n```typescript\n// void - for functions that don't return a value\nfunction logMessage(message: string): void {\n  console.log(message);\n}\n\n// never - for functions that never return (throw or infinite loop)\nfunction throwError(message: string): never {\n  throw new Error(message);\n}\n\n// literal types - specific values\nlet status: 'loading' | 'success' | 'error' = 'loading';\nlet pixel: 16 | 32 | 64 = 16;\n```\n\n## Type Assertions\n\nSometimes you know more than TypeScript:\n\n```typescript\nconst input = document.getElementById('input') as HTMLInputElement;\n// Now TypeScript knows it's an input element, not just HTMLElement\n\n// Alternative syntax\nconst canvas = <HTMLCanvasElement>document.getElementById('canvas');\n\n// Be careful - type assertions don't validate at runtime!\nconst user = {} as { name: string };  // Dangerous!\n// user.name is undefined but TypeScript thinks it's a string\n```\n\n## Type Inference Best Practices\n\n```typescript\n// Good - let TypeScript infer simple types\nconst count = 10;  // inferred as number\nconst message = 'Hello';  // inferred as string\n\n// Explicit types are better for:\n// - Function parameters\nfunction greet(name: string): string {\n  return `Hello, ${name}`;\n}\n\n// - Complex objects\ninterface User {\n  name: string;\n  email: string;\n}\nconst user: User = { name: 'John', email: 'john@example.com' };\n\n// - When the inferred type is too narrow\nconst status: 'pending' | 'active' | 'inactive' = 'active';\n```",
      "codeExample": "// Practice with basic types\n\n// 1. Create a properly typed array\nconst scores: number[] = [85, 92, 78, 96, 88];\n\n// 2. Define an object with optional and readonly properties\ninterface Config {\n  readonly apiUrl: string;\n  timeout: number;\n  retries?: number;\n}\n\nconst config: Config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  // retries is optional\n};\n\n// 3. Use unknown safely\nfunction processInput(input: unknown): string {\n  if (typeof input === 'string') {\n    return input.toUpperCase();\n  } else if (typeof input === 'number') {\n    return input.toString();\n  }\n  return 'Unknown input';\n}\n\nconsole.log(processInput('hello'));\nconsole.log(processInput(42));\nconsole.log(processInput(true));"
    },
    {
      "id": "typescript-interfaces-types",
      "moduleId": "typescript-basics",
      "title": "Interfaces & Type Aliases",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Interfaces and type aliases both define object shapes\n- Interfaces can be extended and merged (declaration merging)\n- Type aliases are more flexible: unions, intersections, primitives\n- Use interfaces for object shapes, type aliases for complex types\n- Optional properties with ?, readonly properties with readonly\n\n---\n\n# Interfaces vs Type Aliases\n\n## Interfaces\n\nInterfaces are the primary way to define object shapes in TypeScript:\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;           // Optional property\n  readonly createdAt: Date;  // Readonly property\n}\n\n// Using the interface\nconst user: User = {\n  id: 1,\n  name: 'John Doe',\n  email: 'john@example.com',\n  createdAt: new Date()\n};\n\n// user.createdAt = new Date();  // Error: readonly property\n```\n\n## Extending Interfaces\n\n```typescript\ninterface Animal {\n  name: string;\n  age: number;\n}\n\ninterface Dog extends Animal {\n  breed: string;\n  bark(): void;\n}\n\nconst myDog: Dog = {\n  name: 'Rex',\n  age: 3,\n  breed: 'Golden Retriever',\n  bark: () => console.log('Woof!')\n};\n\n// Multiple inheritance\ninterface CanFly {\n  wingspan: number;\n  fly(): void;\n}\n\ninterface CanSwim {\n  swim(): void;\n}\n\ninterface Duck extends Animal, CanFly, CanSwim {\n  // Duck inherits from all three!\n}\n```\n\n## Declaration Merging\n\nInterfaces have a unique feature - they can be declared multiple times and are automatically merged:\n\n```typescript\ninterface Window {\n  myLibrary: any;\n}\n\n// Later in another file...\ninterface Window {\n  anotherLibrary: any;\n}\n\n// Window now has both myLibrary and anotherLibrary\n```\n\n## Type Aliases\n\nType aliases use the `type` keyword and are more flexible:\n\n```typescript\n// Object shape (similar to interface)\ntype Point = {\n  x: number;\n  y: number;\n};\n\n// Primitive type alias\ntype ID = string | number;\n\n// Union type\ntype Status = 'pending' | 'active' | 'inactive';\n\n// Tuple type\ntype Coordinates = [number, number];\n\n// Function type\ntype Callback = (error: Error | null, data: string) => void;\n```\n\n## Intersection Types\n\n```typescript\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype Employee = {\n  employeeId: number;\n  department: string;\n};\n\n// Intersection: has all properties of both\ntype EmployeePerson = Person & Employee;\n\nconst emp: EmployeePerson = {\n  name: 'Jane',\n  age: 30,\n  employeeId: 12345,\n  department: 'Engineering'\n};\n\n// Same with interfaces using extends\ninterface EmployeePerson2 extends Person, Employee {}\n```\n\n## When to Use What?\n\n### Use Interfaces when:\n```typescript\n// 1. Defining object shapes\ninterface User {\n  name: string;\n  email: string;\n}\n\n// 2. You need to extend/implement\ninterface Admin extends User {\n  permissions: string[];\n}\n\n// 3. You need declaration merging\ninterface Array<T> {\n  customMethod(): void;\n}\n```\n\n### Use Type Aliases when:\n```typescript\n// 1. You need union types\ntype Status = 'loading' | 'success' | 'error';\n\n// 2. You need tuple types\ntype Point3D = [number, number, number];\n\n// 3. You need mapped types\ntype ReadonlyUser = Readonly<User>;\n\n// 4. You need conditional types\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\n// 5. Working with primitives\ntype UserID = string;\n```\n\n## Index Signatures\n\nFor objects with dynamic keys:\n\n```typescript\ninterface Dictionary {\n  [key: string]: number;\n}\n\nconst scores: Dictionary = {\n  alice: 95,\n  bob: 87,\n  charlie: 92\n};\n\n// More specific index signature\ninterface Config {\n  [key: string]: string | number | boolean;\n  apiUrl: string;  // Must satisfy the index signature\n  timeout: number;\n}\n```\n\n## Utility Types with Interfaces\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n  password: string;\n}\n\n// Make all properties optional\ntype PartialUser = Partial<User>;\n\n// Make all properties required\ntype RequiredUser = Required<User>;\n\n// Pick specific properties\ntype UserSummary = Pick<User, 'id' | 'name' | 'email'>;\n\n// Omit specific properties\ntype PublicUser = Omit<User, 'password'>;\n\n// Make all properties readonly\ntype ReadonlyUser = Readonly<User>;\n\n// Extract specific properties\ntype UserKeys = keyof User;  // 'id' | 'name' | 'email' | 'age' | 'password'\n```\n\n## Best Practices\n\n```typescript\n// 1. Prefer interfaces for public API shapes\ninterface Props {\n  title: string;\n  children: React.ReactNode;\n}\n\n// 2. Use type aliases for implementation details\ntype State = 'idle' | 'loading' | 'success' | 'error';\n\n// 3. Be consistent within your codebase\n// Don't mix interface User and type User in different files\n\n// 4. Use descriptive names\ninterface APIResponse<T> {\n  data: T;\n  error: string | null;\n  status: number;\n}\n\n// 5. Document with JSDoc comments\ninterface User {\n  /** Unique identifier */\n  id: number;\n  \n  /** Display name */\n  name: string;\n  \n  /** Email address, must be unique */\n  email: string;\n}\n```",
      "codeExample": "// Practice with interfaces and types\n\n// 1. Define a base interface\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  description?: string;\n}\n\n// 2. Extend it for a specific product type\ninterface Electronics extends Product {\n  warranty: number;  // months\n  brand: string;\n}\n\n// 3. Create a type alias for complex scenarios\ntype Discount = \n  | { type: 'percentage'; value: number }\n  | { type: 'fixed'; amount: number };\n\n// 4. Use intersection types\ninterface Timestamps {\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ntype ProductWithTimestamps = Product & Timestamps;\n\n// 5. Create instances\nconst laptop: Electronics = {\n  id: 1,\n  name: 'MacBook Pro',\n  price: 1999,\n  warranty: 12,\n  brand: 'Apple'\n};\n\nconst book: Product = {\n  id: 2,\n  name: 'TypeScript Handbook',\n  price: 29.99,\n  description: 'Learn TypeScript from scratch'\n};\n\nconsole.log(laptop);\nconsole.log(book);"
    },
    {
      "id": "typescript-functions-generics",
      "moduleId": "typescript-basics",
      "title": "Functions & Generics",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Function parameters and return types can be typed\n- Optional parameters with ?, default values\n- Rest parameters as arrays\n- Function overloads for different signatures\n- Generics create reusable, type-safe components\n- Generic constraints limit what types can be used\n\n---\n\n# Functions in TypeScript\n\n## Basic Function Typing\n\n```typescript\n// Function declaration\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n\n// Arrow function\nconst multiply = (a: number, b: number): number => a * b;\n\n// Function type annotation\nconst divide: (a: number, b: number) => number = (a, b) => a / b;\n```\n\n## Optional and Default Parameters\n\n```typescript\n// Optional parameter\nfunction greet(name: string, greeting?: string): string {\n  const actualGreeting = greeting || 'Hello';\n  return `${actualGreeting}, ${name}!`;\n}\n\n// Default parameter value\nfunction greetWithDefault(name: string, greeting: string = 'Hello'): string {\n  return `${greeting}, ${name}!`;\n}\n\n// Both work the same way\nconsole.log(greet('Alice'));                    // \"Hello, Alice!\"\nconsole.log(greetWithDefault('Bob', 'Hi'));     // \"Hi, Bob!\"\n```\n\n## Rest Parameters\n\n```typescript\n// Rest parameters as array\nfunction sum(...numbers: number[]): number {\n  return numbers.reduce((acc, n) => acc + n, 0);\n}\n\nconsole.log(sum(1, 2, 3, 4, 5));  // 15\n\n// Rest with other parameters\nfunction logMessage(level: string, ...messages: string[]): void {\n  console.log(`[${level}]`, ...messages);\n}\n\nlogMessage('INFO', 'Server started', 'Port: 3000');\n```\n\n## Void vs Undefined Return\n\n```typescript\n// void - function does not return anything useful\nfunction logMessage(message: string): void {\n  console.log(message);\n}\n\n// undefined - function explicitly returns undefined\nfunction doNothing(): undefined {\n  return undefined;\n}\n\n// void allows implicit return of undefined\nconst result: void = logMessage('test');  // OK\n```\n\n## Function Overloads\n\nWhen a function can accept different parameter types:\n\n```typescript\n// Overload signatures\nfunction processInput(input: string): string;\nfunction processInput(input: number): number;\nfunction processInput(input: string[]): string[];\n\n// Implementation signature\nfunction processInput(input: string | number | string[]): string | number | string[] {\n  if (typeof input === 'string') {\n    return input.toUpperCase();\n  } else if (typeof input === 'number') {\n    return input * 2;\n  } else {\n    return input.map(s => s.toUpperCase());\n  }\n}\n\n// TypeScript knows the return type based on input\nconst str = processInput('hello');     // TypeScript knows: string\nconst num = processInput(42);          // TypeScript knows: number\nconst arr = processInput(['a', 'b']);  // TypeScript knows: string[]\n```\n\n# Generics\n\n## The Problem Generics Solve\n\n```typescript\n// Without generics - not type safe\nfunction identity(arg: any): any {\n  return arg;\n}\n\nconst result = identity('hello');  // result is 'any', lost type info\n\n// With generics - type safe\nfunction identityGeneric<T>(arg: T): T {\n  return arg;\n}\n\nconst result2 = identityGeneric('hello');  // result2 is 'string'\nconst result3 = identityGeneric(42);       // result3 is 'number'\n```\n\n## Generic Functions\n\n```typescript\n// Generic function with multiple type parameters\nfunction pair<T, U>(first: T, second: U): [T, U] {\n  return [first, second];\n}\n\nconst result = pair('Alice', 30);  // [string, number]\nconst result2 = pair(true, ['a']);  // [boolean, string[]]\n\n// Generic with constraints\nfunction longest<T extends { length: number }>(a: T, b: T): T {\n  return a.length > b.length ? a : b;\n}\n\nconst longerArray = longest([1, 2, 3], [1, 2]);  // number[]\nconst longerString = longest('hello', 'world!');  // string\n// longest(1, 2);  // Error: number does not have 'length'\n```\n\n## Generic Interfaces\n\n```typescript\ninterface Box<T> {\n  value: T;\n}\n\nconst numberBox: Box<number> = { value: 42 };\nconst stringBox: Box<string> = { value: 'hello' };\n\ninterface APIResponse<T> {\n  data: T;\n  status: number;\n  error: string | null;\n}\n\nconst userResponse: APIResponse<User> = {\n  data: { id: 1, name: 'John' },\n  status: 200,\n  error: null\n};\n\nconst productsResponse: APIResponse<Product[]> = {\n  data: [{ id: 1, name: 'Widget' }],\n  status: 200,\n  error: null\n};\n```\n\n## Generic Classes\n\n```typescript\nclass Stack<T> {\n  private items: T[] = [];\n\n  push(item: T): void {\n    this.items.push(item);\n  }\n\n  pop(): T | undefined {\n    return this.items.pop();\n  }\n\n  peek(): T | undefined {\n    return this.items[this.items.length - 1];\n  }\n\n  isEmpty(): boolean {\n    return this.items.length === 0;\n  }\n}\n\nconst numberStack = new Stack<number>();\nnumberStack.push(1);\nnumberStack.push(2);\nconst top = numberStack.pop();  // TypeScript knows it's number | undefined\n\nconst stringStack = new Stack<string>();\nstringStack.push('hello');\n```\n\n## Generic Constraints\n\n```typescript\n// Constraint: T must have a 'name' property\ninterface Named {\n  name: string;\n}\n\nfunction logName<T extends Named>(obj: T): void {\n  console.log(obj.name);\n}\n\nlogName({ name: 'Alice', age: 30 });  // OK\n// logName({ age: 30 });  // Error: missing 'name'\n\n// Multiple constraints\ninterface Printable {\n  print(): void;\n}\n\ninterface Serializable {\n  serialize(): string;\n}\n\nfunction processDocument<T extends Printable & Serializable>(doc: T): void {\n  doc.print();\n  const json = doc.serialize();\n}\n\n// Keyof constraint\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { name: 'John', age: 30 };\nconst userName = getProperty(user, 'name');  // string\nconst userAge = getProperty(user, 'age');    // number\n// getProperty(user, 'email');  // Error: 'email' is not in keyof User\n```\n\n## Default Generic Parameters\n\n```typescript\ninterface Component<T = any> {\n  props: T;\n  render(): void;\n}\n\n// Without specifying T, it defaults to any\nconst genericComponent: Component = {\n  props: { anything: 'goes' },\n  render: () => {}\n};\n\n// With specific type\ninterface ButtonProps {\n  label: string;\n  onClick: () => void;\n}\n\nconst buttonComponent: Component<ButtonProps> = {\n  props: {\n    label: 'Click me',\n    onClick: () => console.log('clicked')\n  },\n  render: () => {}\n};\n```\n\n## Practical Generic Examples\n\n```typescript\n// Generic array methods\nfunction filter<T>(array: T[], predicate: (item: T) => boolean): T[] {\n  return array.filter(predicate);\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nconst evens = filter(numbers, n => n % 2 === 0);  // number[]\n\nconst words = ['apple', 'banana', 'cherry'];\nconst longWords = filter(words, w => w.length > 5);  // string[]\n\n// Generic API client\nasync function fetchData<T>(url: string): Promise<T> {\n  const response = await fetch(url);\n  return response.json();\n}\n\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst user = await fetchData<User>('/api/user/1');  // TypeScript knows it's User\nconst users = await fetchData<User[]>('/api/users');  // TypeScript knows it's User[]\n\n// Generic state management\ninterface State<T> {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n}\n\nfunction createInitialState<T>(): State<T> {\n  return {\n    data: null,\n    loading: false,\n    error: null\n  };\n}\n\nconst userState = createInitialState<User>();\nconst productState = createInitialState<Product>();\n```",
      "codeExample": "// Practice with generics\n\n// 1. Generic identity function\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nconsole.log(identity<string>('Hello'));\nconsole.log(identity<number>(42));\nconsole.log(identity<boolean>(true));\n\n// 2. Generic with constraints\ninterface HasId {\n  id: number;\n}\n\nfunction findById<T extends HasId>(items: T[], id: number): T | undefined {\n  return items.find(item => item.id === id);\n}\n\nconst users = [\n  { id: 1, name: 'Alice' },\n  { id: 2, name: 'Bob' },\n  { id: 3, name: 'Charlie' }\n];\n\nconst user = findById(users, 2);\nconsole.log(user);\n\n// 3. Generic class\nclass Queue<T> {\n  private items: T[] = [];\n\n  enqueue(item: T): void {\n    this.items.push(item);\n  }\n\n  dequeue(): T | undefined {\n    return this.items.shift();\n  }\n\n  size(): number {\n    return this.items.length;\n  }\n}\n\nconst queue = new Queue<string>();\nqueue.enqueue('first');\nqueue.enqueue('second');\nconsole.log(queue.dequeue());\nconsole.log(queue.size());"
    },
    {
      "id": "typescript-config",
      "moduleId": "typescript-basics",
      "title": "tsconfig.json & Setup",
      "order": 5,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- tsconfig.json configures TypeScript compiler options\n- strict mode enables all strict type-checking options\n- target controls JavaScript version output\n- module controls module system (CommonJS, ES modules)\n- outDir and rootDir organize compiled output\n- include/exclude control which files are compiled\n\n---\n\n# Configuring TypeScript\n\n## Creating tsconfig.json\n\n```bash\n# Generate a default config\nnpx tsc --init\n\n# Or create manually\n```\n\n```json\n{\n  \"compilerOptions\": {\n    // Basic Options\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\"],\n    \n    // Output Options\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \n    // Strict Type-Checking\n    \"strict\": true,\n    \n    // Module Resolution\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \n    // Advanced\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"**/*.test.ts\"]\n}\n```\n\n## Understanding Target\n\nThe `target` option specifies the ECMAScript version:\n\n```json\n{\n  \"compilerOptions\": {\n    // ES3 - oldest, most compatible\n    \"target\": \"ES3\",\n    \n    // ES5 - widely supported, no arrow functions, const, etc.\n    \"target\": \"ES5\",\n    \n    // ES2015/ES6 - modern browsers\n    \"target\": \"ES2015\",\n    \n    // ES2020 - modern features like BigInt, optional chaining\n    \"target\": \"ES2020\",\n    \n    // ESNext - latest features, might need transpilation\n    \"target\": \"ESNext\"\n  }\n}\n```\n\n```typescript\n// TypeScript input\nconst greet = (name: string) => `Hello, ${name}`;\nconst user = { name: 'John' }?.name ?? 'Anonymous';\n\n// Compiled to ES5\nvar greet = function (name) { return \"Hello, \" + name; };\nvar _a;\nvar user = ((_a = { name: 'John' }) === null || _a === void 0 ? void 0 : _a.name) || 'Anonymous';\n\n// Compiled to ES2020 (keeps modern syntax)\nconst greet = (name: string) => `Hello, ${name}`;\nconst user = { name: 'John' }?.name ?? 'Anonymous';\n```\n\n## Module Systems\n\n```json\n{\n  \"compilerOptions\": {\n    // CommonJS (Node.js default)\n    \"module\": \"commonjs\",\n    \n    // ES Modules (modern, tree-shakeable)\n    \"module\": \"ES2020\",\n    \n    // UMD (works in browsers and Node)\n    \"module\": \"UMD\",\n    \n    // AMD (RequireJS)\n    \"module\": \"AMD\"\n  }\n}\n```\n\n## The strict Flag\n\nSetting `\"strict\": true` enables all strict type-checking options:\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true  // Enables all options below:\n    \n    // Individual strict options:\n    // \"noImplicitAny\": true,\n    // \"strictNullChecks\": true,\n    // \"strictFunctionTypes\": true,\n    // \"strictBindCallApply\": true,\n    // \"strictPropertyInitialization\": true,\n    // \"noImplicitThis\": true,\n    // \"alwaysStrict\": true\n  }\n}\n```\n\n### Why strictNullChecks Matters\n\n```typescript\n// Without strictNullChecks\nfunction greet(name: string) {\n  console.log(name.toUpperCase());  // Compiles, might crash at runtime\n}\n\ngreet(null);  // Runtime error: Cannot read property 'toUpperCase' of null\n\n// With strictNullChecks enabled\nfunction greetSafe(name: string | null) {\n  // Error: Object is possibly 'null'\n  console.log(name.toUpperCase());\n  \n  // Must check first\n  if (name !== null) {\n    console.log(name.toUpperCase());  // OK!\n  }\n}\n```\n\n## Path Mapping\n\nCreate shortcuts for imports:\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@components/*\": [\"src/components/*\"],\n      \"@utils/*\": [\"src/utils/*\"],\n      \"@types\": [\"src/types/index.ts\"]\n    }\n  }\n}\n```\n\n```typescript\n// Instead of messy relative paths:\nimport { Button } from '../../../components/Button';\nimport { User } from '../../../../types';\n\n// Use clean absolute paths:\nimport { Button } from '@components/Button';\nimport { User } from '@types';\n```\n\nNote: Path mapping is for TypeScript only. You need additional configuration (webpack, Vite, etc.) for runtime.\n\n## Common Configuration Presets\n\n### Node.js Backend\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n### Frontend with React\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ES2020\",\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"jsx\": \"react-jsx\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true  // Let bundler handle output\n  },\n  \"include\": [\"src\"]\n}\n```\n\n### Library Package\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2015\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2015\"],\n    \"outDir\": \"./lib\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"]\n}\n```\n\n## Type Declarations\n\n```typescript\n// Generate .d.ts declaration files\n// These describe your API for consumers\n\n// In tsconfig.json\n{\n  \"compilerOptions\": {\n    \"declaration\": true,      // Generate .d.ts files\n    \"declarationMap\": true,   // Map .d.ts to source\n    \"outDir\": \"./dist\"\n  }\n}\n```\n\n## Watch Mode\n\n```bash\n# Compile in watch mode (rebuilds on file changes)\nnpx tsc --watch\n\n# Or in package.json scripts:\n\"scripts\": {\n  \"build\": \"tsc\",\n  \"dev\": \"tsc --watch\",\n  \"type-check\": \"tsc --noEmit\"\n}\n```\n\n## Compiler Checks Without Emit\n\n```bash\n# Type check without generating files (fast CI check)\nnpx tsc --noEmit\n\n# With strict mode\nnpx tsc --noEmit --strict\n```\n\n## Type Checking JavaScript\n\n```json\n{\n  \"compilerOptions\": {\n    \"allowJs\": true,         // Allow JavaScript files\n    \"checkJs\": true,         // Type check JavaScript\n    \"strict\": true\n  }\n}\n```\n\n```javascript\n// With JSDoc comments, JavaScript gets type checking!\n/**\n * @param {string} name\n * @returns {string}\n */\nfunction greet(name) {\n  return `Hello, ${name}`;\n}\n\ngreet(123);  // Error: Argument of type 'number' is not assignable to parameter of type 'string'\n```",
      "codeExample": "// Understanding strictNullChecks\n\n// Without strict mode, this would compile:\nfunction getLength(str: string | null): number {\n  // TypeScript with strictNullChecks catches this!\n  if (str === null) {\n    return 0;\n  }\n  return str.length;  // Safe now\n}\n\n// Discriminated unions work great with strict mode\ntype Result = \n  | { success: true; data: string }\n  | { success: false; error: string };\n\nfunction handleResult(result: Result): void {\n  if (result.success) {\n    console.log(result.data);  // TypeScript knows this is safe\n  } else {\n    console.error(result.error);  // TypeScript knows this is the error\n  }\n}\n\n// Path mapping example (requires tsconfig.json setup)\n// import { Button } from '@components/Button';\n// import { validateEmail } from '@utils/validation';\n\nconsole.log('tsconfig.json setup complete!');"
    }
  ],
  "exercises": []
}