{
  "module": {
    "id": "db-sql-fundamentals",
    "title": "SQL: The Fundamentals",
    "description": "Master SQL language: queries, filters, joins and aggregations",
    "icon": "FileCode",
    "requiredXp": 700,
    "color": "from-cyan-500 to-blue-600",
    "courseId": "databases"
  },
  "lessons": [
    {
      "id": "sql-basics",
      "moduleId": "db-sql-fundamentals",
      "title": "Basic SQL Queries",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- SQL = Structured Query Language\n- SELECT retrieves data\n- INSERT adds, UPDATE modifies, DELETE removes\n- WHERE filters results\n- ORDER BY sorts, LIMIT pages\n\n---\n\n# SQL: The Language of Databases\n\nSQL is the standard language for interacting with relational databases. Regardless of the system (PostgreSQL, MySQL, SQLite), basic SQL is 95% identical.\n\n## SELECT: Read Data\n\n```sql\n-- All columns\nSELECT * FROM users;\n\n-- Specific columns\nSELECT name, email FROM users;\n\n-- With alias\nSELECT name AS username, email AS user_email FROM users;\n\n-- Without duplicates\nSELECT DISTINCT country FROM users;\n\n-- Count\nSELECT COUNT(*) FROM users;\nSELECT COUNT(DISTINCT country) FROM users;\n```\n\n## WHERE: Filter\n\n```sql\n-- Equality\nSELECT * FROM users WHERE country = 'France';\n\n-- Inequalities\nSELECT * FROM products WHERE price > 100;\nSELECT * FROM users WHERE age >= 18 AND age <= 65;\n\n-- BETWEEN (inclusive)\nSELECT * FROM products WHERE price BETWEEN 10 AND 50;\n\n-- IN (list of values)\nSELECT * FROM users WHERE country IN ('France', 'Belgium', 'Switzerland');\n\n-- LIKE (text search)\nSELECT * FROM users WHERE name LIKE 'John%';      -- Starts with John\nSELECT * FROM users WHERE email LIKE '%@gmail.com'; -- Ends with @gmail.com\nSELECT * FROM users WHERE name LIKE '%Smith%';      -- Contains Smith\n\n-- NULL\nSELECT * FROM users WHERE phone IS NULL;\nSELECT * FROM users WHERE phone IS NOT NULL;\n\n-- AND / OR / NOT\nSELECT * FROM users\nWHERE country = 'France'\n  AND age >= 18\n  AND (city = 'Paris' OR city = 'Lyon');\n```\n\n## ORDER BY: Sort\n\n```sql\n-- Ascending (ASC by default)\nSELECT * FROM users ORDER BY name;\nSELECT * FROM users ORDER BY name ASC;\n\n-- Descending\nSELECT * FROM products ORDER BY price DESC;\n\n-- Multiple sort\nSELECT * FROM users ORDER BY country ASC, age DESC;\n\n-- NULL handling\nSELECT * FROM users ORDER BY phone NULLS LAST;\n```\n\n## LIMIT / OFFSET: Pagination\n\n```sql\n-- First 10 results\nSELECT * FROM users LIMIT 10;\n\n-- Page 2 (results 11-20)\nSELECT * FROM users LIMIT 10 OFFSET 10;\n\n-- Or with OFFSET clause\nSELECT * FROM users LIMIT 10 OFFSET 20;  -- Page 3\n\n-- Alternative PostgreSQL\nSELECT * FROM users OFFSET 20 LIMIT 10;\n\n-- Alternative MySQL/PostgreSQL\nSELECT * FROM users LIMIT 20, 10;  -- OFFSET 20, LIMIT 10\n```\n\n## INSERT: Add Data\n\n```sql\n-- One row\nINSERT INTO users (name, email, age)\nVALUES ('John Doe', 'john@example.com', 30);\n\n-- Multiple rows\nINSERT INTO users (name, email, age) VALUES\n  ('Jane Smith', 'jane@example.com', 25),\n  ('Bob Wilson', 'bob@example.com', 35),\n  ('Alice Brown', 'alice@example.com', 28);\n\n-- Return inserted data (PostgreSQL)\nINSERT INTO users (name, email)\nVALUES ('New User', 'new@example.com')\nRETURNING *;\n\n-- Insert with SELECT\nINSERT INTO archive_users (name, email)\nSELECT name, email FROM users WHERE inactive = true;\n```\n\n## UPDATE: Modify\n\n```sql\n-- Simple\nUPDATE users SET age = 31 WHERE id = 1;\n\n-- Multiple columns\nUPDATE users SET\n  name = 'John Updated',\n  email = 'new@example.com',\n  updated_at = NOW()\nWHERE id = 1;\n\n-- Warning! Without WHERE = all rows\nUPDATE users SET country = 'France';  -- ⚠️ DANGER!\n\n-- With return (PostgreSQL)\nUPDATE users SET age = 32 WHERE id = 1 RETURNING *;\n```\n\n## DELETE: Remove\n\n```sql\n-- Delete one row\nDELETE FROM users WHERE id = 1;\n\n-- Delete with condition\nDELETE FROM users WHERE inactive = true AND created_at < '2023-01-01';\n\n-- ⚠️ DANGER! Without WHERE = delete everything\nDELETE FROM users;  -- Deletes ALL!\n\n-- Delete with limit\nDELETE FROM logs WHERE created_at < NOW() - INTERVAL '30 days';\n```\n\n## Useful Commands\n\n```sql\n-- View table structure\n\\d users           -- PostgreSQL\nDESCRIBE users;    -- MySQL\n.schema users      -- SQLite\n\n-- List tables\n\\dt               -- PostgreSQL\nSHOW TABLES;       -- MySQL\n.tables            -- SQLite\n\n-- Comments\n-- This is a comment\n/* This is a\n   multiline comment */\n```"
    },
    {
      "id": "sql-joins",
      "moduleId": "db-sql-fundamentals",
      "title": "JOINs: Combining Data",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- JOINs combine data from multiple tables\n- INNER JOIN: intersection only\n- LEFT JOIN: all rows from left + intersection\n- RIGHT JOIN / FULL JOIN: less common variants\n- Foreign key links tables\n\n---\n\n# Understanding JOINs\n\nJOINs are the power of relational databases. They allow you to recombine data stored in different tables.\n\n## Example Tables\n\n```sql\n-- Table users\n| id | name  | email              |\n|----|-------|--------------------|\n| 1  | John  | john@example.com   |\n| 2  | Jane  | jane@example.com   |\n| 3  | Bob   | bob@example.com    |\n\n-- Table orders\n| id | user_id | total  | status    |\n|----|---------|--------|-----------|\n| 101| 1       | 150.00 | completed |\n| 102| 1       | 75.50  | pending   |\n| 103| 2       | 200.00 | completed |\n```\n\n## INNER JOIN\n\nReturns only rows that match in BOTH tables.\n\n```sql\nSELECT users.name, orders.total, orders.status\nFROM users\nINNER JOIN orders ON users.id = orders.user_id;\n\n-- Result:\n| name  | total  | status    |\n|-------|--------|-----------|\n| John  | 150.00 | completed |\n| John  | 75.50  | pending   |\n| Jane  | 200.00 | completed |\n\n-- Bob doesn't appear (no orders)\n```\n\n## LEFT JOIN (LEFT OUTER JOIN)\n\nReturns ALL rows from left table, with matching from right (or NULL).\n\n```sql\nSELECT users.name, orders.total, orders.status\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id;\n\n-- Result:\n| name  | total  | status    |\n|-------|--------|-----------|\n| John  | 150.00 | completed |\n| John  | 75.50  | pending   |\n| Jane  | 200.00 | completed |\n| Bob   | NULL   | NULL      |  ← Bob appears without order\n```\n\n**LEFT JOIN Use Cases:**\n- List all users with their number of orders (even 0)\n- Products with categories (even without category)\n\n```sql\n-- Users with order count\nSELECT\n  users.name,\n  COUNT(orders.id) AS order_count\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id\nGROUP BY users.id, users.name;\n\n-- Result:\n| name  | order_count |\n|-------|-------------|\n| John  | 2           |\n| Jane  | 1           |\n| Bob   | 0           |  ← Thanks to LEFT JOIN\n```\n\n## RIGHT JOIN\n\nOpposite of LEFT JOIN: all rows from right + matching from left.\n\n```sql\nSELECT users.name, orders.total\nFROM users\nRIGHT JOIN orders ON users.id = orders.user_id;\n\n-- Equivalent to:\nSELECT users.name, orders.total\nFROM orders\nLEFT JOIN users ON orders.user_id = users.id;\n```\n\n## FULL OUTER JOIN\n\nAll rows from both tables, with NULL where no match.\n\n```sql\nSELECT users.name, orders.total\nFROM users\nFULL OUTER JOIN orders ON users.id = orders.user_id;\n\n-- Result:\n| name  | total  |\n|-------|--------|\n| John  | 150.00 |\n| John  | 75.50  |\n| Jane  | 200.00 |\n| Bob   | NULL   |  ← In users but not orders\n| NULL  | 999.00 |  ← In orders but not users (orphan)\n```\n\n## Multiple JOINs\n\n```sql\n-- 3 tables: users, orders, order_items\nSELECT\n  users.name AS customer,\n  orders.id AS order_id,\n  products.name AS product,\n  order_items.quantity\nFROM users\nINNER JOIN orders ON users.id = orders.user_id\nINNER JOIN order_items ON orders.id = order_items.order_id\nINNER JOIN products ON order_items.product_id = products.id\nWHERE users.id = 1;\n```\n\n## Table Aliases\n\n```sql\n-- Without alias (verbose)\nSELECT users.name, orders.total FROM users INNER JOIN orders ON users.id = orders.user_id;\n\n-- With alias (readable)\nSELECT u.name, o.total\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n```\n\n## Self-JOIN\n\nJoin a table with itself:\n\n```sql\n-- Employees and their managers\nSELECT\n  e.name AS employee,\n  m.name AS manager\nFROM employees e\nLEFT JOIN employees m ON e.manager_id = m.id;\n```\n\n## Visualization of JOINs\n\n```\nINNER JOIN:      A ∩ B (intersection only)\nLEFT JOIN:       A + (A ∩ B)\nRIGHT JOIN:      (A ∩ B) + B\nFULL JOIN:       A + B (union)\n```\n\nVenn diagram:\n```\nINNER JOIN:      LEFT JOIN:       FULL JOIN:\n   ___               ___               ___\n  / A \\             / A \\             / A \\    / B \\\n  \\___/ \\___/       \\___/ \\___/       \\___/ \\___/\n    ↑                 ↑                 ↑\n   A∩B                A                 A∪B\n```"
    },
    {
      "id": "sql-aggregation",
      "moduleId": "db-sql-fundamentals",
      "title": "Aggregations and GROUP BY",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Aggregate functions: COUNT, SUM, AVG, MIN, MAX\n- GROUP BY groups rows for aggregation\n- HAVING filters groups (like WHERE for rows)\n- Subqueries for nested queries\n\n---\n\n# SQL Aggregations\n\nAggregate functions calculate values over groups of rows.\n\n## Aggregate Functions\n\n```sql\n-- COUNT: Count rows\nSELECT COUNT(*) FROM users;                    -- Total users\nSELECT COUNT(email) FROM users;                -- Non-NULL emails\nSELECT COUNT(DISTINCT country) FROM users;     -- Unique countries\n\n-- SUM: Sum\nSELECT SUM(total) FROM orders;                          -- Total sales\nSELECT SUM(total) FROM orders WHERE status = 'completed'; -- Completed sales\n\n-- AVG: Average\nSELECT AVG(age) FROM users;\nSELECT AVG(price) FROM products WHERE category = 'Electronics';\n\n-- MIN / MAX: Extreme values\nSELECT MIN(price), MAX(price) FROM products;\nSELECT MIN(created_at) AS first_order, MAX(created_at) AS last_order FROM orders;\n\n-- Combine\nSELECT\n  COUNT(*) AS total_orders,\n  SUM(total) AS revenue,\n  AVG(total) AS average_order,\n  MIN(total) AS min_order,\n  MAX(total) AS max_order\nFROM orders;\n```\n\n## GROUP BY\n\nGroups rows with same values for calculation.\n\n```sql\n-- Sales by country\nSELECT\n  country,\n  COUNT(*) AS user_count\nFROM users\nGROUP BY country;\n\n-- Result:\n| country    | user_count |\n|------------|------------|\n| France     | 150        |\n| Belgium    | 25         |\n| Switzerland| 10         |\n\n-- Revenue by month\nSELECT\n  DATE_TRUNC('month', created_at) AS month,\n  COUNT(*) AS orders,\n  SUM(total) AS revenue\nFROM orders\nGROUP BY DATE_TRUNC('month', created_at)\nORDER BY month;\n\n-- Stats by category\nSELECT\n  category,\n  COUNT(*) AS product_count,\n  AVG(price) AS avg_price,\n  MIN(price) AS min_price,\n  MAX(price) AS max_price\nFROM products\nGROUP BY category;\n```\n\n## HAVING: Filter Groups\n\nWHERE filters before aggregation, HAVING filters after.\n\n```sql\n-- ❌ IMPOSSIBLE: WHERE can't use aggregates\nSELECT country, COUNT(*) AS cnt\nFROM users\nWHERE COUNT(*) > 10    -- ERROR!\nGROUP BY country;\n\n-- ✅ CORRECT: Use HAVING\nSELECT country, COUNT(*) AS cnt\nFROM users\nGROUP BY country\nHAVING COUNT(*) > 10;   -- Countries with 10+ users\n\n-- Complex example\nSELECT\n  u.country,\n  COUNT(DISTINCT o.id) AS order_count,\n  SUM(o.total) AS total_revenue\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.country\nHAVING COUNT(DISTINCT o.id) >= 5      -- At least 5 orders\n   AND SUM(o.total) > 10000           -- Revenue > 10000\nORDER BY total_revenue DESC;\n```\n\n## Subqueries (Nested Queries)\n\n```sql\n-- Users with more orders than average\nSELECT name, order_count\nFROM (\n  SELECT\n    u.name,\n    COUNT(o.id) AS order_count\n  FROM users u\n  LEFT JOIN orders o ON u.id = o.user_id\n  GROUP BY u.id, u.name\n) AS user_stats\nWHERE order_count > (\n  SELECT AVG(order_count)\n  FROM (\n    SELECT COUNT(o.id) AS order_count\n    FROM users u\n    LEFT JOIN orders o ON u.id = o.user_id\n    GROUP BY u.id\n  ) AS counts\n);\n\n-- Simpler with CTE (WITH)\nWITH user_orders AS (\n  SELECT\n    u.id,\n    u.name,\n    COUNT(o.id) AS order_count\n  FROM users u\n  LEFT JOIN orders o ON u.id = o.user_id\n  GROUP BY u.id, u.name\n)\nSELECT name, order_count\nFROM user_orders\nWHERE order_count > (SELECT AVG(order_count) FROM user_orders);\n```\n\n## CASE: Conditions in SQL\n\n```sql\n-- Categorize orders\nSELECT\n  id,\n  total,\n  CASE\n    WHEN total < 50 THEN 'Small'\n    WHEN total < 200 THEN 'Medium'\n    ELSE 'Large'\n  END AS order_size\nFROM orders;\n\n-- With aggregation\nSELECT\n  CASE\n    WHEN age < 18 THEN 'Minor'\n    WHEN age < 65 THEN 'Adult'\n    ELSE 'Senior'\n  END AS age_group,\n  COUNT(*) AS count\nFROM users\nGROUP BY age_group;\n```\n\n## COALESCE and NULLIF\n\n```sql\n-- COALESCE: First non-NULL value\nSELECT\n  name,\n  COALESCE(phone, email, 'No contact') AS contact\nFROM users;\n\n-- NULLIF: Return NULL if equal\nSELECT\n  name,\n  NULLIF(discount, 0) AS discount_or_null\nFROM products;\n\n-- Avoid division by zero\nSELECT\n  name,\n  total_sales / NULLIF(total_orders, 0) AS avg_order_value\nFROM sales_summary;\n```"
    },
    {
      "id": "sql-advanced",
      "moduleId": "db-sql-fundamentals",
      "title": "Advanced SQL: CTEs, Window Functions",
      "order": 4,
      "difficulty": "advanced",
      "content": "# Essential to know\n- CTE (WITH) breaks complex queries into parts\n- Window functions for calculations on row sets\n- ROW_NUMBER, RANK, DENSE_RANK for ranking\n- LAG/LEAD to access previous/next rows\n\n---\n\n# CTEs: Common Table Expressions\n\nCTEs define temporary named tables to simplify complex queries.\n\n## Basic Syntax\n\n```sql\nWITH cte_name AS (\n  SELECT ...\n)\nSELECT * FROM cte_name;\n\n-- Multiple CTEs\nWITH\n  cte1 AS (SELECT ...),\n  cte2 AS (SELECT ...),\n  cte3 AS (SELECT FROM cte1 JOIN cte2 ...)\nSELECT * FROM cte3;\n```\n\n## Practical Examples\n\n```sql\n-- Top 3 products per category\nWITH product_stats AS (\n  SELECT\n    category,\n    name,\n    sales_count,\n    RANK() OVER (PARTITION BY category ORDER BY sales_count DESC) AS rank\n  FROM products\n)\nSELECT category, name, sales_count\nFROM product_stats\nWHERE rank <= 3;\n\n-- Monthly revenue growth\nWITH monthly_revenue AS (\n  SELECT\n    DATE_TRUNC('month', created_at) AS month,\n    SUM(total) AS revenue\n  FROM orders\n  GROUP BY 1\n)\nSELECT\n  month,\n  revenue,\n  LAG(revenue) OVER (ORDER BY month) AS prev_month_revenue,\n  revenue - LAG(revenue) OVER (ORDER BY month) AS growth\nFROM monthly_revenue;\n\n-- Recursive: Employee hierarchy\nWITH RECURSIVE employee_tree AS (\n  -- Anchor: level 0 (CEO with no manager)\n  SELECT id, name, manager_id, 0 AS level\n  FROM employees\n  WHERE manager_id IS NULL\n\n  UNION ALL\n\n  -- Recursive: employees whose manager is in tree\n  SELECT e.id, e.name, e.manager_id, et.level + 1\n  FROM employees e\n  INNER JOIN employee_tree et ON e.manager_id = et.id\n)\nSELECT * FROM employee_tree ORDER BY level, name;\n```\n\n# Window Functions\n\nWindow functions calculate over a set of rows related to current row.\n\n## ROW_NUMBER, RANK, DENSE_RANK\n\n```sql\n-- Rank sales\nSELECT\n  name,\n  sales,\n  ROW_NUMBER() OVER (ORDER BY sales DESC) AS row_num,\n  RANK() OVER (ORDER BY sales DESC) AS rank,\n  DENSE_RANK() OVER (ORDER BY sales DESC) AS dense_rank\nFROM products;\n\n-- Differences:\n-- sales | row_num | rank | dense_rank\n-- 1000  | 1       | 1    | 1\n-- 1000  | 2       | 1    | 1   ← Tied\n-- 900   | 3       | 3    | 2   ← RANK skips 3, DENSE_RANK continues 2\n-- 800   | 4       | 4    | 3\n\n-- PARTITION BY: Rank within category\nSELECT\n  category,\n  name,\n  sales,\n  ROW_NUMBER() OVER (PARTITION BY category ORDER BY sales DESC) AS rank_in_category\nFROM products;\n```\n\n## LAG and LEAD\n\n```sql\n-- Access previous/next rows\nSELECT\n  date,\n  revenue,\n  LAG(revenue) OVER (ORDER BY date) AS prev_day,\n  revenue - LAG(revenue) OVER (ORDER BY date) AS day_change,\n  LEAD(revenue) OVER (ORDER BY date) AS next_day\nFROM daily_revenue;\n\n-- Year-over-year comparison\nSELECT\n  month,\n  year_2023,\n  year_2022,\n  year_2023 - year_2022 AS yoy_change,\n  (year_2023 - year_2022) * 100.0 / year_2022 AS yoy_percent\nFROM (\n  SELECT\n    EXTRACT(MONTH FROM date) AS month,\n    SUM(CASE WHEN EXTRACT(YEAR FROM date) = 2023 THEN revenue END) AS year_2023,\n    SUM(CASE WHEN EXTRACT(YEAR FROM date) = 2022 THEN revenue END) AS year_2022\n  FROM sales\n  GROUP BY 1\n) monthly;\n```\n\n## SUM and AVG with OVER\n\n```sql\n-- Running total of sales\nSELECT\n  date,\n  daily_sales,\n  SUM(daily_sales) OVER (ORDER BY date) AS running_total,\n  AVG(daily_sales) OVER (ORDER BY date ROWS 6 PRECEDING) AS moving_average_7d\nFROM daily_sales;\n```\n\n## FIRST_VALUE, LAST_VALUE, NTH_VALUE\n\n```sql\nSELECT\n  category,\n  name,\n  price,\n  FIRST_VALUE(name) OVER (PARTITION BY category ORDER BY price DESC) AS most_expensive_in_category,\n  LAST_VALUE(name) OVER (PARTITION BY category ORDER BY price DESC\n    RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS cheapest_in_category\nFROM products;\n```\n\n## Frame Specifications\n\n```sql\n-- ROWS: number of rows\n-- RANGE: value-based\n\nSUM(amount) OVER (ORDER BY date ROWS UNBOUNDED PRECEDING)\nSUM(amount) OVER (ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)\nSUM(amount) OVER (ORDER BY date RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW)\n```"
    }
  ],
  "exercises": [
    {
      "id": "sql-ex-1",
      "lessonId": "sql-basics",
      "moduleId": "db-sql-fundamentals",
      "title": "Fix the Broken WHERE Clause",
      "difficulty": "easy",
      "type": "code",
      "description": "ChatGPT generated this query to find active users in France, but it's returning no results. Debug and fix it!",
      "instructions": "Your AI coding assistant generated this query:\n\n```sql\nSELECT * FROM users WHERE country = \"France\" AND status = \"active\"\n```\n\nBut when you run it, you get a syntax error. This is a common mistake when translating between different SQL dialects. Fix the query so it works correctly.\n\n**Expected behavior:** Should return all users where country is 'France' AND status is 'active'.\n\n**Hint:** Check the string delimiters - SQL uses different quotes than some programming languages!",
      "starterCode": "SELECT * FROM users WHERE country = \"France\" AND status = \"active\"",
      "solution": "SELECT * FROM users WHERE country = 'France' AND status = 'active'",
      "hints": [
        "In SQL, string literals use single quotes ('), not double quotes (\")",
        "Double quotes are used for identifiers (table/column names) in some SQL dialects",
        "This is one of the most common errors when AI tools generate SQL without knowing your database"
      ],
      "validationPrompt": "Check if the student's SQL query:\n1. Uses single quotes (') for string literals instead of double quotes (\")\n2. Correctly filters for country = 'France' AND status = 'active'\n3. The query syntax is valid SQL\n\nAccept variations like different spacing or line breaks, but the quotes MUST be single quotes for the strings."
    },
    {
      "id": "sql-ex-2",
      "lessonId": "sql-joins",
      "moduleId": "db-sql-fundamentals",
      "title": "Understanding JOIN Types",
      "difficulty": "easy",
      "type": "quiz",
      "question": "You asked Cursor to \"show all users and their orders\". It generated `SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id`. When you run it, you notice some users are missing from the results. Why?",
      "options": [
        "INNER JOIN only returns users who have at least one order - users without orders are excluded",
        "The query has a syntax error and needs to be fixed",
        "INNER JOIN returns too many results because of duplicate users",
        "The ON clause is wrong and should use orders.id = users.user_id instead"
      ],
      "correctAnswer": 0,
      "explanation": "INNER JOIN only returns rows where there's a match in BOTH tables. Users without orders won't appear in the results because they have no matching row in the orders table.\n\nTo show ALL users (including those without orders), you need LEFT JOIN:\n```sql\nSELECT * FROM users LEFT JOIN orders ON users.id = orders.user_id\n```\n\nThis is a classic mistake when working with AI-generated queries - always check which JOIN type matches your actual requirement!"
    },
    {
      "id": "sql-ex-3",
      "lessonId": "sql-aggregation",
      "moduleId": "db-sql-fundamentals",
      "title": "Fix the GROUP BY Error",
      "difficulty": "intermediate",
      "type": "code",
      "description": "v0 generated this query to show user names with their order counts, but it throws an error. Fix it!",
      "instructions": "Your AI tool generated this query:\n\n```sql\nSELECT users.name, COUNT(orders.id) AS order_count\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id\n```\n\nWhen you run it, you get an error: `column \"users.name\" must appear in the GROUP BY clause`.\n\nFix the query so it correctly shows each user's name and their total number of orders.\n\n**Expected output columns:**\n- name (user's name)\n- order_count (number of orders for that user)\n\n**Requirements:**\n- Use LEFT JOIN so users with 0 orders still appear\n- Use COUNT to count orders\n- Group the results properly",
      "starterCode": "SELECT users.name, COUNT(orders.id) AS order_count\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id",
      "solution": "SELECT users.name, COUNT(orders.id) AS order_count\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id\nGROUP BY users.name",
      "hints": [
        "When you use an aggregate function like COUNT(), all non-aggregated columns must be in GROUP BY",
        "You're selecting users.name (non-aggregated) and COUNT(orders.id) (aggregated)",
        "Add GROUP BY users.name at the end of the query",
        "This is one of the most common SQL errors when using aggregations!"
      ],
      "validationPrompt": "Check if the student's SQL query:\n1. Includes 'GROUP BY users.name' or 'GROUP BY name' (or uses users.id if they also selected it)\n2. Still has the LEFT JOIN to include users without orders\n3. Uses COUNT(orders.id) or COUNT(*) to count orders\n4. Selects name and the count with an alias like order_count\n\nThe key requirement is that non-aggregated columns (name) must appear in GROUP BY. Accept reasonable variations in formatting or if they use users.id in both SELECT and GROUP BY."
    },
    {
      "id": "sql-ex-4",
      "lessonId": "sql-aggregation",
      "moduleId": "db-sql-fundamentals",
      "title": "Debug the HAVING vs WHERE Mix-up",
      "difficulty": "intermediate",
      "type": "code",
      "description": "ChatGPT wrote a query to find countries with more than 10 users, but used WHERE instead of HAVING. Fix it!",
      "instructions": "An AI assistant generated this query to find countries that have more than 10 users:\n\n```sql\nSELECT country, COUNT(*) AS user_count\nFROM users\nWHERE COUNT(*) > 10\nGROUP BY country\n```\n\nWhen you run it, you get: `aggregate functions are not allowed in WHERE`.\n\nFix the query so it correctly returns countries with more than 10 users.\n\n**Expected behavior:** Returns countries and their user counts, but ONLY for countries with more than 10 users.\n\n**Tip:** Think about when filtering happens - before or after grouping?",
      "starterCode": "SELECT country, COUNT(*) AS user_count\nFROM users\nWHERE COUNT(*) > 10\nGROUP BY country",
      "solution": "SELECT country, COUNT(*) AS user_count\nFROM users\nGROUP BY country\nHAVING COUNT(*) > 10",
      "hints": [
        "WHERE filters individual rows BEFORE grouping happens",
        "HAVING filters groups AFTER aggregation is complete",
        "You can't use aggregate functions (like COUNT) in WHERE clause",
        "Use HAVING to filter on aggregated values: GROUP BY country HAVING COUNT(*) > 10",
        "Remember: WHERE = filter rows, HAVING = filter groups"
      ],
      "validationPrompt": "Check if the student's SQL query:\n1. Uses HAVING instead of WHERE for the COUNT(*) > 10 condition\n2. Keeps the GROUP BY country clause\n3. Has HAVING clause AFTER the GROUP BY (correct SQL order)\n4. The condition HAVING COUNT(*) > 10 is present (or similar like HAVING user_count > 10 if they reference the alias)\n\nThe key fix is moving the aggregate filter from WHERE to HAVING. Accept variations in spacing or if they use the alias in HAVING (though not all databases support that)."
    }
  ]
}
