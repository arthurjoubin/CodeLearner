{
  "module": {
    "id": "auth-security",
    "title": "Authentication & Security",
    "description": "Secure your applications with proper authentication and security practices",
    "icon": "Shield",
    "requiredXp": 600,
    "color": "from-red-500 to-pink-600",
    "courseId": "auth-security"
  },
  "lessons": [
    {
      "id": "auth-intro",
      "moduleId": "auth-security",
      "title": "Authentication vs Authorization",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Authentication: Who are you? (identity)\n- Authorization: What can you do? (permissions)\n- Both are essential for secure applications\n- Different strategies for different use cases\n\n---\n\n# Authentication vs Authorization\n\n## Understanding the Difference\n\nThese two terms are often confused, but they serve different purposes:\n\n### Authentication (AuthN)\n**Answer: \"Who are you?\"**\n\nAuthentication is the process of verifying that a user is who they claim to be.\n\n**Examples:**\n- Entering your username and password\n- Fingerprint scan\n- Face recognition\n- Security token\n- SMS code\n\n**Key characteristics:**\n- Happens once per session (at login)\n- Proves identity\n- Creates a session or token\n\n### Authorization (AuthZ)\n**Answer: \"What are you allowed to do?\"**\n\nAuthorization determines what resources an authenticated user can access and what actions they can perform.\n\n**Examples:**\n- Admin can delete users, regular user cannot\n- Premium subscribers see HD videos, free users see SD\n- Team members can edit project, viewers can only read\n\n**Key characteristics:**\n- Happens on every request\n- Checks permissions\n- Uses roles, policies, or claims\n\n## The Auth Flow\n\n```\n1. User provides credentials (email/password)\n2. System AUTHENTICATES: \"Is this really the user?\"\n3. System creates session/token\n4. User requests resource\n5. System AUTHORIZES: \"Can this user access this?\"\n6. Access granted or denied\n```\n\n## Real-World Analogy\n\n**Airport Security:**\n- **Authentication:** Showing your passport (proving identity)\n- **Authorization:** Your boarding pass (determining which gate/plane you can access)\n\n**Office Building:**\n- **Authentication:** Keycard scan (proving you work there)\n- **Authorization:** Access levels (can you enter the server room or just the lobby?)\n\n## Common Auth Strategies\n\n### 1. Session-Based (Stateful)\n```\nClient \u003c-\u003e Server \u003c-\u003e Database\n```\n- Server stores session data\n- Client gets session ID (cookie)\n- **Good for:** Traditional web apps\n- **Trade-off:** Server must track all sessions\n\n### 2. Token-Based (Stateless)\n```\nClient \u003c-\u003e Server\n(Token contains all info)\n```\n- JWT contains user info and permissions\n- No server storage needed\n- **Good for:** APIs, mobile apps, microservices\n- **Trade-off:** Cannot revoke immediately\n\n### 3. OAuth 2.0 / OpenID Connect\n```\nYour App \u003c-\u003e Google/GitHub \u003c-\u003e User\n```\n- Delegate authentication to trusted providers\n- User logs in with Google, GitHub, etc.\n- **Good for:** User convenience, reduced password fatigue\n- **Trade-off:** Dependency on third parties\n\n## When to Use What\n\n### Choose Session-Based When:\n- Building a traditional server-rendered web app\n- Need to revoke sessions immediately\n- Want simpler token management\n- Using frameworks like Express with server-side rendering\n\n### Choose JWT When:\n- Building REST APIs\n- Scaling horizontally (multiple servers)\n- Mobile or SPA applications\n- Microservices architecture\n\n### Choose OAuth When:\n- Want to offer \"Login with Google\"\n- Don't want to manage passwords\n- Building consumer-facing apps\n- Quick onboarding is important\n\n## Key Security Principles\n\n1. **Never trust the client** - Always verify on server\n2. **Use HTTPS** - Encrypt all auth traffic\n3. **Hash passwords** - Never store plain text\n4. **Validate everything** - Sanitize all input\n5. **Principle of least privilege** - Give minimum permissions needed\n6. **Defense in depth** - Multiple security layers\n\n## Quick Reference\n\n| | Authentication | Authorization |\n|---|---|---|\n| **Question** | Who are you? | What can you do? |\n| **When** | Login | Every request |\n| **Methods** | Passwords, tokens, biometrics | Roles, permissions, policies |\n| **Examples** | Login form, OAuth, 2FA | Admin panel, resource access |\n| **Stores** | Password hashes, sessions | Roles, ACLs, claims |\n\n**Remember:** Authentication proves identity, authorization controls access. You need both for secure systems!"
    },
    {
      "id": "auth-passwords",
      "moduleId": "auth-security",
      "title": "Password Hashing with bcrypt",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- NEVER store plain text passwords\n- bcrypt hashes with salt automatically\n- Salt prevents rainbow table attacks\n- Use high cost factor (10-12)\n\n---\n\n# Password Hashing with bcrypt\n\n## Why Hash Passwords?\n\n**❌ NEVER store passwords in plain text!**\n\nIf your database is compromised:\n- Plain text: Attacker has all passwords immediately\n- Hashed: Attacker must crack each password individually\n\n### Real-World Consequences\n\nWhen companies store plain text passwords:\n- Users lose trust\n- Legal liability (GDPR violations)\n- Credential stuffing attacks (trying leaked passwords on other sites)\n- Reputational damage\n\n## What is Hashing?\n\nHashing is a **one-way function** that converts data into a fixed-length string. You cannot reverse it to get the original data.\n\n```\nPassword: \"mypassword123\"\n    ↓\nHash Function\n    ↓\nHash: \"$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.VTtYA.qGZvKG6G\"\n```\n\n**Key properties:**\n- Same input always produces same output\n- Different inputs produce very different outputs\n- Impossible to reverse (get password from hash)\n- Fast to compute, slow to crack\n\n## Why bcrypt?\n\n### Problems with Simple Hashing (MD5, SHA1)\n\n1. **Rainbow Tables**: Pre-computed tables of common passwords and their hashes\n   - Attackers look up hash → instant password recovery\n\n2. **Fast Computation**: Modern GPUs can compute billions of hashes per second\n   - Brute force attacks are feasible\n\n### bcrypt Solutions\n\n**1. Automatic Salting**\n\nA salt is random data added to each password before hashing:\n\n```\nPassword: \"password123\"\nSalt: \"random_salt_abc123\"\nCombined: \"password123random_salt_abc123\"\nHash: bcrypt(combined)\n```\n\n**Result:**\n- Same password, different salt = different hash\n- Rainbow tables become useless\n- Must crack each password individually\n\n**2. Adaptive Cost Factor**\n\nbcrypt has a \"work factor\" (cost) that makes hashing slower:\n\n```javascript\n// Cost factor 10: ~100ms per hash\n// Cost factor 12: ~300ms per hash\n// Cost factor 14: ~1s per hash\n```\n\nAs computers get faster, you increase the cost factor.\n\n## Using bcrypt in Node.js\n\n### Installation\n\n```bash\nnpm install bcrypt\n```\n\n### Hashing Passwords\n\n```javascript\nimport bcrypt from 'bcrypt';\n\nconst SALT_ROUNDS = 12;  // 10-12 recommended\n\n// Hash a password\nasync function hashPassword(password) {\n  // bcrypt automatically:\n  // 1. Generates random salt\n  // 2. Hashes password with salt\n  // 3. Returns combined hash\n  const hash = await bcrypt.hash(password, SALT_ROUNDS);\n  return hash;\n}\n\n// Example\nconst password = \"mypassword123\";\nconst hash = await hashPassword(password);\nconsole.log(hash);\n// $2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.VTtYA.qGZvKG6G\n```\n\n**Understanding the hash format:**\n```\n$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.VTtYA.qGZvKG6G\n│   │  │\n│   │  └── Salt (22 chars) + Hash (31 chars)\n│   └───── Cost factor (2^12 iterations)\n└───────── Algorithm (2b = bcrypt)\n```\n\n### Verifying Passwords\n\n```javascript\n// Verify a password against stored hash\nasync function verifyPassword(password, hash) {\n  const isValid = await bcrypt.compare(password, hash);\n  return isValid;  // true or false\n}\n\n// Usage in login route\napp.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // Get user from database\n  const user = await db.getUserByEmail(email);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Verify password\n  const isValid = await bcrypt.compare(password, user.passwordHash);\n  if (!isValid) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Success! Create session/token\n  const token = createToken(user.id);\n  res.json({ token });\n});\n```\n\n## Complete Registration Example\n\n```javascript\nimport bcrypt from 'bcrypt';\nimport { z } from 'zod';\n\nconst SALT_ROUNDS = 12;\n\n// Validation schema\nconst registerSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8)  // Enforce minimum length!\n});\n\napp.post('/register', async (req, res) => {\n  try {\n    // 1. Validate input\n    const { email, password } = registerSchema.parse(req.body);\n    \n    // 2. Check if user exists\n    const existing = await db.getUserByEmail(email);\n    if (existing) {\n      return res.status(400).json({ error: 'Email already registered' });\n    }\n    \n    // 3. Hash password\n    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);\n    \n    // 4. Create user (store ONLY the hash!)\n    const user = await db.createUser({\n      email,\n      passwordHash  // Never store password!\n    });\n    \n    // 5. Return success (don't expose hash)\n    res.status(201).json({\n      message: 'User created',\n      userId: user.id\n    });\n    \n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return res.status(400).json({ error: error.errors });\n    }\n    console.error(error);\n    res.status(500).json({ error: 'Server error' });\n  }\n});\n```\n\n## Password Security Best Practices\n\n### 1. Enforce Strong Passwords\n\n```javascript\nconst passwordSchema = z.string()\n  .min(12, 'Password must be at least 12 characters')\n  .regex(/[A-Z]/, 'Must contain uppercase')\n  .regex(/[a-z]/, 'Must contain lowercase')\n  .regex(/[0-9]/, 'Must contain number')\n  .regex(/[^A-Za-z0-9]/, 'Must contain special character');\n```\n\n### 2. Use Appropriate Cost Factor\n\n```javascript\n// Test timing on your server\nconst SALT_ROUNDS = 12;  // ~250-300ms is good\n\n// Benchmark\nconsole.time('hash');\nawait bcrypt.hash('test', 12);\nconsole.timeEnd('hash');\n```\n\n### 3. Rate Limit Auth Endpoints\n\n```javascript\nimport rateLimit from 'express-rate-limit';\n\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,  // 15 minutes\n  max: 5,  // 5 attempts per window\n  message: 'Too many attempts'\n});\n\napp.post('/login', authLimiter, async (req, res) => {\n  // ...\n});\n```\n\n### 4. Don't Reveal Which Field Failed\n\n```javascript\n// BAD - reveals user exists\nif (!user) return res.status(401).json({ error: 'User not found' });\nif (!valid) return res.status(401).json({ error: 'Wrong password' });\n\n// GOOD - generic error\nif (!user || !valid) {\n  return res.status(401).json({ error: 'Invalid credentials' });\n}\n```\n\n## Alternative: Argon2\n\nArgon2 is the winner of the Password Hashing Competition (2015) and is considered more secure than bcrypt:\n\n```bash\nnpm install argon2\n```\n\n```javascript\nimport argon2 from 'argon2';\n\n// Hash\nconst hash = await argon2.hash(password);\n\n// Verify\nconst isValid = await argon2.verify(hash, password);\n```\n\n**When to use Argon2:**\n- New projects (recommended)\n- High security requirements\n- When you want memory-hard hashing\n\n**When to stick with bcrypt:**\n- Existing projects (migration effort)\n- Need maximum compatibility\n- Argon2 not available in your environment\n\n## Quick Reference\n\n```bash\n# Installation\nnpm install bcrypt\n```\n\n```javascript\nimport bcrypt from 'bcrypt';\n\nconst SALT_ROUNDS = 12;\n\n// Hash password\nconst hash = await bcrypt.hash(password, SALT_ROUNDS);\n\n// Verify password\nconst isValid = await bcrypt.compare(password, hash);\n```\n\n**Remember:**\n- ✅ Always hash passwords before storing\n- ✅ Use bcrypt or Argon2 (not MD5/SHA1)\n- ✅ Salt is automatic with bcrypt\n- ✅ Use cost factor 10-12\n- ✅ Enforce strong password policies\n- ✅ Rate limit auth attempts\n- ❌ Never store plain text passwords\n- ❌ Never log passwords\n- ❌ Don't return hash to client"
    },
    {
      "id": "auth-sessions",
      "moduleId": "auth-security",
      "title": "Session-Based Authentication",
      "order": 3,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Server stores session data, client gets session ID\n- Session ID sent via cookie\n- Stateful: server must track all sessions\n- Good for traditional web apps\n\n---\n\n# Session-Based Authentication\n\n## How Session Auth Works\n\nSession-based authentication is the traditional approach used by many web applications. The server maintains state about logged-in users.\n\n```\n1. User submits credentials (email/password)\n2. Server validates credentials\n3. Server creates session (stores user data)\n4. Server sends session ID via cookie\n5. Client includes cookie in subsequent requests\n6. Server looks up session data\n7. Server returns protected resource\n```\n\n## Session Flow Diagram\n\n```\n┌─────────┐         ┌──────────┐         ┌──────────┐\n│  Client │────────\u003e│  Server  │────────\u003e│ Session  │\n│         │ Login   │          │ Create  │  Store   │\n│         │         │ Validate │────────\u003e│          │\n│         │\u003c────────│ Cookie   │\u003c────────│          │\n│         │  SID    │          │         │          │\n│         │         │          │         │          │\n│         │ Request │          │ Lookup  │          │\n│         │+ Cookie │────────\u003e│ Session │────────\u003e│          │\n│         │         │          │\u003c────────│          │\n│         │\u003c────────│ Response │         │          │\n└─────────┘         └──────────┘         └──────────┘\n```\n\n## Implementing Sessions with Express\n\n### Installation\n\n```bash\nnpm install express-session\n```\n\n### Basic Setup\n\n```javascript\nimport session from 'express-session';\n\napp.use(session({\n  secret: process.env.SESSION_SECRET,  // Strong secret key\n  resave: false,                       // Don't save unmodified sessions\n  saveUninitialized: false,            // Don't create empty sessions\n  cookie: {\n    secure: process.env.NODE_ENV === 'production',  // HTTPS only in prod\n    httpOnly: true,                    // No JavaScript access\n    maxAge: 24 * 60 * 60 * 1000,       // 24 hours\n    sameSite: 'strict'                 // CSRF protection\n  }\n}));\n```\n\n### Login Route\n\n```javascript\napp.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // Find user\n  const user = await db.getUserByEmail(email);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Verify password\n  const isValid = await bcrypt.compare(password, user.passwordHash);\n  if (!isValid) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Create session\n  req.session.userId = user.id;\n  req.session.email = user.email;\n  req.session.role = user.role;\n  \n  res.json({\n    message: 'Login successful',\n    user: {\n      id: user.id,\n      email: user.email,\n      role: user.role\n    }\n  });\n});\n```\n\n### Protected Route\n\n```javascript\n// Auth middleware\nfunction requireAuth(req, res, next) {\n  if (!req.session.userId) {\n    return res.status(401).json({ error: 'Not authenticated' });\n  }\n  next();\n}\n\n// Protected route\napp.get('/profile', requireAuth, async (req, res) => {\n  const user = await db.getUserById(req.session.userId);\n  res.json(user);\n});\n\n// Admin only\nfunction requireAdmin(req, res, next) {\n  if (req.session.role !== 'admin') {\n    return res.status(403).json({ error: 'Admin access required' });\n  }\n  next();\n}\n\napp.get('/admin', requireAuth, requireAdmin, (req, res) => {\n  res.json({ message: 'Admin panel' });\n});\n```\n\n### Logout\n\n```javascript\napp.post('/logout', (req, res) => {\n  // Destroy session\n  req.session.destroy((err) => {\n    if (err) {\n      return res.status(500).json({ error: 'Logout failed' });\n    }\n    \n    // Clear cookie\n    res.clearCookie('connect.sid');\n    res.json({ message: 'Logout successful' });\n  });\n});\n```\n\n## Session Stores\n\nBy default, express-session stores sessions in memory. This is not suitable for production!\n\n### Redis Store (Recommended)\n\n```bash\nnpm install connect-redis redis\n```\n\n```javascript\nimport RedisStore from 'connect-redis';\nimport { createClient } from 'redis';\n\nconst redisClient = createClient();\nredisClient.connect();\n\napp.use(session({\n  store: new RedisStore({ client: redisClient }),\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n  cookie: {\n    secure: process.env.NODE_ENV === 'production',\n    httpOnly: true,\n    maxAge: 24 * 60 * 60 * 1000\n  }\n}));\n```\n\n**Benefits of Redis:**\n- Persistent storage\n- Shared across multiple servers\n- Fast (in-memory)\n- Automatic expiration\n\n### Database Store\n\n```bash\nnpm install connect-pg-simple  # For PostgreSQL\n```\n\n```javascript\nimport pgSession from 'connect-pg-simple';\n\napp.use(session({\n  store: new (pgSession(session))({\n    conObject: {\n      connectionString: process.env.DATABASE_URL\n    }\n  }),\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false\n}));\n```\n\n## Cookie Security Settings\n\n```javascript\ncookie: {\n  // HTTPS only in production\n  secure: process.env.NODE_ENV === 'production',\n  \n  // Prevent JavaScript access (XSS protection)\n  httpOnly: true,\n  \n  // Cookie expiration\n  maxAge: 24 * 60 * 60 * 1000,  // 24 hours\n  \n  // SameSite protection against CSRF\n  sameSite: 'strict',  // or 'lax' for OAuth callbacks\n  \n  // Cookie name (optional, default is connect.sid)\n  name: 'sessionId'\n}\n```\n\n## Session Best Practices\n\n### 1. Regenerate Session on Login\n\nPrevent session fixation attacks:\n\n```javascript\napp.post('/login', async (req, res) => {\n  // Store temp data\n  const tempData = req.session.tempData;\n  \n  // Regenerate session\n  req.session.regenerate((err) => {\n    if (err) throw err;\n    \n    // Set user data on new session\n    req.session.userId = user.id;\n    req.session.tempData = tempData;\n  });\n});\n```\n\n### 2. Store Minimal Data\n\n```javascript\n// Good - minimal data\nreq.session.userId = user.id;\n\n// Bad - too much data\nreq.session.user = user;  // Contains password hash, etc.\n```\n\n### 3. Implement Session Timeout\n\n```javascript\napp.use(session({\n  // ... other options\n  cookie: {\n    maxAge: 30 * 60 * 1000,  // 30 minutes\n    rolling: true  // Reset timer on each request\n  }\n}));\n```\n\n### 4. Clean Up Expired Sessions\n\nFor database stores, periodically clean expired sessions:\n\n```sql\n-- PostgreSQL\nDELETE FROM session WHERE expire \u003c NOW();\n```\n\n## Pros and Cons of Session Auth\n\n### Advantages\n- ✅ Immediate revocation (just delete session)\n- ✅ Server control over sessions\n- ✅ Can store arbitrary data\n- ✅ Well-understood security model\n- ✅ Works great with server-rendered apps\n\n### Disadvantages\n- ❌ Requires server storage\n- ❌ Doesn't scale horizontally (need shared store)\n- ❌ Stateful - harder for microservices\n- ❌ Cookie size limits\n- ❌ Cross-domain challenges\n\n## Quick Reference\n\n```javascript\n// Setup\nimport session from 'express-session';\n\napp.use(session({\n  secret: 'your-secret',\n  resave: false,\n  saveUninitialized: false,\n  cookie: {\n    secure: true,\n    httpOnly: true,\n    maxAge: 24 * 60 * 60 * 1000\n  }\n}));\n\n// Create session (login)\nreq.session.userId = user.id;\n\n// Read session (auth middleware)\nif (!req.session.userId) throw new Error('Not authenticated');\n\n// Destroy session (logout)\nreq.session.destroy();\n```\n\n**Remember:**\n- ✅ Always use secure, httpOnly cookies\n- ✅ Use Redis or DB store in production\n- ✅ Regenerate session on login\n- ✅ Store minimal data in session\n- ✅ Set appropriate expiration\n- ❌ Never store passwords in session\n- ❌ Don't use memory store in production"
    },
    {
      "id": "auth-jwt",
      "moduleId": "auth-security",
      "title": "JWT (JSON Web Tokens)",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- JWT is self-contained (stateless)\n- Three parts: header.payload.signature\n- Signed, not encrypted (don't store secrets)\n- Good for APIs and microservices\n\n---\n\n# JWT (JSON Web Tokens)\n\n## What is JWT?\n\nJWT is a compact, URL-safe means of representing claims to be transferred between two parties. It's commonly used for authentication in modern web applications.\n\n## JWT Structure\n\nA JWT consists of three parts separated by dots:\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\n**Three parts:**\n1. **Header** - Algorithm and token type\n2. **Payload** - Claims (user data)\n3. **Signature** - Verification\n\n### Header\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n### Payload\n```json\n{\n  \"userId\": \"1234567890\",\n  \"email\": \"user@example.com\",\n  \"role\": \"user\",\n  \"iat\": 1516239022,\n  \"exp\": 1516242622\n}\n```\n\n**Common claims:**\n- `sub` (subject) - User identifier\n- `iat` (issued at) - Timestamp\n- `exp` (expiration) - Expiration timestamp\n- `nbf` (not before) - Don't use before\n\n### Signature\n\nCreated by signing the header and payload with a secret key:\n\n```\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret\n)\n```\n\n## Implementing JWT in Node.js\n\n### Installation\n\n```bash\nnpm install jsonwebtoken\n```\n\n### Creating Tokens\n\n```javascript\nimport jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET;  // Keep this secret!\nconst JWT_EXPIRES_IN = '15m';  // Short-lived access tokens\n\n// Generate access token\nfunction generateAccessToken(user) {\n  return jwt.sign(\n    {\n      userId: user.id,\n      email: user.email,\n      role: user.role\n    },\n    JWT_SECRET,\n    { expiresIn: JWT_EXPIRES_IN }\n  );\n}\n\n// Generate refresh token (longer lived)\nfunction generateRefreshToken(user) {\n  return jwt.sign(\n    { userId: user.id, type: 'refresh' },\n    JWT_SECRET,\n    { expiresIn: '7d' }  // 7 days\n  );\n}\n\n// Login route\napp.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // Verify credentials...\n  const user = await verifyCredentials(email, password);\n  \n  // Generate tokens\n  const accessToken = generateAccessToken(user);\n  const refreshToken = generateRefreshToken(user);\n  \n  // Store refresh token in database (to allow revocation)\n  await db.saveRefreshToken(user.id, refreshToken);\n  \n  res.json({\n    accessToken,\n    refreshToken,\n    expiresIn: 900  // 15 minutes in seconds\n  });\n});\n```\n\n### Verifying Tokens\n\n```javascript\n// Auth middleware\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader \u0026\u0026 authHeader.split(' ')[1];  // Bearer TOKEN\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Access token required' });\n  }\n  \n  jwt.verify(token, JWT_SECRET, (err, decoded) => {\n    if (err) {\n      if (err.name === 'TokenExpiredError') {\n        return res.status(401).json({ error: 'Token expired' });\n      }\n      return res.status(403).json({ error: 'Invalid token' });\n    }\n    \n    req.user = decoded;  // Attach user data to request\n    next();\n  });\n}\n\n// Protected route\napp.get('/profile', authenticateToken, async (req, res) => {\n  const user = await db.getUserById(req.user.userId);\n  res.json(user);\n});\n```\n\n## Token Storage\n\n### Where to Store Tokens?\n\n**❌ DON'T store in localStorage/sessionStorage**\n- Vulnerable to XSS attacks\n- JavaScript can read them\n\n**✅ DO store in httpOnly cookies**\n- Not accessible by JavaScript\n- Secure against XSS\n- Sent automatically with requests\n\n```javascript\n// Set token in httpOnly cookie\nres.cookie('accessToken', accessToken, {\n  httpOnly: true,\n  secure: process.env.NODE_ENV === 'production',\n  sameSite: 'strict',\n  maxAge: 15 * 60 * 1000  // 15 minutes\n});\n\n// Cookie is automatically sent with every request\n```\n\n## Refresh Tokens\n\nAccess tokens should be short-lived. Use refresh tokens to get new access tokens without re-authenticating.\n\n```javascript\n// Refresh token endpoint\napp.post('/refresh', async (req, res) => {\n  const refreshToken = req.body.refreshToken;\n  \n  if (!refreshToken) {\n    return res.status(401).json({ error: 'Refresh token required' });\n  }\n  \n  // Verify refresh token exists in database\n  const tokenData = await db.findRefreshToken(refreshToken);\n  if (!tokenData) {\n    return res.status(403).json({ error: 'Invalid refresh token' });\n  }\n  \n  // Verify token\n  jwt.verify(refreshToken, JWT_SECRET, async (err, decoded) => {\n    if (err) {\n      return res.status(403).json({ error: 'Invalid refresh token' });\n    }\n    \n    // Get user and generate new access token\n    const user = await db.getUserById(decoded.userId);\n    const accessToken = generateAccessToken(user);\n    \n    res.json({ accessToken });\n  });\n});\n\n// Revoke refresh token (logout from all devices)\napp.post('/revoke', authenticateToken, async (req, res) => {\n  await db.deleteRefreshTokens(req.user.userId);\n  res.json({ message: 'All sessions revoked' });\n});\n```\n\n## JWT Best Practices\n\n### 1. Keep Secrets Secret\n\n```javascript\n// Use environment variables\nconst JWT_SECRET = process.env.JWT_SECRET;\n\n// Generate strong secret\n// node -e \"console.log(require('crypto').randomBytes(64).toString('hex'))\"\n```\n\n### 2. Use Short Expiration\n\n```javascript\n// Access tokens: 15 minutes\n// Refresh tokens: 7 days\nconst token = jwt.sign(payload, secret, { expiresIn: '15m' });\n```\n\n### 3. Don't Store Sensitive Data\n\n```javascript\n// BAD - storing sensitive info\nconst token = jwt.sign({\n  userId: user.id,\n  ssn: user.socialSecurityNumber,  // ❌ Never do this!\n  password: user.passwordHash       // ❌ Never do this!\n}, secret);\n\n// GOOD - minimal data\nconst token = jwt.sign({\n  userId: user.id,\n  role: user.role\n}, secret);\n```\n\n### 4. Implement Token Revocation\n\n```javascript\n// Maintain a blacklist of revoked tokens\nconst revokedTokens = new Set();\n\nfunction revokeToken(token) {\n  revokedTokens.add(token);\n}\n\nfunction isTokenRevoked(token) {\n  return revokedTokens.has(token);\n}\n```\n\n## Pros and Cons of JWT\n\n### Advantages\n- ✅ Stateless - no server storage needed\n- ✅ Scales horizontally\n- ✅ Cross-domain friendly\n- ✅ Decoupled from auth server\n- ✅ Good for microservices\n\n### Disadvantages\n- ❌ Cannot revoke immediately (unless blacklisted)\n- ❌ Tokens can grow large\n- ❌ Payload is visible (though signed)\n- ❌ Complexity of refresh tokens\n- ❌ Clock skew issues\n\n## Quick Reference\n\n```bash\n# Installation\nnpm install jsonwebtoken\n```\n\n```javascript\nimport jwt from 'jsonwebtoken';\n\nconst SECRET = process.env.JWT_SECRET;\n\n// Sign\nconst token = jwt.sign({ userId: user.id }, SECRET, { expiresIn: '15m' });\n\n// Verify\njwt.verify(token, SECRET, (err, decoded) => {\n  if (err) throw err;\n  console.log(decoded.userId);\n});\n```\n\n**Remember:**\n- ✅ Sign tokens with strong secret\n- ✅ Set short expiration times\n- ✅ Store in httpOnly cookies (not localStorage)\n- ✅ Use refresh tokens for better UX\n- ✅ Implement token revocation\n- ❌ Don't store sensitive data in payload\n- ❌ Don't use without HTTPS"
    },
    {
      "id": "auth-oauth",
      "moduleId": "auth-security",
      "title": "OAuth 2.0 & Social Login",
      "order": 5,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- OAuth lets users login via Google, GitHub, etc.\n- Authorization code flow is most secure\n- You get tokens to access user data\n- Libraries: passport.js, arctic, lucia\n\n---\n\n# OAuth 2.0 & Social Login\n\n## What is OAuth 2.0?\n\nOAuth 2.0 is an authorization framework that enables third-party applications to obtain limited access to a user's resources without sharing their credentials.\n\n## Why Use Social Login?\n\n**Benefits for Users:**\n- No need to create new passwords\n- Faster registration\n- Already authenticated with trusted provider\n\n**Benefits for Developers:**\n- No password management\n- Verified email addresses\n- Reduced fake accounts\n- Access to profile information\n\n## OAuth 2.0 Authorization Code Flow\n\nThis is the most secure flow for server-side applications:\n\n```\n1. User clicks \"Login with Google\" on your app\n2. Your app redirects to Google with client_id and redirect_uri\n3. User authenticates with Google and grants permissions\n4. Google redirects back to your app with an authorization code\n5. Your server exchanges the code for access tokens\n6. Use access token to fetch user information\n```\n\n### Flow Diagram\n\n```\n┌─────────┐                    ┌──────────┐                    ┌─────────┐\n│  User   │───1. Click Login──\u003e│ Your App │───2. Redirect────\u003e│ Google  │\n│         │                    │          │   + client_id     │         │\n│         │                    │          │                    │         │\n│         │───3. Login &─────\u003e│          │\u003c──4. Redirect──────│         │\n│         │    Consent         │          │   + auth code      │         │\n│         │                    │          │                    │         │\n│         │                    │──5. Exchange──\u003e│         │\n│         │                    │   code for      │         │\n│         │                    │   tokens          │         │\n│         │                    │                   │         │\n│         │                    │\u003c─6. Access &────│         │\n│         │                    │   Refresh Token  │         │\n└─────────┘                    └───────────────────┴─────────┘\n```\n\n## Implementation with Passport.js\n\n### Installation\n\n```bash\nnpm install passport passport-google-oauth20\n```\n\n### Setup\n\n```javascript\nimport passport from 'passport';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\n\npassport.use(new GoogleStrategy({\n    clientID: process.env.GOOGLE_CLIENT_ID,\n    clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n    callbackURL: '/auth/google/callback'\n  },\n  async (accessToken, refreshToken, profile, done) => {\n    // Find or create user\n    let user = await db.findUserByEmail(profile.emails[0].value);\n    \n    if (!user) {\n      // Create new user\n      user = await db.createUser({\n        email: profile.emails[0].value,\n        name: profile.displayName,\n        googleId: profile.id,\n        avatar: profile.photos[0].value\n      });\n    }\n    \n    done(null, user);\n  }\n));\n\n// Serialize user for session\npassport.serializeUser((user, done) => {\n  done(null, user.id);\n});\n\npassport.deserializeUser(async (id, done) => {\n  const user = await db.findUserById(id);\n  done(null, user);\n});\n\n// Initialize passport\napp.use(passport.initialize());\napp.use(passport.session());\n```\n\n### Routes\n\n```javascript\n// Initiate OAuth flow\napp.get('/auth/google',\n  passport.authenticate('google', {\n    scope: ['profile', 'email']  // Requested permissions\n  })\n);\n\n// OAuth callback\napp.get('/auth/google/callback',\n  passport.authenticate('google', {\n    failureRedirect: '/login',\n    successRedirect: '/dashboard'\n  })\n);\n\n// Logout\napp.get('/logout', (req, res) => {\n  req.logout();\n  res.redirect('/');\n});\n```\n\n## Setting Up OAuth Providers\n\n### Google OAuth\n\n1. Go to [Google Cloud Console](https://console.cloud.google.com/)\n2. Create a new project\n3. Enable Google+ API\n4. Create OAuth 2.0 credentials\n5. Add authorized redirect URIs\n6. Copy Client ID and Client Secret\n\n### GitHub OAuth\n\n1. Go to GitHub Settings → Developer settings → OAuth Apps\n2. Create New OAuth App\n3. Set Authorization callback URL\n4. Copy Client ID and Client Secret\n\n## Manual OAuth Implementation\n\nWithout libraries (to understand the flow):\n\n```javascript\nimport crypto from 'crypto';\n\n// Step 1: Generate authorization URL\napp.get('/auth/google', (req, res) => {\n  const state = crypto.randomBytes(32).toString('hex');\n  req.session.oauthState = state;  // Store for verification\n  \n  const params = new URLSearchParams({\n    client_id: process.env.GOOGLE_CLIENT_ID,\n    redirect_uri: `${process.env.APP_URL}/auth/google/callback`,\n    response_type: 'code',\n    scope: 'openid email profile',\n    state: state,  // CSRF protection\n    access_type: 'offline',  // Get refresh token\n    prompt: 'consent'\n  });\n  \n  res.redirect(`https://accounts.google.com/o/oauth2/v2/auth?${params}`);\n});\n\n// Step 2: Handle callback\napp.get('/auth/google/callback', async (req, res) => {\n  const { code, state, error } = req.query;\n  \n  // Check for errors\n  if (error) {\n    return res.redirect('/login?error=access_denied');\n  }\n  \n  // Verify state (CSRF protection)\n  if (state !== req.session.oauthState) {\n    return res.status(403).send('Invalid state');\n  }\n  \n  // Exchange code for tokens\n  const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({\n      code: code,\n      client_id: process.env.GOOGLE_CLIENT_ID,\n      client_secret: process.env.GOOGLE_CLIENT_SECRET,\n      redirect_uri: `${process.env.APP_URL}/auth/google/callback`,\n      grant_type: 'authorization_code'\n    })\n  });\n  \n  const tokens = await tokenResponse.json();\n  \n  // Fetch user info\n  const userResponse = await fetch(\n    'https://www.googleapis.com/oauth2/v2/userinfo',\n    {\n      headers: { Authorization: `Bearer ${tokens.access_token}` }\n    }\n  );\n  \n  const userInfo = await userResponse.json();\n  \n  // Create session or JWT\n  req.session.userId = await findOrCreateUser(userInfo);\n  \n  res.redirect('/dashboard');\n});\n```\n\n## Account Linking\n\nAllow users to connect multiple OAuth providers to one account:\n\n```javascript\napp.get('/auth/link/google', requireAuth, async (req, res) => {\n  // Store that user wants to link account\n  req.session.linkingAccount = true;\n  \n  // Redirect to OAuth\n  res.redirect('/auth/google');\n});\n\n// In callback\nif (req.session.linkingAccount) {\n  await db.linkOAuthAccount(req.session.userId, {\n    provider: 'google',\n    providerId: userInfo.id\n  });\n  req.session.linkingAccount = false;\n}\n```\n\n## Security Considerations\n\n### 1. Always Use State Parameter\nPrevents CSRF attacks on OAuth callbacks.\n\n### 2. Verify Redirect URIs\nEnsure the redirect URI matches exactly what you registered.\n\n### 3. Store Tokens Securely\n```javascript\n// Encrypt refresh tokens before storing\nconst encryptedToken = encrypt(tokens.refresh_token);\nawait db.saveRefreshToken(user.id, encryptedToken);\n```\n\n### 4. Handle Token Expiration\n```javascript\n// Check if token is expired\nif (Date.now() >= token.expires_at) {\n  // Refresh the token\n  const newToken = await refreshAccessToken(token.refresh_token);\n}\n```\n\n## Common Pitfalls\n\n1. **Not verifying state** → CSRF vulnerabilities\n2. **Trusting user data** → Always verify tokens server-side\n3. **Storing tokens insecurely** → Encrypt at rest\n4. **Not handling errors** → Users get stuck\n5. **Missing scopes** → Can't access needed data\n\n## Quick Reference\n\n```bash\n# Installation\nnpm install passport passport-google-oauth20\n```\n\n```javascript\n// Setup strategy\npassport.use(new GoogleStrategy({\n  clientID: process.env.GOOGLE_CLIENT_ID,\n  clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n  callbackURL: '/auth/google/callback'\n}, async (token, refreshToken, profile, done) => {\n  const user = await findOrCreateUser(profile);\n  done(null, user);\n}));\n\n// Routes\napp.get('/auth/google', passport.authenticate('google', { scope: ['email'] }));\napp.get('/auth/google/callback', passport.authenticate('google', {\n  successRedirect: '/dashboard',\n  failureRedirect: '/login'\n}));\n```\n\n**Remember:**\n- ✅ Use authorization code flow (most secure)\n- ✅ Always verify state parameter\n- ✅ Store tokens encrypted\n- ✅ Handle errors gracefully\n- ✅ Allow account linking\n- ❌ Don't trust client-side tokens\n- ❌ Don't store tokens in localStorage"
    },
    {
      "id": "auth-middleware",
      "moduleId": "auth-security",
      "title": "Auth Middleware & Protected Routes",
      "order": 6,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Middleware checks auth before route handlers\n- Extract and verify token/session\n- Attach user to request object\n- Return 401 Unauthorized if invalid\n\n---\n\n# Auth Middleware & Protected Routes\n\n## What is Middleware?\n\nMiddleware functions are functions that have access to the request object, response object, and the next middleware function in the application's request-response cycle.\n\n```\nRequest → Middleware 1 → Middleware 2 → Route Handler → Response\n              ↓               ↓\n         Check auth       Check role\n```\n\n## Creating Auth Middleware\n\n### Basic Authentication Middleware\n\n```javascript\n// middleware/auth.js\nimport jwt from 'jsonwebtoken';\n\nexport function requireAuth(req, res, next) {\n  // Get token from header\n  const authHeader = req.headers['authorization'];\n  const token = authHeader \u0026\u0026 authHeader.split(' ')[1];  // Bearer TOKEN\n  \n  if (!token) {\n    return res.status(401).json({\n      error: 'Access denied',\n      message: 'No token provided'\n    });\n  }\n  \n  try {\n    // Verify token\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    \n    // Attach user to request\n    req.user = decoded;\n    \n    // Continue to next middleware/route\n    next();\n    \n  } catch (error) {\n    if (error.name === 'TokenExpiredError') {\n      return res.status(401).json({\n        error: 'Token expired',\n        message: 'Please log in again'\n      });\n    }\n    \n    return res.status(403).json({\n      error: 'Invalid token',\n      message: 'Token verification failed'\n    });\n  }\n}\n```\n\n### Session-Based Auth Middleware\n\n```javascript\nexport function requireSession(req, res, next) {\n  if (!req.session.userId) {\n    return res.status(401).json({\n      error: 'Not authenticated',\n      message: 'Please log in'\n    });\n  }\n  \n  // Optionally fetch full user data\n  req.user = {\n    id: req.session.userId,\n    role: req.session.role\n  };\n  \n  next();\n}\n```\n\n## Role-Based Middleware\n\n### Authorization Middleware\n\n```javascript\n// Check if user has required role\nexport function requireRole(...allowedRoles) {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Not authenticated' });\n    }\n    \n    if (!allowedRoles.includes(req.user.role)) {\n      return res.status(403).json({\n        error: 'Forbidden',\n        message: `Role '${req.user.role}' not authorized`\n      });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.delete('/users/:id',\n  requireAuth,\n  requireRole('admin', 'moderator'),\n  deleteUser\n);\n```\n\n### Permission-Based Middleware\n\n```javascript\n// More granular permissions\nexport function requirePermission(permission) {\n  return async (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Not authenticated' });\n    }\n    \n    const userPermissions = await getUserPermissions(req.user.id);\n    \n    if (!userPermissions.includes(permission)) {\n      return res.status(403).json({\n        error: 'Forbidden',\n        message: `Missing permission: ${permission}`\n      });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.post('/posts',\n  requireAuth,\n  requirePermission('posts:create'),\n  createPost\n);\n```\n\n## Combining with Validation\n\n### With Zod Validation\n\n```javascript\nimport { z } from 'zod';\n\n// Validation middleware factory\nfunction validate(schema) {\n  return (req, res, next) => {\n    try {\n      schema.parse(req.body);\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          error: 'Validation failed',\n          details: error.errors\n        });\n      }\n      next(error);\n    }\n  };\n}\n\n// Schemas\nconst createPostSchema = z.object({\n  title: z.string().min(1).max(200),\n  content: z.string().min(1),\n  published: z.boolean().optional()\n});\n\n// Usage - middleware chain\napp.post('/posts',\n  requireAuth,                    // 1. Check auth\n  requirePermission('posts:create'), // 2. Check permission\n  validate(createPostSchema),     // 3. Validate input\n  createPost                      // 4. Handle request\n);\n```\n\n## Resource Ownership\n\n### Verifying Resource Ownership\n\n```javascript\n// Check if user owns the resource\nexport function requireOwnership(getResourceOwner) {\n  return async (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Not authenticated' });\n    }\n    \n    const resourceId = req.params.id;\n    const ownerId = await getResourceOwner(resourceId);\n    \n    // Allow if owner or admin\n    if (req.user.id !== ownerId \u0026\u0026 req.user.role !== 'admin') {\n      return res.status(403).json({\n        error: 'Forbidden',\n        message: 'You do not own this resource'\n      });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.put('/posts/:id',\n  requireAuth,\n  requireOwnership(async (postId) => {\n    const post = await db.getPost(postId);\n    return post.authorId;\n  }),\n  updatePost\n);\n```\n\n## Error Handling Middleware\n\n### Centralized Error Handler\n\n```javascript\n// Always define last\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  \n  if (err.name === 'UnauthorizedError') {\n    return res.status(401).json({\n      error: 'Unauthorized',\n      message: 'Invalid token'\n    });\n  }\n  \n  if (err.name === 'ValidationError') {\n    return res.status(400).json({\n      error: 'Validation Error',\n      message: err.message\n    });\n  }\n  \n  res.status(500).json({\n    error: 'Internal Server Error',\n    message: process.env.NODE_ENV === 'production'\n      ? 'Something went wrong'\n      : err.message\n  });\n});\n```\n\n## Complete Example\n\n```javascript\nimport express from 'express';\nimport jwt from 'jsonwebtoken';\nimport { z } from 'zod';\n\nconst app = express();\n\n// ===== MIDDLEWARE =====\n\n// Auth middleware\nconst requireAuth = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  if (!token) {\n    return res.status(401).json({ error: 'No token' });\n  }\n  \n  try {\n    req.user = jwt.verify(token, process.env.JWT_SECRET);\n    next();\n  } catch (err) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n};\n\n// Role middleware\nconst requireRole = (...roles) => {\n  return (req, res, next) => {\n    if (!roles.includes(req.user?.role)) {\n      return res.status(403).json({ error: 'Insufficient role' });\n    }\n    next();\n  };\n};\n\n// Validation middleware\nconst validate = (schema) => (req, res, next) => {\n  try {\n    schema.parse(req.body);\n    next();\n  } catch (err) {\n    res.status(400).json({ error: err.errors });\n  }\n};\n\n// ===== ROUTES =====\n\n// Public routes\napp.post('/login', login);\napp.post('/register', register);\n\n// Protected routes\napp.get('/profile', requireAuth, getProfile);\napp.put('/profile', requireAuth, validate(updateProfileSchema), updateProfile);\n\n// Admin routes\napp.get('/admin/users', requireAuth, requireRole('admin'), getAllUsers);\napp.delete('/admin/users/:id', requireAuth, requireRole('admin'), deleteUser);\n\n// User routes with ownership\napp.get('/posts/:id', getPost);  // Public\napp.post('/posts', requireAuth, validate(createPostSchema), createPost);\napp.put('/posts/:id', requireAuth, requireOwnership(getPostOwner), updatePost);\napp.delete('/posts/:id', requireAuth, requireOwnership(getPostOwner), deletePost);\n```\n\n## Testing Middleware\n\n```javascript\n// test/auth.middleware.test.js\nimport { requireAuth } from '../middleware/auth.js';\n\ndescribe('Auth Middleware', () => {\n  it('should reject requests without token', () => {\n    const req = { headers: {} };\n    const res = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn()\n    };\n    const next = jest.fn();\n    \n    requireAuth(req, res, next);\n    \n    expect(res.status).toHaveBeenCalledWith(401);\n    expect(next).not.toHaveBeenCalled();\n  });\n  \n  it('should accept valid token', () => {\n    const token = jwt.sign({ userId: '123' }, process.env.JWT_SECRET);\n    const req = {\n      headers: { authorization: `Bearer ${token}` }\n    };\n    const res = {};\n    const next = jest.fn();\n    \n    requireAuth(req, res, next);\n    \n    expect(req.user).toBeDefined();\n    expect(next).toHaveBeenCalled();\n  });\n});\n```\n\n## Quick Reference\n\n```javascript\n// Basic auth middleware\nfunction requireAuth(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  if (!token) return res.status(401).json({ error: 'No token' });\n  \n  try {\n    req.user = jwt.verify(token, SECRET);\n    next();\n  } catch {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n}\n\n// Role check\nfunction requireRole(...roles) {\n  return (req, res, next) => {\n    if (!roles.includes(req.user?.role)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n    next();\n  };\n}\n\n// Usage\napp.get('/admin', requireAuth, requireRole('admin'), handler);\n```\n\n**Remember:**\n- ✅ Always verify auth before protected routes\n- ✅ Attach user to request for downstream use\n- ✅ Return 401 for missing auth, 403 for insufficient permissions\n- ✅ Chain middleware for complex checks\n- ✅ Test your middleware thoroughly\n- ❌ Don't forget to call next()\n- ❌ Don't expose sensitive error details"
    },
    {
      "id": "auth-security-headers",
      "moduleId": "auth-security",
      "title": "Security Best Practices",
      "order": 7,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- HTTPS everywhere in production\n- HttpOnly, Secure, SameSite cookie flags\n- CSRF protection for cookie-based auth\n- Rate limiting on auth endpoints\n\n---\n\n# Security Best Practices\n\n## HTTPS Everywhere\n\n### Why HTTPS?\n\nHTTPS encrypts all communication between client and server:\n- Prevents man-in-the-middle attacks\n- Protects cookies and tokens\n- Required for modern browser features\n- SEO ranking factor\n\n### Enforcing HTTPS\n\n```javascript\n// Redirect HTTP to HTTPS\napp.use((req, res, next) => {\n  if (process.env.NODE_ENV === 'production' \u0026\u0026 !req.secure) {\n    return res.redirect(`https://${req.headers.host}${req.url}`);\n  }\n  next();\n});\n\n// Or use a library\nimport helmet from 'helmet';\napp.use(helmet());\n```\n\n## Secure Cookies\n\n### Cookie Flags\n\n```javascript\nres.cookie('sessionId', token, {\n  // Prevent JavaScript access (XSS protection)\n  httpOnly: true,\n  \n  // HTTPS only in production\n  secure: process.env.NODE_ENV === 'production',\n  \n  // SameSite protection (CSRF)\n  sameSite: 'strict',  // 'strict', 'lax', or 'none'\n  \n  // Cookie expiration\n  maxAge: 24 * 60 * 60 * 1000,  // 24 hours\n  \n  // Cookie scope\n  domain: '.example.com',  // Subdomains\n  path: '/'                // URL path\n});\n```\n\n### SameSite Values\n\n- **Strict**: Cookie never sent in cross-site requests (most secure)\n- **Lax**: Cookie sent for top-level navigation GET requests (balanced)\n- **None**: Cookie sent with all requests (requires Secure flag)\n\n## Security Headers with Helmet\n\n```bash\nnpm install helmet\n```\n\n```javascript\nimport helmet from 'helmet';\n\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\", 'https://api.example.com']\n    }\n  },\n  hsts: {\n    maxAge: 31536000,  // 1 year\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'same-origin' }\n}));\n```\n\n**Key headers set by Helmet:**\n- `Content-Security-Policy` - XSS protection\n- `X-Frame-Options` - Clickjacking protection\n- `X-Content-Type-Options` - MIME sniffing protection\n- `Strict-Transport-Security` - HTTPS enforcement\n- `Referrer-Policy` - Privacy protection\n\n## CSRF Protection\n\n### What is CSRF?\n\nCross-Site Request Forgery: Attacker tricks user's browser into performing unwanted actions on a trusted site.\n\n### Protection Methods\n\n**1. SameSite Cookies (Modern)**\n```javascript\n// Already covered above\nsameSite: 'strict'  // or 'lax'\n```\n\n**2. CSRF Tokens (Traditional)**\n```bash\nnpm install csurf\n```\n\n```javascript\nimport csurf from 'csurf';\n\nconst csrfProtection = csurf({\n  cookie: {\n    httpOnly: true,\n    secure: true\n  }\n});\n\n// Apply to all routes\napp.use(csrfProtection);\n\n// Get CSRF token\napp.get('/form', (req, res) => {\n  res.render('form', { csrfToken: req.csrfToken() });\n});\n\n// Form must include token\n// \u003cinput type=\"hidden\" name=\"_csrf\" value=\"{{csrfToken}}\"\u003e\n```\n\n## Rate Limiting\n\n### Protect Against Brute Force\n\n```bash\nnpm install express-rate-limit\n```\n\n```javascript\nimport rateLimit from 'express-rate-limit';\n\n// Strict limit for auth endpoints\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,  // 15 minutes\n  max: 5,  // 5 attempts per window\n  message: {\n    error: 'Too many attempts',\n    retryAfter: '15 minutes'\n  },\n  standardHeaders: true,\n  legacyHeaders: false\n});\n\n// General API limit\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  message: 'Too many requests from this IP'\n});\n\n// Apply to routes\napp.post('/login', authLimiter, loginHandler);\napp.post('/register', authLimiter, registerHandler);\napp.use('/api/', apiLimiter);\n```\n\n## Account Security\n\n### Account Lockout\n\n```javascript\n// After N failed attempts, lock account\nasync function checkLockout(email) {\n  const user = await db.getUserByEmail(email);\n  \n  if (user.failedAttempts >= 5) {\n    const lockoutTime = 30 * 60 * 1000;  // 30 minutes\n    if (Date.now() - user.lastAttempt < lockoutTime) {\n      throw new Error('Account locked. Try again later.');\n    }\n    // Reset after lockout period\n    await db.resetFailedAttempts(email);\n  }\n}\n\nasync function recordFailedAttempt(email) {\n  await db.incrementFailedAttempts(email, Date.now());\n}\n```\n\n### Password Reset Security\n\n```javascript\n// Generate secure reset token\nimport crypto from 'crypto';\n\nasync function createPasswordReset(email) {\n  const token = crypto.randomBytes(32).toString('hex');\n  const expiresAt = Date.now() + 60 * 60 * 1000;  // 1 hour\n  \n  await db.saveResetToken(email, {\n    token: hashToken(token),  // Hash before storing\n    expiresAt\n  });\n  \n  // Send email with plain token\n  await sendResetEmail(email, token);\n}\n\n// Verify reset token\nasync function verifyResetToken(email, token) {\n  const resetData = await db.getResetToken(email);\n  \n  if (!resetData) throw new Error('Invalid token');\n  if (Date.now() > resetData.expiresAt) {\n    throw new Error('Token expired');\n  }\n  if (!compareToken(token, resetData.token)) {\n    throw new Error('Invalid token');\n  }\n  \n  return true;\n}\n```\n\n## Input Validation\n\n### Always Validate Input\n\n```javascript\nimport { z } from 'zod';\n\nconst loginSchema = z.object({\n  email: z.string().email('Invalid email format'),\n  password: z.string().min(8, 'Password too short')\n});\n\napp.post('/login', async (req, res) => {\n  // Validate before processing\n  const result = loginSchema.safeParse(req.body);\n  \n  if (!result.success) {\n    return res.status(400).json({\n      error: 'Validation failed',\n      details: result.error.errors\n    });\n  }\n  \n  const { email, password } = result.data;\n  // Continue with login...\n});\n```\n\n## Security Checklist\n\n### Pre-Production Checklist\n\n- [ ] HTTPS enabled\n- [ ] Secure cookie flags (httpOnly, secure, sameSite)\n- [ ] Helmet middleware configured\n- [ ] Rate limiting on auth endpoints\n- [ ] CSRF protection\n- [ ] Input validation on all endpoints\n- [ ] SQL injection protection (parameterized queries)\n- [ ] XSS protection (output encoding)\n- [ ] Security headers configured\n- [ ] Error handling (no sensitive info leaked)\n- [ ] Dependencies updated\n- [ ] Secrets in environment variables\n- [ ] Logging and monitoring\n\n## Quick Reference\n\n```javascript\n// Essential security middleware\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\n\n// Helmet for security headers\napp.use(helmet());\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100\n});\napp.use(limiter);\n\n// Secure cookies\nres.cookie('token', value, {\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict',\n  maxAge: 24 * 60 * 60 * 1000\n});\n```\n\n**Remember:**\n- ✅ Always use HTTPS in production\n- ✅ Set all cookie security flags\n- ✅ Implement rate limiting\n- ✅ Use security headers (Helmet)\n- ✅ Validate all input\n- ✅ Protect against CSRF\n- ✅ Implement account lockout\n- ✅ Log security events\n- ❌ Never trust client input\n- ❌ Don't expose sensitive error messages\n- ❌ Don't commit secrets to git"
    },
    {
      "id": "auth-common-vulnerabilities",
      "moduleId": "auth-security",
      "title": "Common Vulnerabilities",
      "order": 8,
      "difficulty": "advanced",
      "content": "# Essential to know\n- SQL injection: use parameterized queries\n- XSS: sanitize output, use CSP\n- CSRF: use tokens or SameSite cookies\n- Always validate and sanitize input\n\n---\n\n# Common Security Vulnerabilities\n\n## SQL Injection\n\n### The Vulnerability\n\nAttacker injects malicious SQL code through user input.\n\n**Vulnerable Code:**\n```javascript\n// ❌ NEVER do this!\nconst query = `SELECT * FROM users WHERE email = '${email}'`;\nawait db.query(query);\n\n// If email is: ' OR '1'='1\n// Query becomes: SELECT * FROM users WHERE email = '' OR '1'='1'\n// Returns ALL users!\n```\n\n**Attacker inputs:**\n- `' OR '1'='1` - Bypass authentication\n- `'; DROP TABLE users; --` - Delete data\n- `' UNION SELECT * FROM passwords --` - Extract data\n\n### Prevention\n\n**✅ Use Parameterized Queries:**\n```javascript\n// Using pg (PostgreSQL)\nconst query = 'SELECT * FROM users WHERE email = $1';\nconst result = await db.query(query, [email]);\n\n// Using Prisma\nconst user = await prisma.user.findFirst({\n  where: { email }\n});\n\n// Using Sequelize\nconst user = await User.findOne({\n  where: { email }\n});\n```\n\n## Cross-Site Scripting (XSS)\n\n### Types of XSS\n\n**1. Stored XSS**\nAttacker stores malicious script in database.\n\n**2. Reflected XSS**\nMalicious script in URL parameters.\n\n**3. DOM-based XSS**\nClient-side JavaScript vulnerability.\n\n### Example Attack\n\n```javascript\n// Vulnerable: displaying user input directly\napp.get('/profile', (req, res) => {\n  res.send(`\n    \u003cdiv class=\"profile\"\u003e\n      \u003ch1\u003e${req.query.name}\u003c/h1\u003e  \u003c!-- XSS here! --\u003e\n    \u003c/div\u003e\n  `);\n});\n\n// Attacker visits: /profile?name=\u003cscript\u003estealCookies()\u003c/script\u003e\n```\n\n### Prevention\n\n**1. Output Encoding:**\n```javascript\nimport { escapeHtml } from 'lodash';\n\n// Escape HTML entities\nconst safeName = escapeHtml(userInput);\n// \u003cscript\u003e becomes \u0026lt;script\u0026gt;\n```\n\n**2. Content Security Policy:**\n```javascript\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\"],  // No inline scripts\n    styleSrc: [\"'self'\"]\n  }\n}));\n```\n\n**3. React/Vue/Angular automatically escape output**\n```jsx\n// Safe - React escapes by default\nfunction Profile({ name }) {\n  return \u003ch1\u003e{name}\u003c/h1\u003e;  // Even if name contains \u003cscript\u003e\n}\n\n// Dangerous - dangerouslySetInnerHTML\nfunction Dangerous({ html }) {\n  return \u003cdiv dangerouslySetInnerHTML={{ __html: html }} /\u003e;\n}\n```\n\n## Cross-Site Request Forgery (CSRF)\n\n### The Attack\n\nAttacker tricks user's browser into performing unwanted actions.\n\n```html\n\u003c!-- Attacker's website --\u003e\n\u003cform action=\"https://bank.com/transfer\" method=\"POST\"\u003e\n  \u003cinput type=\"hidden\" name=\"to\" value=\"attacker\"\u003e\n  \u003cinput type=\"hidden\" name=\"amount\" value=\"1000\"\u003e\n  \u003cbutton\u003eClick for free money!\u003c/button\u003e\n\u003c/form\u003e\n\n\u003cscript\u003e\n  document.forms[0].submit();  // Auto-submit\n\u003c/script\u003e\n```\n\nIf user is logged into bank.com, the request includes their cookies!\n\n### Prevention\n\n**1. SameSite Cookies (Best Solution):**\n```javascript\nres.cookie('session', token, {\n  sameSite: 'strict'  // or 'lax'\n});\n```\n\n**2. CSRF Tokens:**\n```javascript\nimport csrf from 'csurf';\n\napp.use(csrf({ cookie: true }));\n\n// Include in forms\napp.get('/form', (req, res) => {\n  res.render('form', { csrfToken: req.csrfToken() });\n});\n```\n\n**3. Validate Origin/Referer:**\n```javascript\napp.use((req, res, next) => {\n  const origin = req.headers.origin || req.headers.referer;\n  if (origin \u0026\u0026 !origin.includes('yourdomain.com')) {\n    return res.status(403).send('Invalid origin');\n  }\n  next();\n});\n```\n\n## Insecure Direct Object References (IDOR)\n\n### The Vulnerability\n\nAttacker accesses resources by modifying IDs in requests.\n\n**Vulnerable:**\n```javascript\n// User can change the ID in URL\napp.get('/api/invoices/:id', async (req, res) => {\n  const invoice = await db.getInvoice(req.params.id);\n  res.json(invoice);  // Returns any invoice!\n});\n```\n\n**Fix:**\n```javascript\napp.get('/api/invoices/:id', requireAuth, async (req, res) => {\n  const invoice = await db.getInvoice(req.params.id);\n  \n  // Verify ownership\n  if (invoice.userId !== req.user.id) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  res.json(invoice);\n});\n```\n\n## Security Misconfiguration\n\n### Common Issues\n\n**1. Default Credentials**\n```javascript\n// ❌ Bad\nconst adminPassword = 'admin123';\n\n// ✅ Good\nconst adminPassword = process.env.ADMIN_PASSWORD;\n```\n\n**2. Exposing Stack Traces**\n```javascript\n// ❌ Bad - reveals implementation details\napp.use((err, req, res, next) => {\n  res.status(500).json({ error: err.stack });\n});\n\n// ✅ Good - generic error\napp.use((err, req, res, next) => {\n  console.error(err);  // Log internally\n  res.status(500).json({\n    error: 'Internal server error'\n  });\n});\n```\n\n**3. Missing Security Headers**\n```javascript\n// Always use Helmet\nimport helmet from 'helmet';\napp.use(helmet());\n```\n\n## OWASP Top 10 (2021)\n\n1. **Broken Access Control** - IDOR, privilege escalation\n2. **Cryptographic Failures** - Weak encryption,明文传输\n3. **Injection** - SQL, NoSQL, OS command, LDAP\n4. **Insecure Design** - Missing security controls\n5. **Security Misconfiguration** - Default configs, verbose errors\n6. **Vulnerable Components** - Outdated dependencies\n7. **Authentication Failures** - Weak passwords, session issues\n8. **Data Integrity Failures** - Insecure deserialization\n9. **Logging Failures** - Insufficient monitoring\n10. **SSRF** - Server-Side Request Forgery\n\n## Vulnerability Prevention Checklist\n\n### Input Handling\n- [ ] Validate all input (type, length, format)\n- [ ] Use parameterized queries\n- [ ] Sanitize HTML output\n- [ ] Encode special characters\n- [ ] Validate file uploads\n\n### Authentication\n- [ ] Strong password policies\n- [ ] Multi-factor authentication\n- [ ] Secure session management\n- [ ] Account lockout\n- [ ] Secure password reset\n\n### Authorization\n- [ ] Check ownership on every request\n- [ ] Principle of least privilege\n- [ ] Role-based access control\n- [ ] Deny by default\n\n### Data Protection\n- [ ] Encrypt sensitive data at rest\n- [ ] Use HTTPS everywhere\n- [ ] Secure cookie flags\n- [ ] Hash passwords with bcrypt/Argon2\n\n### Infrastructure\n- [ ] Keep dependencies updated\n- [ ] Security headers (Helmet)\n- [ ] Rate limiting\n- [ ] WAF (Web Application Firewall)\n- [ ] Logging and monitoring\n\n## Quick Reference\n\n```javascript\n// SQL Injection Prevention\nawait db.query('SELECT * FROM users WHERE id = $1', [id]);\n\n// XSS Prevention\nconst safe = escapeHtml(userInput);\n\n// CSRF Prevention\nres.cookie('token', value, { sameSite: 'strict' });\n\n// IDOR Prevention\nif (resource.ownerId !== req.user.id) {\n  return res.status(403).send('Forbidden');\n}\n```\n\n**Remember:**\n- ✅ Never trust user input\n- ✅ Always validate and sanitize\n- ✅ Use parameterized queries\n- ✅ Escape output\n- ✅ Implement defense in depth\n- ✅ Keep dependencies updated\n- ✅ Monitor and log security events\n- ❌ Don't expose sensitive information\n- ❌ Don't rely on client-side validation alone\n- ❌ Don't ignore security updates"
    },
    {
      "id": "auth-advanced-security",
      "moduleId": "auth-security",
      "title": "Advanced Security: 2FA",
      "order": 9,
      "difficulty": "advanced",
      "content": "# Essential to know\n- 2FA = Something you know (password) + Something you have (phone/app)\n- TOTP (Time-based OTP) with apps like Google Authenticator\n- SMS 2FA: less secure (SIM swapping) but more accessible\n- Backup codes for recovery\n\n---\n\n# Two-Factor Authentication (2FA)\n\n## What is 2FA?\n\nTwo-factor authentication adds an extra layer of security by requiring two different types of authentication:\n\n1. **Something you know** - Password\n2. **Something you have** - Phone/app (TOTP) or SMS\n3. **Something you are** - Biometrics (fingerprint, face)\n\nEven if an attacker gets your password, they can't log in without the second factor.\n\n## TOTP (Time-based One-Time Password)\n\n### How TOTP Works\n\n```\n1. User scans QR code with authenticator app\n2. App and server share a secret\n3. Both generate same 6-digit code based on current time\n4. User enters code during login\n5. Server verifies code matches\n```\n\n### Implementation with speakeasy\n\n```bash\nnpm install speakeasy qrcode\n```\n\n```javascript\nimport speakeasy from 'speakeasy';\nimport QRCode from 'qrcode';\n\n// Step 1: Generate secret\napp.post('/auth/2fa/setup', requireAuth, async (req, res) => {\n  // Generate secret\n  const secret = speakeasy.generateSecret({\n    name: 'MyApp',  // App name in authenticator\n    length: 32\n  });\n  \n  // Save temporarily (not activated yet)\n  await db.setTemp2FASecret(req.user.id, secret.base32);\n  \n  // Generate QR code\n  const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url);\n  \n  res.json({\n    secret: secret.base32,  // For manual entry\n    qrCode: qrCodeUrl       // QR code image\n  });\n});\n\n// Step 2: Verify and activate\napp.post('/auth/2fa/verify', requireAuth, async (req, res) => {\n  const { token } = req.body;\n  const secret = await db.getTemp2FASecret(req.user.id);\n  \n  if (!secret) {\n    return res.status(400).json({ error: '2FA setup not initiated' });\n  }\n  \n  // Verify code\n  const verified = speakeasy.totp.verify({\n    secret: secret,\n    encoding: 'base32',\n    token: token,\n    window: 1  // Allow 1 step (30s) time drift\n  });\n  \n  if (verified) {\n    // Activate 2FA\n    await db.enable2FA(req.user.id, secret);\n    \n    // Generate backup codes\n    const backupCodes = generateBackupCodes();\n    await db.saveBackupCodes(req.user.id, backupCodes);\n    \n    res.json({\n      message: '2FA enabled successfully',\n      backupCodes: backupCodes  // Show once!\n    });\n  } else {\n    res.status(400).json({ error: 'Invalid code' });\n  }\n});\n\n// Generate backup codes\nfunction generateBackupCodes() {\n  const codes = [];\n  for (let i = 0; i < 10; i++) {\n    // Format: XXXX-XXXX-XXXX\n    const code = Array(3).fill(0).map(() =>\n      Math.random().toString(36).substring(2, 6).toUpperCase()\n    ).join('-');\n    codes.push(code);\n  }\n  return codes;\n}\n```\n\n### Login with 2FA\n\n```javascript\napp.post('/login', async (req, res) => {\n  const { email, password, twoFactorCode } = req.body;\n  \n  // Step 1: Verify credentials\n  const user = await db.getUserByEmail(email);\n  if (!user || !await bcrypt.compare(password, user.passwordHash)) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Step 2: Check if 2FA enabled\n  if (user.twoFactorEnabled) {\n    // If no 2FA code provided, indicate partial auth\n    if (!twoFactorCode) {\n      return res.json({\n        partialAuth: true,\n        message: '2FA required',\n        userId: user.id\n      });\n    }\n    \n    // Verify 2FA code\n    const verified = speakeasy.totp.verify({\n      secret: user.twoFactorSecret,\n      encoding: 'base32',\n      token: twoFactorCode,\n      window: 1\n    });\n    \n    // Check backup codes\n    if (!verified) {\n      const backupValid = await verifyBackupCode(user.id, twoFactorCode);\n      if (!backupValid) {\n        return res.status(401).json({ error: 'Invalid 2FA code' });\n      }\n    }\n  }\n  \n  // Step 3: Complete authentication\n  const token = generateToken(user);\n  res.json({ token });\n});\n\n// Verify and consume backup code\nasync function verifyBackupCode(userId, code) {\n  const codes = await db.getBackupCodes(userId);\n  const index = codes.findIndex(c => bcrypt.compareSync(code, c.hash));\n  \n  if (index >= 0) {\n    // Remove used code\n    await db.removeBackupCode(userId, codes[index].id);\n    return true;\n  }\n  return false;\n}\n```\n\n## SMS 2FA\n\n### Implementation\n\n```javascript\nimport twilio from 'twilio';\n\nconst twilioClient = twilio(process.env.TWILIO_SID, process.env.TWILIO_TOKEN);\n\n// Send SMS code\napp.post('/auth/2fa/sms/send', requireAuth, async (req, res) => {\n  const code = Math.floor(100000 + Math.random() * 900000).toString();\n  \n  // Save code (expires in 10 minutes)\n  await db.saveSMSCode(req.user.id, {\n    code: await bcrypt.hash(code, 10),\n    expiresAt: Date.now() + 10 * 60 * 1000\n  });\n  \n  // Send SMS\n  await twilioClient.messages.create({\n    body: `Your verification code: ${code}`,\n    from: process.env.TWILIO_PHONE,\n    to: req.user.phoneNumber\n  });\n  \n  res.json({ message: 'Code sent' });\n});\n```\n\n**⚠️ Warning:** SMS 2FA is vulnerable to:\n- SIM swapping attacks\n- SS7 attacks\n- Phishing\n\n**Prefer TOTP apps** (Google Authenticator, Authy) when possible.\n\n## Disabling 2FA\n\n```javascript\napp.post('/auth/2fa/disable', requireAuth, async (req, res) => {\n  const { password, twoFactorCode } = req.body;\n  \n  // Re-authenticate\n  const user = await db.getUserById(req.user.id);\n  if (!await bcrypt.compare(password, user.passwordHash)) {\n    return res.status(401).json({ error: 'Invalid password' });\n  }\n  \n  // Verify 2FA\n  const verified = speakeasy.totp.verify({\n    secret: user.twoFactorSecret,\n    encoding: 'base32',\n    token: twoFactorCode,\n    window: 1\n  });\n  \n  if (!verified) {\n    return res.status(401).json({ error: 'Invalid 2FA code' });\n  }\n  \n  // Disable 2FA\n  await db.disable2FA(req.user.id);\n  \n  res.json({ message: '2FA disabled' });\n});\n```\n\n## Security Considerations\n\n### 1. Protect 2FA Secrets\n\n```javascript\n// Encrypt 2FA secrets in database\nimport crypto from 'crypto';\n\nfunction encryptSecret(secret) {\n  const algorithm = 'aes-256-gcm';\n  const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');\n  const iv = crypto.randomBytes(16);\n  \n  const cipher = crypto.createCipher(algorithm, key);\n  cipher.setAAD(Buffer.from('2fa-secret', 'utf8'));\n  \n  let encrypted = cipher.update(secret, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  const authTag = cipher.getAuthTag();\n  \n  return {\n    encrypted,\n    iv: iv.toString('hex'),\n    authTag: authTag.toString('hex')\n  };\n}\n```\n\n### 2. Rate Limit 2FA Attempts\n\n```javascript\nconst twoFALimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  message: 'Too many 2FA attempts'\n});\n\napp.post('/login', twoFALimiter, loginHandler);\n```\n\n### 3. Backup Codes\n\n- Generate 10 one-time use codes\n- Hash before storing\n- Remove after use\n- Allow regeneration\n- Warn when running low\n\n### 4. Remember Device\n\n```javascript\n// Optional: Remember device for 30 days\napp.post('/login', async (req, res) => {\n  // ... after successful 2FA\n  \n  if (req.body.rememberDevice) {\n    const deviceToken = crypto.randomBytes(32).toString('hex');\n    await db.saveTrustedDevice(req.user.id, {\n      token: await bcrypt.hash(deviceToken, 10),\n      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000\n    });\n    \n    res.cookie('device_token', deviceToken, {\n      httpOnly: true,\n      secure: true,\n      maxAge: 30 * 24 * 60 * 60 * 1000\n    });\n  }\n});\n```\n\n## Quick Reference\n\n```bash\n# Install\nnpm install speakeasy qrcode\n```\n\n```javascript\nimport speakeasy from 'speakeasy';\n\n// Generate secret\nconst secret = speakeasy.generateSecret({ name: 'MyApp' });\n\n// Generate QR code\nconst qrCode = await QRCode.toDataURL(secret.otpauth_url);\n\n// Verify token\nconst verified = speakeasy.totp.verify({\n  secret: userSecret,\n  encoding: 'base32',\n  token: userInput,\n  window: 1\n});\n```\n\n**Remember:**\n- ✅ Encrypt 2FA secrets at rest\n- ✅ Provide backup codes\n- ✅ Rate limit 2FA attempts\n- ✅ Allow users to disable 2FA\n- ✅ Log 2FA events\n- ✅ Prefer TOTP over SMS\n- ❌ Don't store 2FA codes\n- ❌ Don't allow 2FA bypass\n- ❌ Don't show secrets in logs"
    }
  ],
  "exercises": []
}
