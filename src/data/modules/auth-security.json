{
  "module": {
    "id": "auth-security",
    "title": "Advanced Security",
    "description": "Advanced authentication patterns, security best practices, and protecting against vulnerabilities",
    "icon": "Shield",
    "requiredXp": 800,
    "color": "from-red-500 to-pink-600",
    "courseId": "auth-security"
  },
  "lessons": [
    {
      "id": "auth-middleware",
      "moduleId": "auth-security",
      "title": "Auth Middleware & Protected Routes",
      "order": 1,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Middleware checks auth before route handlers\n- Extract and verify token/session\n- Attach user to request object\n- Return 401 Unauthorized if invalid\n\n---\n\n# Auth Middleware & Protected Routes\n\n## What is Middleware?\n\nMiddleware functions are functions that have access to the request object, response object, and the next middleware function in the application's request-response cycle.\n\n```\nRequest → Middleware 1 → Middleware 2 → Route Handler → Response\n              ↓               ↓\n         Check auth       Check role\n```\n\n## Creating Auth Middleware\n\n### Basic Authentication Middleware\n\n```javascript\n// middleware/auth.js\nimport jwt from 'jsonwebtoken';\n\nexport function requireAuth(req, res, next) {\n  // Get token from header\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];  // Bearer TOKEN\n  \n  if (!token) {\n    return res.status(401).json({\n      error: 'Access denied',\n      message: 'No token provided'\n    });\n  }\n  \n  try {\n    // Verify token\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    \n    // Attach user to request\n    req.user = decoded;\n    \n    // Continue to next middleware/route\n    next();\n    \n  } catch (error) {\n    if (error.name === 'TokenExpiredError') {\n      return res.status(401).json({\n        error: 'Token expired',\n        message: 'Please log in again'\n      });\n    }\n    \n    return res.status(403).json({\n      error: 'Invalid token',\n      message: 'Token verification failed'\n    });\n  }\n}\n```\n\n### Session-Based Auth Middleware\n\n```javascript\nexport function requireSession(req, res, next) {\n  if (!req.session.userId) {\n    return res.status(401).json({\n      error: 'Not authenticated',\n      message: 'Please log in'\n    });\n  }\n  \n  // Optionally fetch full user data\n  req.user = {\n    id: req.session.userId,\n    role: req.session.role\n  };\n  \n  next();\n}\n```\n\n## Role-Based Middleware\n\n### Authorization Middleware\n\n```javascript\n// Check if user has required role\nexport function requireRole(...allowedRoles) {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Not authenticated' });\n    }\n    \n    if (!allowedRoles.includes(req.user.role)) {\n      return res.status(403).json({\n        error: 'Forbidden',\n        message: `Role '${req.user.role}' not authorized`\n      });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.delete('/users/:id',\n  requireAuth,\n  requireRole('admin', 'moderator'),\n  deleteUser\n);\n```\n\n### Permission-Based Middleware\n\n```javascript\n// More granular permissions\nexport function requirePermission(permission) {\n  return async (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Not authenticated' });\n    }\n    \n    const userPermissions = await getUserPermissions(req.user.id);\n    \n    if (!userPermissions.includes(permission)) {\n      return res.status(403).json({\n        error: 'Forbidden',\n        message: `Missing permission: ${permission}`\n      });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.post('/posts',\n  requireAuth,\n  requirePermission('posts:create'),\n  createPost\n);\n```\n\n## Combining with Validation\n\n### With Zod Validation\n\n```javascript\nimport { z } from 'zod';\n\n// Validation middleware factory\nfunction validate(schema) {\n  return (req, res, next) => {\n    try {\n      schema.parse(req.body);\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          error: 'Validation failed',\n          details: error.errors\n        });\n      }\n      next(error);\n    }\n  };\n}\n\n// Schemas\nconst createPostSchema = z.object({\n  title: z.string().min(1).max(200),\n  content: z.string().min(1),\n  published: z.boolean().optional()\n});\n\n// Usage - middleware chain\napp.post('/posts',\n  requireAuth,                    // 1. Check auth\n  requirePermission('posts:create'), // 2. Check permission\n  validate(createPostSchema),     // 3. Validate input\n  createPost                      // 4. Handle request\n);\n```\n\n## Resource Ownership\n\n### Verifying Resource Ownership\n\n```javascript\n// Check if user owns the resource\nexport function requireOwnership(getResourceOwner) {\n  return async (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Not authenticated' });\n    }\n    \n    const resourceId = req.params.id;\n    const ownerId = await getResourceOwner(resourceId);\n    \n    // Allow if owner or admin\n    if (req.user.id !== ownerId && req.user.role !== 'admin') {\n      return res.status(403).json({\n        error: 'Forbidden',\n        message: 'You do not own this resource'\n      });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.put('/posts/:id',\n  requireAuth,\n  requireOwnership(async (postId) => {\n    const post = await db.getPost(postId);\n    return post.authorId;\n  }),\n  updatePost\n);\n```\n\n## Error Handling Middleware\n\n### Centralized Error Handler\n\n```javascript\n// Always define last\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  \n  if (err.name === 'UnauthorizedError') {\n    return res.status(401).json({\n      error: 'Unauthorized',\n      message: 'Invalid token'\n    });\n  }\n  \n  if (err.name === 'ValidationError') {\n    return res.status(400).json({\n      error: 'Validation Error',\n      message: err.message\n    });\n  }\n  \n  res.status(500).json({\n    error: 'Internal Server Error',\n    message: process.env.NODE_ENV === 'production'\n      ? 'Something went wrong'\n      : err.message\n  });\n});\n```\n\n## Complete Example\n\n```javascript\nimport express from 'express';\nimport jwt from 'jsonwebtoken';\nimport { z } from 'zod';\n\nconst app = express();\n\n// ===== MIDDLEWARE =====\n\n// Auth middleware\nconst requireAuth = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  if (!token) {\n    return res.status(401).json({ error: 'No token' });\n  }\n  \n  try {\n    req.user = jwt.verify(token, process.env.JWT_SECRET);\n    next();\n  } catch (err) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n};\n\n// Role middleware\nconst requireRole = (...roles) => {\n  return (req, res, next) => {\n    if (!roles.includes(req.user?.role)) {\n      return res.status(403).json({ error: 'Insufficient role' });\n    }\n    next();\n  };\n};\n\n// Validation middleware\nconst validate = (schema) => (req, res, next) => {\n  try {\n    schema.parse(req.body);\n    next();\n  } catch (err) {\n    res.status(400).json({ error: err.errors });\n  }\n};\n\n// ===== ROUTES =====\n\n// Public routes\napp.post('/login', login);\napp.post('/register', register);\n\n// Protected routes\napp.get('/profile', requireAuth, getProfile);\napp.put('/profile', requireAuth, validate(updateProfileSchema), updateProfile);\n\n// Admin routes\napp.get('/admin/users', requireAuth, requireRole('admin'), getAllUsers);\napp.delete('/admin/users/:id', requireAuth, requireRole('admin'), deleteUser);\n\n// User routes with ownership\napp.get('/posts/:id', getPost);  // Public\napp.post('/posts', requireAuth, validate(createPostSchema), createPost);\napp.put('/posts/:id', requireAuth, requireOwnership(getPostOwner), updatePost);\napp.delete('/posts/:id', requireAuth, requireOwnership(getPostOwner), deletePost);\n```\n\n## Testing Middleware\n\n```javascript\n// test/auth.middleware.test.js\nimport { requireAuth } from '../middleware/auth.js';\n\ndescribe('Auth Middleware', () => {\n  it('should reject requests without token', () => {\n    const req = { headers: {} };\n    const res = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn()\n    };\n    const next = jest.fn();\n    \n    requireAuth(req, res, next);\n    \n    expect(res.status).toHaveBeenCalledWith(401);\n    expect(next).not.toHaveBeenCalled();\n  });\n  \n  it('should accept valid token', () => {\n    const token = jwt.sign({ userId: '123' }, process.env.JWT_SECRET);\n    const req = {\n      headers: { authorization: `Bearer ${token}` }\n    };\n    const res = {};\n    const next = jest.fn();\n    \n    requireAuth(req, res, next);\n    \n    expect(req.user).toBeDefined();\n    expect(next).toHaveBeenCalled();\n  });\n});\n```\n\n## Quick Reference\n\n```javascript\n// Basic auth middleware\nfunction requireAuth(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  if (!token) return res.status(401).json({ error: 'No token' });\n  \n  try {\n    req.user = jwt.verify(token, SECRET);\n    next();\n  } catch {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n}\n\n// Role check\nfunction requireRole(...roles) {\n  return (req, res, next) => {\n    if (!roles.includes(req.user?.role)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n    next();\n  };\n}\n\n// Usage\napp.get('/admin', requireAuth, requireRole('admin'), handler);\n```\n\n**Remember:**\n- ✅ Always verify auth before protected routes\n- ✅ Attach user to request for downstream use\n- ✅ Return 401 for missing auth, 403 for insufficient permissions\n- ✅ Chain middleware for complex checks\n- ✅ Test your middleware thoroughly\n- ❌ Don't forget to call next()\n- ❌ Don't expose sensitive error details"
    },
    {
      "id": "auth-security-headers",
      "moduleId": "auth-security",
      "title": "Security Best Practices",
      "order": 2,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- HTTPS everywhere in production\n- HttpOnly, Secure, SameSite cookie flags\n- CSRF protection for cookie-based auth\n- Rate limiting on auth endpoints\n\n---\n\n# Security Best Practices\n\n## HTTPS Everywhere\n\n### Why HTTPS?\n\nHTTPS encrypts all communication between client and server:\n- Prevents man-in-the-middle attacks\n- Protects cookies and tokens\n- Required for modern browser features\n- SEO ranking factor\n\n### Enforcing HTTPS\n\n```javascript\n// Redirect HTTP to HTTPS\napp.use((req, res, next) => {\n  if (process.env.NODE_ENV === 'production' && !req.secure) {\n    return res.redirect(`https://${req.headers.host}${req.url}`);\n  }\n  next();\n});\n\n// Or use a library\nimport helmet from 'helmet';\napp.use(helmet());\n```\n\n## Secure Cookies\n\n### Cookie Flags\n\n```javascript\nres.cookie('sessionId', token, {\n  // Prevent JavaScript access (XSS protection)\n  httpOnly: true,\n  \n  // HTTPS only in production\n  secure: process.env.NODE_ENV === 'production',\n  \n  // SameSite protection (CSRF)\n  sameSite: 'strict',  // 'strict', 'lax', or 'none'\n  \n  // Cookie expiration\n  maxAge: 24 * 60 * 60 * 1000,  // 24 hours\n  \n  // Cookie scope\n  domain: '.example.com',  // Subdomains\n  path: '/'                // URL path\n});\n```\n\n### SameSite Values\n\n- **Strict**: Cookie never sent in cross-site requests (most secure)\n- **Lax**: Cookie sent for top-level navigation GET requests (balanced)\n- **None**: Cookie sent with all requests (requires Secure flag)\n\n## Security Headers with Helmet\n\n```bash\nnpm install helmet\n```\n\n```javascript\nimport helmet from 'helmet';\n\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\", 'https://api.example.com']\n    }\n  },\n  hsts: {\n    maxAge: 31536000,  // 1 year\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'same-origin' }\n}));\n```\n\n**Key headers set by Helmet:**\n- `Content-Security-Policy` - XSS protection\n- `X-Frame-Options` - Clickjacking protection\n- `X-Content-Type-Options` - MIME sniffing protection\n- `Strict-Transport-Security` - HTTPS enforcement\n- `Referrer-Policy` - Privacy protection\n\n## CSRF Protection\n\n### What is CSRF?\n\nCross-Site Request Forgery: Attacker tricks user's browser into performing unwanted actions on a trusted site.\n\n### Protection Methods\n\n**1. SameSite Cookies (Modern)**\n```javascript\n// Already covered above\nsameSite: 'strict'  // or 'lax'\n```\n\n**2. CSRF Tokens (Traditional)**\n```bash\nnpm install csurf\n```\n\n```javascript\nimport csurf from 'csurf';\n\nconst csrfProtection = csurf({\n  cookie: {\n    httpOnly: true,\n    secure: true\n  }\n});\n\n// Apply to all routes\napp.use(csrfProtection);\n\n// Get CSRF token\napp.get('/form', (req, res) => {\n  res.render('form', { csrfToken: req.csrfToken() });\n});\n\n// Form must include token\n// <input type=\"hidden\" name=\"_csrf\" value=\"{{csrfToken}}\">\n```\n\n## Rate Limiting\n\n### Protect Against Brute Force\n\n```bash\nnpm install express-rate-limit\n```\n\n```javascript\nimport rateLimit from 'express-rate-limit';\n\n// Strict limit for auth endpoints\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,  // 15 minutes\n  max: 5,  // 5 attempts per window\n  message: {\n    error: 'Too many attempts',\n    retryAfter: '15 minutes'\n  },\n  standardHeaders: true,\n  legacyHeaders: false\n});\n\n// General API limit\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  message: 'Too many requests from this IP'\n});\n\n// Apply to routes\napp.post('/login', authLimiter, loginHandler);\napp.post('/register', authLimiter, registerHandler);\napp.use('/api/', apiLimiter);\n```\n\n## Account Security\n\n### Account Lockout\n\n```javascript\n// After N failed attempts, lock account\nasync function checkLockout(email) {\n  const user = await db.getUserByEmail(email);\n  \n  if (user.failedAttempts >= 5) {\n    const lockoutTime = 30 * 60 * 1000;  // 30 minutes\n    if (Date.now() - user.lastAttempt < lockoutTime) {\n      throw new Error('Account locked. Try again later.');\n    }\n    // Reset after lockout period\n    await db.resetFailedAttempts(email);\n  }\n}\n\nasync function recordFailedAttempt(email) {\n  await db.incrementFailedAttempts(email, Date.now());\n}\n```\n\n### Password Reset Security\n\n```javascript\n// Generate secure reset token\nimport crypto from 'crypto';\n\nasync function createPasswordReset(email) {\n  const token = crypto.randomBytes(32).toString('hex');\n  const expiresAt = Date.now() + 60 * 60 * 1000;  // 1 hour\n  \n  await db.saveResetToken(email, {\n    token: hashToken(token),  // Hash before storing\n    expiresAt\n  });\n  \n  // Send email with plain token\n  await sendResetEmail(email, token);\n}\n\n// Verify reset token\nasync function verifyResetToken(email, token) {\n  const resetData = await db.getResetToken(email);\n  \n  if (!resetData) throw new Error('Invalid token');\n  if (Date.now() > resetData.expiresAt) {\n    throw new Error('Token expired');\n  }\n  if (!compareToken(token, resetData.token)) {\n    throw new Error('Invalid token');\n  }\n  \n  return true;\n}\n```\n\n## Input Validation\n\n### Always Validate Input\n\n```javascript\nimport { z } from 'zod';\n\nconst loginSchema = z.object({\n  email: z.string().email('Invalid email format'),\n  password: z.string().min(8, 'Password too short')\n});\n\napp.post('/login', async (req, res) => {\n  // Validate before processing\n  const result = loginSchema.safeParse(req.body);\n  \n  if (!result.success) {\n    return res.status(400).json({\n      error: 'Validation failed',\n      details: result.error.errors\n    });\n  }\n  \n  const { email, password } = result.data;\n  // Continue with login...\n});\n```\n\n## Security Checklist\n\n### Pre-Production Checklist\n\n- [ ] HTTPS enabled\n- [ ] Secure cookie flags (httpOnly, secure, sameSite)\n- [ ] Helmet middleware configured\n- [ ] Rate limiting on auth endpoints\n- [ ] CSRF protection\n- [ ] Input validation on all endpoints\n- [ ] SQL injection protection (parameterized queries)\n- [ ] XSS protection (output encoding)\n- [ ] Security headers configured\n- [ ] Error handling (no sensitive info leaked)\n- [ ] Dependencies updated\n- [ ] Secrets in environment variables\n- [ ] Logging and monitoring\n\n## Quick Reference\n\n```javascript\n// Essential security middleware\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\n\n// Helmet for security headers\napp.use(helmet());\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100\n});\napp.use(limiter);\n\n// Secure cookies\nres.cookie('token', value, {\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict',\n  maxAge: 24 * 60 * 60 * 1000\n});\n```\n\n**Remember:**\n- ✅ Always use HTTPS in production\n- ✅ Set all cookie security flags\n- ✅ Implement rate limiting\n- ✅ Use security headers (Helmet)\n- ✅ Validate all input\n- ✅ Protect against CSRF\n- ✅ Implement account lockout\n- ✅ Log security events\n- ❌ Never trust client input\n- ❌ Don't expose sensitive error messages\n- ❌ Don't commit secrets to git"
    },
    {
      "id": "auth-common-vulnerabilities",
      "moduleId": "auth-security",
      "title": "Common Vulnerabilities",
      "order": 3,
      "difficulty": "advanced",
      "content": "# Essential to know\n- SQL injection: use parameterized queries\n- XSS: sanitize output, use CSP\n- CSRF: use tokens or SameSite cookies\n- Always validate and sanitize input\n\n---\n\n# Common Security Vulnerabilities\n\n## SQL Injection\n\n### The Vulnerability\n\nAttacker injects malicious SQL code through user input.\n\n**Vulnerable Code:**\n```javascript\n// ❌ NEVER do this!\nconst query = `SELECT * FROM users WHERE email = '${email}'`;\nawait db.query(query);\n\n// If email is: ' OR '1'='1\n// Query becomes: SELECT * FROM users WHERE email = '' OR '1'='1'\n// Returns ALL users!\n```\n\n**Attacker inputs:**\n- `' OR '1'='1` - Bypass authentication\n- `'; DROP TABLE users; --` - Delete data\n- `' UNION SELECT * FROM passwords --` - Extract data\n\n### Prevention\n\n**✅ Use Parameterized Queries:**\n```javascript\n// Using pg (PostgreSQL)\nconst query = 'SELECT * FROM users WHERE email = $1';\nconst result = await db.query(query, [email]);\n\n// Using Prisma\nconst user = await prisma.user.findFirst({\n  where: { email }\n});\n\n// Using Sequelize\nconst user = await User.findOne({\n  where: { email }\n});\n```\n\n## Cross-Site Scripting (XSS)\n\n### Types of XSS\n\n**1. Stored XSS**\nAttacker stores malicious script in database.\n\n**2. Reflected XSS**\nMalicious script in URL parameters.\n\n**3. DOM-based XSS**\nClient-side JavaScript vulnerability.\n\n### Example Attack\n\n```javascript\n// Vulnerable: displaying user input directly\napp.get('/profile', (req, res) => {\n  res.send(`\n    <div class=\"profile\">\n      <h1>${req.query.name}</h1>  <!-- XSS here! -->\n    </div>\n  `);\n});\n\n// Attacker visits: /profile?name=<script>stealCookies()</script>\n```\n\n### Prevention\n\n**1. Output Encoding:**\n```javascript\nimport { escapeHtml } from 'lodash';\n\n// Escape HTML entities\nconst safeName = escapeHtml(userInput);\n// <script> becomes &lt;script&gt;\n```\n\n**2. Content Security Policy:**\n```javascript\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\"],  // No inline scripts\n    styleSrc: [\"'self'\"]\n  }\n}));\n```\n\n**3. React/Vue/Angular automatically escape output**\n```jsx\n// Safe - React escapes by default\nfunction Profile({ name }) {\n  return <h1>{name}</h1>;  // Even if name contains <script>\n}\n\n// Dangerous - dangerouslySetInnerHTML\nfunction Dangerous({ html }) {\n  return <div dangerouslySetInnerHTML={{ __html: html }} />;\n}\n```\n\n## Cross-Site Request Forgery (CSRF)\n\n### The Attack\n\nAttacker tricks user's browser into performing unwanted actions.\n\n```html\n<!-- Attacker's website -->\n<form action=\"https://bank.com/transfer\" method=\"POST\">\n  <input type=\"hidden\" name=\"to\" value=\"attacker\">\n  <input type=\"hidden\" name=\"amount\" value=\"1000\">\n  <button>Click for free money!</button>\n</form>\n\n<script>\n  document.forms[0].submit();  // Auto-submit\n</script>\n```\n\nIf user is logged into bank.com, the request includes their cookies!\n\n### Prevention\n\n**1. SameSite Cookies (Best Solution):**\n```javascript\nres.cookie('session', token, {\n  sameSite: 'strict'  // or 'lax'\n});\n```\n\n**2. CSRF Tokens:**\n```javascript\nimport csrf from 'csurf';\n\napp.use(csrf({ cookie: true }));\n\n// Include in forms\napp.get('/form', (req, res) => {\n  res.render('form', { csrfToken: req.csrfToken() });\n});\n```\n\n**3. Validate Origin/Referer:**\n```javascript\napp.use((req, res, next) => {\n  const origin = req.headers.origin || req.headers.referer;\n  if (origin && !origin.includes('yourdomain.com')) {\n    return res.status(403).send('Invalid origin');\n  }\n  next();\n});\n```\n\n## Insecure Direct Object References (IDOR)\n\n### The Vulnerability\n\nAttacker accesses resources by modifying IDs in requests.\n\n**Vulnerable:**\n```javascript\n// User can change the ID in URL\napp.get('/api/invoices/:id', async (req, res) => {\n  const invoice = await db.getInvoice(req.params.id);\n  res.json(invoice);  // Returns any invoice!\n});\n```\n\n**Fix:**\n```javascript\napp.get('/api/invoices/:id', requireAuth, async (req, res) => {\n  const invoice = await db.getInvoice(req.params.id);\n  \n  // Verify ownership\n  if (invoice.userId !== req.user.id) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  res.json(invoice);\n});\n```\n\n## Security Misconfiguration\n\n### Common Issues\n\n**1. Default Credentials**\n```javascript\n// ❌ Bad\nconst adminPassword = 'admin123';\n\n// ✅ Good\nconst adminPassword = process.env.ADMIN_PASSWORD;\n```\n\n**2. Exposing Stack Traces**\n```javascript\n// ❌ Bad - reveals implementation details\napp.use((err, req, res, next) => {\n  res.status(500).json({ error: err.stack });\n});\n\n// ✅ Good - generic error\napp.use((err, req, res, next) => {\n  console.error(err);  // Log internally\n  res.status(500).json({\n    error: 'Internal server error'\n  });\n});\n```\n\n**3. Missing Security Headers**\n```javascript\n// Always use Helmet\nimport helmet from 'helmet';\napp.use(helmet());\n```\n\n## OWASP Top 10 (2021)\n\n1. **Broken Access Control** - IDOR, privilege escalation\n2. **Cryptographic Failures** - Weak encryption,明文传输\n3. **Injection** - SQL, NoSQL, OS command, LDAP\n4. **Insecure Design** - Missing security controls\n5. **Security Misconfiguration** - Default configs, verbose errors\n6. **Vulnerable Components** - Outdated dependencies\n7. **Authentication Failures** - Weak passwords, session issues\n8. **Data Integrity Failures** - Insecure deserialization\n9. **Logging Failures** - Insufficient monitoring\n10. **SSRF** - Server-Side Request Forgery\n\n## Vulnerability Prevention Checklist\n\n### Input Handling\n- [ ] Validate all input (type, length, format)\n- [ ] Use parameterized queries\n- [ ] Sanitize HTML output\n- [ ] Encode special characters\n- [ ] Validate file uploads\n\n### Authentication\n- [ ] Strong password policies\n- [ ] Multi-factor authentication\n- [ ] Secure session management\n- [ ] Account lockout\n- [ ] Secure password reset\n\n### Authorization\n- [ ] Check ownership on every request\n- [ ] Principle of least privilege\n- [ ] Role-based access control\n- [ ] Deny by default\n\n### Data Protection\n- [ ] Encrypt sensitive data at rest\n- [ ] Use HTTPS everywhere\n- [ ] Secure cookie flags\n- [ ] Hash passwords with bcrypt/Argon2\n\n### Infrastructure\n- [ ] Keep dependencies updated\n- [ ] Security headers (Helmet)\n- [ ] Rate limiting\n- [ ] WAF (Web Application Firewall)\n- [ ] Logging and monitoring\n\n## Quick Reference\n\n```javascript\n// SQL Injection Prevention\nawait db.query('SELECT * FROM users WHERE id = $1', [id]);\n\n// XSS Prevention\nconst safe = escapeHtml(userInput);\n\n// CSRF Prevention\nres.cookie('token', value, { sameSite: 'strict' });\n\n// IDOR Prevention\nif (resource.ownerId !== req.user.id) {\n  return res.status(403).send('Forbidden');\n}\n```\n\n**Remember:**\n- ✅ Never trust user input\n- ✅ Always validate and sanitize\n- ✅ Use parameterized queries\n- ✅ Escape output\n- ✅ Implement defense in depth\n- ✅ Keep dependencies updated\n- ✅ Monitor and log security events\n- ❌ Don't expose sensitive information\n- ❌ Don't rely on client-side validation alone\n- ❌ Don't ignore security updates"
    },
    {
      "id": "auth-advanced-security",
      "moduleId": "auth-security",
      "title": "Advanced Security: 2FA",
      "order": 4,
      "difficulty": "advanced",
      "content": "# Essential to know\n- 2FA = Something you know (password) + Something you have (phone/app)\n- TOTP (Time-based OTP) with apps like Google Authenticator\n- SMS 2FA: less secure (SIM swapping) but more accessible\n- Backup codes for recovery\n\n---\n\n# Two-Factor Authentication (2FA)\n\n## What is 2FA?\n\nTwo-factor authentication adds an extra layer of security by requiring two different types of authentication:\n\n1. **Something you know** - Password\n2. **Something you have** - Phone/app (TOTP) or SMS\n3. **Something you are** - Biometrics (fingerprint, face)\n\nEven if an attacker gets your password, they can't log in without the second factor.\n\n## TOTP (Time-based One-Time Password)\n\n### How TOTP Works\n\n```\n1. User scans QR code with authenticator app\n2. App and server share a secret\n3. Both generate same 6-digit code based on current time\n4. User enters code during login\n5. Server verifies code matches\n```\n\n### Implementation with speakeasy\n\n```bash\nnpm install speakeasy qrcode\n```\n\n```javascript\nimport speakeasy from 'speakeasy';\nimport QRCode from 'qrcode';\n\n// Step 1: Generate secret\napp.post('/auth/2fa/setup', requireAuth, async (req, res) => {\n  // Generate secret\n  const secret = speakeasy.generateSecret({\n    name: 'MyApp',  // App name in authenticator\n    length: 32\n  });\n  \n  // Save temporarily (not activated yet)\n  await db.setTemp2FASecret(req.user.id, secret.base32);\n  \n  // Generate QR code\n  const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url);\n  \n  res.json({\n    secret: secret.base32,  // For manual entry\n    qrCode: qrCodeUrl       // QR code image\n  });\n});\n\n// Step 2: Verify and activate\napp.post('/auth/2fa/verify', requireAuth, async (req, res) => {\n  const { token } = req.body;\n  const secret = await db.getTemp2FASecret(req.user.id);\n  \n  if (!secret) {\n    return res.status(400).json({ error: '2FA setup not initiated' });\n  }\n  \n  // Verify code\n  const verified = speakeasy.totp.verify({\n    secret: secret,\n    encoding: 'base32',\n    token: token,\n    window: 1  // Allow 1 step (30s) time drift\n  });\n  \n  if (verified) {\n    // Activate 2FA\n    await db.enable2FA(req.user.id, secret);\n    \n    // Generate backup codes\n    const backupCodes = generateBackupCodes();\n    await db.saveBackupCodes(req.user.id, backupCodes);\n    \n    res.json({\n      message: '2FA enabled successfully',\n      backupCodes: backupCodes  // Show once!\n    });\n  } else {\n    res.status(400).json({ error: 'Invalid code' });\n  }\n});\n\n// Generate backup codes\nfunction generateBackupCodes() {\n  const codes = [];\n  for (let i = 0; i < 10; i++) {\n    // Format: XXXX-XXXX-XXXX\n    const code = Array(3).fill(0).map(() =>\n      Math.random().toString(36).substring(2, 6).toUpperCase()\n    ).join('-');\n    codes.push(code);\n  }\n  return codes;\n}\n```\n\n### Login with 2FA\n\n```javascript\napp.post('/login', async (req, res) => {\n  const { email, password, twoFactorCode } = req.body;\n  \n  // Step 1: Verify credentials\n  const user = await db.getUserByEmail(email);\n  if (!user || !await bcrypt.compare(password, user.passwordHash)) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  // Step 2: Check if 2FA enabled\n  if (user.twoFactorEnabled) {\n    // If no 2FA code provided, indicate partial auth\n    if (!twoFactorCode) {\n      return res.json({\n        partialAuth: true,\n        message: '2FA required',\n        userId: user.id\n      });\n    }\n    \n    // Verify 2FA code\n    const verified = speakeasy.totp.verify({\n      secret: user.twoFactorSecret,\n      encoding: 'base32',\n      token: twoFactorCode,\n      window: 1\n    });\n    \n    // Check backup codes\n    if (!verified) {\n      const backupValid = await verifyBackupCode(user.id, twoFactorCode);\n      if (!backupValid) {\n        return res.status(401).json({ error: 'Invalid 2FA code' });\n      }\n    }\n  }\n  \n  // Step 3: Complete authentication\n  const token = generateToken(user);\n  res.json({ token });\n});\n\n// Verify and consume backup code\nasync function verifyBackupCode(userId, code) {\n  const codes = await db.getBackupCodes(userId);\n  const index = codes.findIndex(c => bcrypt.compareSync(code, c.hash));\n  \n  if (index >= 0) {\n    // Remove used code\n    await db.removeBackupCode(userId, codes[index].id);\n    return true;\n  }\n  return false;\n}\n```\n\n## SMS 2FA\n\n### Implementation\n\n```javascript\nimport twilio from 'twilio';\n\nconst twilioClient = twilio(process.env.TWILIO_SID, process.env.TWILIO_TOKEN);\n\n// Send SMS code\napp.post('/auth/2fa/sms/send', requireAuth, async (req, res) => {\n  const code = Math.floor(100000 + Math.random() * 900000).toString();\n  \n  // Save code (expires in 10 minutes)\n  await db.saveSMSCode(req.user.id, {\n    code: await bcrypt.hash(code, 10),\n    expiresAt: Date.now() + 10 * 60 * 1000\n  });\n  \n  // Send SMS\n  await twilioClient.messages.create({\n    body: `Your verification code: ${code}`,\n    from: process.env.TWILIO_PHONE,\n    to: req.user.phoneNumber\n  });\n  \n  res.json({ message: 'Code sent' });\n});\n```\n\n**⚠️ Warning:** SMS 2FA is vulnerable to:\n- SIM swapping attacks\n- SS7 attacks\n- Phishing\n\n**Prefer TOTP apps** (Google Authenticator, Authy) when possible.\n\n## Disabling 2FA\n\n```javascript\napp.post('/auth/2fa/disable', requireAuth, async (req, res) => {\n  const { password, twoFactorCode } = req.body;\n  \n  // Re-authenticate\n  const user = await db.getUserById(req.user.id);\n  if (!await bcrypt.compare(password, user.passwordHash)) {\n    return res.status(401).json({ error: 'Invalid password' });\n  }\n  \n  // Verify 2FA\n  const verified = speakeasy.totp.verify({\n    secret: user.twoFactorSecret,\n    encoding: 'base32',\n    token: twoFactorCode,\n    window: 1\n  });\n  \n  if (!verified) {\n    return res.status(401).json({ error: 'Invalid 2FA code' });\n  }\n  \n  // Disable 2FA\n  await db.disable2FA(req.user.id);\n  \n  res.json({ message: '2FA disabled' });\n});\n```\n\n## Security Considerations\n\n### 1. Protect 2FA Secrets\n\n```javascript\n// Encrypt 2FA secrets in database\nimport crypto from 'crypto';\n\nfunction encryptSecret(secret) {\n  const algorithm = 'aes-256-gcm';\n  const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');\n  const iv = crypto.randomBytes(16);\n  \n  const cipher = crypto.createCipher(algorithm, key);\n  cipher.setAAD(Buffer.from('2fa-secret', 'utf8'));\n  \n  let encrypted = cipher.update(secret, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  const authTag = cipher.getAuthTag();\n  \n  return {\n    encrypted,\n    iv: iv.toString('hex'),\n    authTag: authTag.toString('hex')\n  };\n}\n```\n\n### 2. Rate Limit 2FA Attempts\n\n```javascript\nconst twoFALimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  message: 'Too many 2FA attempts'\n});\n\napp.post('/login', twoFALimiter, loginHandler);\n```\n\n### 3. Backup Codes\n\n- Generate 10 one-time use codes\n- Hash before storing\n- Remove after use\n- Allow regeneration\n- Warn when running low\n\n### 4. Remember Device\n\n```javascript\n// Optional: Remember device for 30 days\napp.post('/login', async (req, res) => {\n  // ... after successful 2FA\n  \n  if (req.body.rememberDevice) {\n    const deviceToken = crypto.randomBytes(32).toString('hex');\n    await db.saveTrustedDevice(req.user.id, {\n      token: await bcrypt.hash(deviceToken, 10),\n      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000\n    });\n    \n    res.cookie('device_token', deviceToken, {\n      httpOnly: true,\n      secure: true,\n      maxAge: 30 * 24 * 60 * 60 * 1000\n    });\n  }\n});\n```\n\n## Quick Reference\n\n```bash\n# Install\nnpm install speakeasy qrcode\n```\n\n```javascript\nimport speakeasy from 'speakeasy';\n\n// Generate secret\nconst secret = speakeasy.generateSecret({ name: 'MyApp' });\n\n// Generate QR code\nconst qrCode = await QRCode.toDataURL(secret.otpauth_url);\n\n// Verify token\nconst verified = speakeasy.totp.verify({\n  secret: userSecret,\n  encoding: 'base32',\n  token: userInput,\n  window: 1\n});\n```\n\n**Remember:**\n- ✅ Encrypt 2FA secrets at rest\n- ✅ Provide backup codes\n- ✅ Rate limit 2FA attempts\n- ✅ Allow users to disable 2FA\n- ✅ Log 2FA events\n- ✅ Prefer TOTP over SMS\n- ❌ Don't store 2FA codes\n- ❌ Don't allow 2FA bypass\n- ❌ Don't show secrets in logs"
    }
  ],
  "exercises": []
}
