{
  "module": {
    "id": "terminal-cli",
    "title": "Terminal & CLI",
    "description": "Master the command line interface for efficient development",
    "icon": "Terminal",
    "requiredXp": 0,
    "color": "from-gray-600 to-gray-800",
    "courseId": "internet-tools"
  },
  "lessons": [
    {
      "id": "cli-intro",
      "moduleId": "terminal-cli",
      "title": "Why Use the Terminal?",
      "order": 1,
      "difficulty": "beginner",
      "content": "# Essential to know\n- Terminal gives direct access to your computer\n- Faster than GUIs for many tasks\n- Essential for development workflows\n- Same commands work across projects\n\n---\n\n# Why Use the Terminal?\n\n## The Power of the Command Line\n\nAs a developer, the terminal (or command line interface) is one of your most powerful tools. While graphical user interfaces (GUIs) are great for visual tasks, the command line excels at automation, precision, and speed.\n\n### Terminal vs GUI\n\n**Terminal advantages:**\n- **Speed**: Navigate and operate faster without mouse movements\n- **Precision**: Exact control over operations\n- **Automation**: Script repetitive tasks\n- **Remote access**: Connect to servers anywhere\n- **Consistency**: Same commands work on any system\n- **History**: Every command is logged and searchable\n\n### What is a Shell?\n\nThe terminal is just the window. The **shell** is the program that interprets your commands.\n\n**Popular shells:**\n- **Bash** (Bourne Again Shell): Default on Linux, older macOS\n- **Zsh** (Z Shell): Modern default on macOS, highly customizable\n- **Fish**: User-friendly with great autocomplete\n- **PowerShell**: Windows native, cross-platform\n\n### Terminal Emulators\n\nThe application that displays your terminal window:\n\n**Cross-platform:**\n- VS Code integrated terminal\n- Hyper\n- Alacritty (fast, minimal)\n\n**macOS:**\n- Terminal.app (built-in)\n- iTerm2 (popular alternative)\n\n**Windows:**\n- Windows Terminal (modern)\n- PowerShell\n\n**Linux:**\n- GNOME Terminal\n- Konsole\n- xterm\n\n## Why Developers Use CLI\n\n### 1. Version Control (Git)\n```bash\ngit status\ngit commit -m \"Fix bug\"\ngit push origin main\n```\n\n### 2. Package Management\n```bash\nnpm install express\npip install requests\ncargo build\n```\n\n### 3. Build Tools\n```bash\nnpm run build\nvite dev\ndocker compose up\n```\n\n### 4. Server Management\n```bash\nssh user@server.com\nls /var/log\nsystemctl restart nginx\n```\n\n### 5. Development Servers\n```bash\ncd my-project\nnpm run dev\n```\n\n## Common Fears (and Why They're Overblown)\n\n**❌ \"I'll break something\"**\n✅ Most commands just read information. Dangerous operations (like `rm -rf`) require explicit flags.\n\n**❌ \"I have to memorize everything\"**\n✅ Tab completion helps, and you can always look up commands.\n\n**❌ \"It's too hard\"**\n✅ Start with a few basic commands. Muscle memory develops quickly.\n\n## Your First Commands\n\n```bash\n# Show current directory\npwd\n\n# List files\nls\n\n# Change directory\ncd Documents\n\n# Clear screen\nclear\n```\n\nThe terminal becomes second nature with practice. Every professional developer uses it daily."
    },
    {
      "id": "cli-navigation",
      "moduleId": "terminal-cli",
      "title": "Navigating the File System",
      "order": 2,
      "difficulty": "beginner",
      "content": "# Essential to know\n- pwd shows current directory\n- ls lists files and folders\n- cd changes directory\n- Paths: absolute (/Users/...) vs relative (./folder)\n\n---\n\n# Navigating the File System\n\n## Understanding Your Location\n\nBefore you can work with files, you need to know where you are and how to move around.\n\n### pwd - Print Working Directory\n\nShows your current location in the filesystem:\n\n```bash\n$ pwd\n/Users/john/Documents\n```\n\nThis is your \"home base\" - all relative paths start from here.\n\n## Listing Files\n\n### ls - List Directory Contents\n\nBasic listing:\n```bash\n$ ls\nDocuments Downloads Pictures Projects\n```\n\n**Useful flags:**\n\n```bash\n# Detailed view (long format)\n$ ls -l\ntotal 8\ndrwxr-xr-x 2 john staff 64 Jan 10 09:00 Documents\ndrwxr-xr-x 2 john staff 64 Jan 10 09:00 Downloads\n```\n\n```bash\n# Show hidden files (files starting with .)\n$ ls -a\n. .. .bashrc Documents Downloads\n```\n\n```bash\n# Combine flags: detailed + hidden + human-readable sizes\n$ ls -lah\ndrwxr-xr-x 12 john staff 384B Jan 10 09:00 .\ndrwxr-xr-x  6 john staff 192B Jan 10 08:00 ..\n-rw-r--r--  1 john staff 2.1K Jan 10 09:00 .bashrc\ndrwxr-xr-x  2 john staff  64B Jan 10 09:00 Documents\n```\n\n**Common ls flags:**\n- `-l`: Long format (permissions, owner, size, date)\n- `-a`: Show all files (including hidden)\n- `-h`: Human-readable sizes (K, M, G instead of bytes)\n- `-t`: Sort by modification time\n- `-r`: Reverse order\n\n## Changing Directories\n\n### cd - Change Directory\n\n```bash\n# Go into a folder\ncd Documents\n\n# Go up one level\ncd ..\n\n# Go to home directory\ncd ~\n# or just\ncd\n\n# Go to previous directory\ncd -\n\n# Go to specific path\ncd /Users/john/Documents/Projects\n```\n\n## Path Types\n\n### Absolute Paths\nStart from the root of the filesystem:\n\n```bash\ncd /Users/john/Documents\ncd /etc/nginx\ncd /var/log\n```\n\n**Always works** regardless of where you are.\n\n### Relative Paths\nStart from your current location:\n\n```bash\n# Current directory\ncd ./projects    # or just: cd projects\n\n# Parent directory\ncd ..\ncd ../sibling-folder\n\n# Multiple levels up\ncd ../../..\n```\n\n## Shortcuts and Tips\n\n### Tab Completion\nPress `Tab` to autocomplete:\n\n```bash\ncd Doc<Tab>    # Becomes: cd Documents\ncd ~/P<Tab>    # Shows: Pictures/ Projects/\n```\n\nPress Tab twice to see all matches.\n\n### Special Directories\n\n| Symbol | Meaning |\n|--------|---------|\n| `.` | Current directory |\n| `..` | Parent directory |\n| `~` | Home directory |\n| `-` | Previous directory |\n| `/` | Root directory |\n\n### Clear the Screen\n\n```bash\nclear\n# or press Ctrl+L\n```\n\n## Practice Session\n\n```bash\n# 1. See where you are\npwd\n\n# 2. List files\nls\n\n# 3. Go to Documents\ncd Documents\n\n# 4. List with details\nls -la\n\n# 5. Go back home\ncd ~\n\n# 6. Check the full path again\npwd\n```\n\n## Quick Reference\n\n```bash\npwd          # Where am I?\nls           # What's here?\nls -la       # What's here (including hidden)?\ncd folder    # Go into folder\ncd ..        # Go up\ncd ~         # Go home\ncd -         # Go back\nclear        # Clean screen\n```"
    },
    {
      "id": "cli-files",
      "moduleId": "terminal-cli",
      "title": "Working with Files",
      "order": 3,
      "difficulty": "beginner",
      "content": "# Essential to know\n- touch creates files, mkdir creates folders\n- cp copies, mv moves/renames\n- rm removes (careful! no trash)\n- cat, less, head, tail to view files\n\n---\n\n# Working with Files and Directories\n\n## Creating Files and Folders\n\n### touch - Create Empty Files\n\n```bash\n# Create a single file\ntouch myfile.txt\n\n# Create multiple files at once\ntouch file1.txt file2.txt file3.txt\n\n# Update timestamp of existing file\ntouch existing-file.txt\n```\n\n### mkdir - Make Directory\n\n```bash\n# Create a directory\nmkdir my-folder\n\n# Create parent directories as needed\nmkdir -p projects/web/app/src\n```\n\n**The -p flag** (parents) creates all necessary directories in the path.\n\n## Copying Files\n\n### cp - Copy\n\n```bash\n# Copy a file\ncp source.txt destination.txt\n\n# Copy to a directory\ncp file.txt Documents/\n\n# Copy a directory (recursive)\ncp -r my-folder/ backup-folder/\n\n# Copy multiple files\ncp *.txt Documents/\n```\n\n**Common cp flags:**\n- `-r`: Recursive (for directories)\n- `-i`: Interactive (prompt before overwriting)\n- `-v`: Verbose (show what's being copied)\n\n## Moving and Renaming\n\n### mv - Move (also used to rename)\n\n```bash\n# Rename a file\nmv oldname.txt newname.txt\n\n# Move file to directory\nmv file.txt Documents/\n\n# Move and rename\nmv file.txt Documents/newname.txt\n\n# Move a directory\nmv my-folder/ /path/to/destination/\n\n# Move multiple files\nmv *.txt Documents/\n```\n\n## Removing Files and Directories\n\n### rm - Remove (Permanent!)\n\n**⚠️ WARNING: rm permanently deletes. No trash/recycle bin!**\n\n```bash\n# Remove a file\nrm file.txt\n\n# Remove multiple files\nrm file1.txt file2.txt\n\n# Remove a directory (must be empty)\nrmdir empty-folder\n\n# Remove directory and contents (recursive)\nrm -r my-folder/\n\n# Force remove without prompts (be extra careful!)\nrm -rf my-folder/\n```\n\n**Safety tip**: Use `-i` flag for interactive mode:\n```bash\nrm -i *.txt\n# Asks: remove file1.txt? y\n# Asks: remove file2.txt? n\n```\n\n## Viewing File Contents\n\n### cat - Concatenate and Print\n\n```bash\n# Display entire file\ncat myfile.txt\n\n# Display multiple files\ncat file1.txt file2.txt\n\n# Create file with content\ncat > newfile.txt\nThis is line 1\nThis is line 2\n^D  (Ctrl+D to save)\n```\n\n**Good for**: Small files\n**Bad for**: Large files (scrolls past too fast)\n\n### less - View Files Page by Page\n\n```bash\nless large-file.txt\n```\n\n**Navigation in less:**\n- `Space` or `f`: Next page\n- `b`: Previous page\n- `/pattern`: Search forward\n- `n`: Next search result\n- `q`: Quit\n\n### head - View Beginning of File\n\n```bash\n# First 10 lines (default)\nhead myfile.txt\n\n# First 20 lines\nhead -n 20 myfile.txt\n```\n\n### tail - View End of File\n\n```bash\n# Last 10 lines (default)\ntail myfile.txt\n\n# Last 20 lines\ntail -n 20 myfile.txt\n\n# Follow file as it grows (great for logs!)\ntail -f /var/log/nginx/access.log\n```\n\n## Wildcards (Globbing)\n\nSpecial characters that match patterns:\n\n### * - Asterisk (matches anything)\n\n```bash\n# All files\nls *\n\n# All text files\nls *.txt\n\n# All files starting with 'data'\nls data*\n\n# Copy all JavaScript files\ncp *.js backup/\n```\n\n### ? - Question Mark (matches one character)\n\n```bash\n# Matches file1.txt, file2.txt but not file10.txt\nls file?.txt\n```\n\n### [] - Character Class\n\n```bash\n# Matches file1.txt, file2.txt, file3.txt\nls file[123].txt\n\n# Matches filea.txt, fileb.txt, filec.txt\nls file[abc].txt\n\n# Matches any digit\nls file[0-9].txt\n```\n\n## Practice Session\n\n```bash\n# 1. Create a directory structure\nmkdir -p practice/files\n\n# 2. Create some files\ntouch practice/file1.txt practice/file2.txt\ntouch practice/files/data.json\n\n# 3. List what you created\nls -la practice/\n\n# 4. Copy files\ncp practice/file1.txt practice/backup.txt\n\n# 5. View content (even though empty)\ncat practice/file1.txt\n\n# 6. Clean up\nrm -r practice/\n```\n\n## Quick Reference\n\n```bash\n# Creating\ntouch file.txt           # Create file\nmkdir folder             # Create directory\nmkdir -p a/b/c           # Create nested directories\n\n# Copying\ncp file.txt dest.txt     # Copy file\ncp -r folder/ dest/      # Copy directory\n\n# Moving/Renaming\nmv old.txt new.txt       # Rename\nmv file.txt folder/      # Move\n\n# Removing\nrm file.txt              # Delete file\nrm -r folder/            # Delete directory\nrm -rf folder/           # Force delete (DANGEROUS)\n\n# Viewing\ncat file.txt             # Show entire file\nless file.txt            # Page through file\nhead file.txt            # First 10 lines\ntail file.txt            # Last 10 lines\ntail -f log.txt          # Watch file grow\n\n# Wildcards\nls *.txt                 # All .txt files\nls file?.txt             # Single character match\nls file[1-3].txt         # Range match\n```"
    },
    {
      "id": "cli-permissions",
      "moduleId": "terminal-cli",
      "title": "File Permissions",
      "order": 4,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Three permissions: read (r), write (w), execute (x)\n- Three groups: owner, group, others\n- chmod changes permissions\n- sudo runs as administrator\n\n---\n\n# File Permissions\n\n## Understanding Permissions\n\nOn Unix-like systems (Linux, macOS), every file and directory has permissions that control who can read, write, or execute it.\n\n### Reading Permissions with ls -l\n\n```bash\n$ ls -l\n-rw-r--r-- 1 john staff 1234 Jan 10 09:00 file.txt\ndrwxr-xr-x 2 john staff   64 Jan 10 09:00 folder\n```\n\n**Breaking down `-rw-r--r--`:**\n\n```\n- rw- r-- r--\n│  │   │   │\n│  │   │   └── Others permissions\n│  │   └────── Group permissions\n│  └────────── Owner permissions\n└───────────── File type (- = file, d = directory)\n\n\nPermission characters:\nr = read (4)\nw = write (2)\nx = execute (1)\n- = no permission (0)\n```\n\n## The Three Permission Types\n\n### Read (r)\n- **Files**: Can view contents\n- **Directories**: Can list contents\n\n### Write (w)\n- **Files**: Can modify/delete contents\n- **Directories**: Can add/remove files\n\n### Execute (x)\n- **Files**: Can run as a program\n- **Directories**: Can enter/access\n\n## The Three User Classes\n\n1. **Owner (u)**: The file's creator\n2. **Group (g)**: Users in the file's group\n3. **Others (o)**: Everyone else\n\n## Changing Permissions with chmod\n\n### Symbolic Mode (Text)\n\n```bash\n# Add execute permission for owner\nchmod u+x script.sh\n\n# Remove write permission for others\nchmod o-w file.txt\n\n# Add read permission for group\nchmod g+r file.txt\n\n# Set exact permissions\nchmod u=rwx,g=rx,o=r file.txt\n\n# Add execute for everyone\nchmod a+x script.sh  # a = all (ugo)\n```\n\n**Letters:**\n- `u` = user (owner)\n- `g` = group\n- `o` = others\n- `a` = all\n\n**Operators:**\n- `+` = add permission\n- `-` = remove permission\n- `=` = set exact permission\n\n### Numeric Mode (Octal)\n\nEach permission has a number:\n- Read (r) = 4\n- Write (w) = 2\n- Execute (x) = 1\n- No permission = 0\n\nAdd them up for each user class:\n\n```bash\n# rwxr-xr-x\n#  7  5  5\nchmod 755 script.sh\n\n# rw-r--r--\n#  6  4  4\nchmod 644 file.txt\n\n# rwx------\n#  7  0  0\nchmod 700 secret.txt\n```\n\n**Common numeric permissions:**\n- `644` (rw-r--r--): Regular files\n- `755` (rwxr-xr-x): Directories and executables\n- `600` (rw-------): Private files\n- `777` (rwxrwxrwx): Everyone can do everything (rarely needed!)\n\n## Changing Ownership\n\n### chown - Change Owner\n\n```bash\n# Change owner\nsudo chown alice file.txt\n\n# Change owner and group\nsudo chown alice:developers file.txt\n\n# Change recursively\nsudo chown -R alice:alice /path/to/folder\n```\n\n### chgrp - Change Group\n\n```bash\n# Change group\nsudo chgrp developers file.txt\n```\n\n## The sudo Command\n\n**sudo** = \"superuser do\" - run commands as administrator\n\n```bash\n# Install software (needs admin)\nsudo apt install nginx\n\n# Edit system files\nsudo nano /etc/hosts\n\n# Change system permissions\nsudo chmod 644 /etc/config.txt\n```\n\n**When to use sudo:**\n- ✅ Installing system-wide software\n- ✅ Modifying system files\n- ✅ Managing services\n- ❌ Working in your home directory\n- ❌ Editing your own files\n\n## Practical Examples\n\n### Making a Script Executable\n\n```bash\n# Create a script\necho '#!/bin/bash\necho \"Hello World!\"' > hello.sh\n\n# Make it executable\nchmod +x hello.sh\n\n# Run it\n./hello.sh\n```\n\n### Securing SSH Keys\n\n```bash\n# SSH keys should be private\nchmod 600 ~/.ssh/id_rsa\n\n# SSH directory\nchmod 700 ~/.ssh\n```\n\n### Website Permissions\n\n```bash\n# Web files: readable by all, writable by owner\nchmod 644 *.html *.css *.js\n\n# Web directories: executable by all\nchmod 755 images/ css/ js/\n```\n\n## Practice Session\n\n```bash\n# 1. Check current permissions\nls -la ~\n\n# 2. Create a file and check its permissions\ntouch test.txt\nls -l test.txt  # Usually 644\n\n# 3. Make it executable\nchmod +x test.txt\nls -l test.txt  # Now 755\n\n# 4. Make it private\nchmod 600 test.txt\nls -l test.txt  # Now 600\n\n# 5. Create a script\necho '#!/bin/bash\necho \"It works!\"' > myscript.sh\nchmod +x myscript.sh\n./myscript.sh\n\n# 6. Clean up\nrm test.txt myscript.sh\n```\n\n## Quick Reference\n\n```bash\n# View permissions\nls -l                    # List with permissions\nls -la                   # Include hidden files\n\n# Change permissions (symbolic)\nchmod u+x file           # Add execute for owner\nchmod g-w file           # Remove write for group\nchmod o+r file           # Add read for others\nchmod a+x file           # Add execute for all\n\n# Change permissions (numeric)\nchmod 644 file           # rw-r--r--\nchmod 755 file           # rwxr-xr-x\nchmod 600 file           # rw-------\n\n# Change ownership\nsudo chown user file     # Change owner\nsudo chown user:group file  # Change both\nsudo chown -R user folder   # Recursive\n\n# Elevate privileges\nsudo command             # Run as admin\n```"
    },
    {
      "id": "cli-searching",
      "moduleId": "terminal-cli",
      "title": "Searching & Finding",
      "order": 5,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- find locates files by name/type\n- grep searches file contents\n- Combine with pipes for power\n- Modern alternatives: fd, ripgrep\n\n---\n\n# Searching and Finding Files\n\n## Finding Files by Name\n\n### find Command\n\nThe `find` command searches for files and directories based on various criteria.\n\n```bash\n# Find by name (exact match)\nfind . -name \"file.txt\"\n\n# Find by name (case-insensitive)\nfind . -iname \"FILE.txt\"\n\n# Find by pattern (wildcards)\nfind . -name \"*.js\"\nfind . -name \"data*\"\n\n# Find directories only\nfind . -type d -name \"node_modules\"\n\n# Find files only\nfind . -type f -name \"*.json\"\n\n# Find by size (larger than 10MB)\nfind . -size +10M\n\n# Find modified in last 7 days\nfind . -mtime -7\n\n# Find and delete (USE WITH CAUTION!)\nfind . -name \"*.tmp\" -delete\n\n# Find and execute command\nfind . -name \"*.log\" -exec ls -lh {} \\;\n```\n\n**Common find options:**\n- `.` = start from current directory\n- `-name` = match exact name\n- `-iname` = case-insensitive name\n- `-type f` = files only\n- `-type d` = directories only\n- `-size` = file size\n- `-mtime` = modification time\n- `-exec` = run command on results\n\n## Searching File Contents\n\n### grep - Global Regular Expression Print\n\n```bash\n# Search for text in files\ngrep \"error\" log.txt\n\n# Search case-insensitive\ngrep -i \"ERROR\" log.txt\n\n# Search recursively in directory\ngrep -r \"TODO\" .\n\n# Show line numbers\ngrep -n \"function\" app.js\n\n# Show context (lines before and after)\ngrep -C 2 \"exception\" log.txt\n\n# Count matches\ngrep -c \"failed\" log.txt\n\n# Invert match (lines NOT matching)\ngrep -v \"success\" log.txt\n\n# Search multiple patterns\ngrep -E \"error|warning|critical\" log.txt\n```\n\n**Common grep flags:**\n- `-i` = ignore case\n- `-r` = recursive\n- `-n` = show line numbers\n- `-C` = context lines\n- `-c` = count only\n- `-v` = invert match\n- `-E` = extended regex\n- `-l` = list filenames only\n\n## Combining Commands with Pipes\n\nThe pipe operator `|` sends the output of one command as input to another.\n\n```bash\n# Count files in directory\nls | wc -l\n\n# Find and sort\nfind . -name \"*.js\" | sort\n\n# Search and filter\ncat log.txt | grep \"ERROR\" | head -20\n\n# Multiple pipes\nps aux | grep \"node\" | grep -v \"grep\" | wc -l\n```\n\n## Practical Search Examples\n\n### Find Large Files\n\n```bash\n# Find files over 100MB\nfind . -type f -size +100M\n\n# Find and sort by size\nfind . -type f -size +10M -exec ls -lh {} \\; | sort -k5 -rh\n```\n\n### Search Codebase\n\n```bash\n# Find TODO comments\ngrep -r \"TODO\" --include=\"*.js\" --include=\"*.ts\" .\n\n# Find unused imports (in Python)\ngrep -r \"^import\" --include=\"*.py\" . | sort | uniq -c | sort -nr\n\n# Find function definitions\ngrep -rn \"function \" --include=\"*.js\" .\ngrep -rn \"def \" --include=\"*.py\" .\n```\n\n### Process Log Files\n\n```bash\n# Extract IP addresses from logs\ngrep -oE \"\\b[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\b\" access.log\n\n# Count unique IPs\ngrep -oE \"\\b[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\b\" access.log | sort | uniq | wc -l\n\n# Find most frequent error messages\ngrep \"ERROR\" app.log | cut -d' ' -f3- | sort | uniq -c | sort -nr | head -10\n```\n\n## Modern Alternatives\n\n### fd - A Faster find\n\n```bash\n# Install: https://github.com/sharkdp/fd\n\n# Simpler syntax\nfd \"*.js\"\n\n# Case-insensitive by default\nfd readme\n\n# Exclude directories\nfd -E node_modules \"*.json\"\n\n# Execute command on results\nfd \"*.log\" -x rm {}\n```\n\n### ripgrep (rg) - A Faster grep\n\n```bash\n# Install: https://github.com/BurntSushi/ripgrep\n\n# Faster than grep, respects .gitignore\nrg \"TODO\"\n\n# File type filtering\nrg \"function\" -t js\n\n# Show context\nrg \"error\" -C 3\n\n# Search specific files\nrg \"apiKey\" --type-add 'config:*.config.js' -t config\n```\n\n## Quick Reference\n\n```bash\n# Finding files\nfind . -name \"file.txt\"        # Find by name\nfind . -name \"*.js\"            # Find by pattern\nfind . -type d -name \"test\"    # Find directories\nfind . -size +10M                # Find large files\n\n# Searching content\ngrep \"pattern\" file.txt        # Basic search\ngrep -r \"pattern\" .            # Recursive\ngrep -i \"pattern\" file.txt     # Case-insensitive\ngrep -n \"pattern\" file.txt     # Show line numbers\ngrep -C 3 \"pattern\" file.txt   # Show context\n\n# Pipes\ncommand1 | command2             # Chain commands\nls | grep \"txt\"                # Filter output\ncat file | grep \"error\"        # Search file\n\n# Modern tools\nfd \"*.js\"                       # Fast find\nrg \"TODO\"                      # Fast grep\n```"
    },
    {
      "id": "cli-env-variables",
      "moduleId": "terminal-cli",
      "title": "Environment Variables",
      "order": 6,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Variables store configuration values\n- export makes them available to child processes\n- PATH tells shell where to find commands\n- .bashrc/.zshrc run on shell start\n\n---\n\n# Environment Variables\n\n## What Are Environment Variables?\n\nEnvironment variables are dynamic values that affect how running processes behave on a computer. They're used to store configuration settings, API keys, paths, and other system-wide values.\n\n## Viewing Environment Variables\n\n### echo - Display Variable Value\n\n```bash\n# Show a specific variable\necho $HOME\necho $USER\necho $PATH\n\n# Show all variables\nenv\n\n# Show variables matching pattern\nenv | grep \"USER\"\n```\n\n**Common environment variables:**\n- `$HOME` - Your home directory\n- `$USER` - Your username\n- `$PATH` - Command search directories\n- `$PWD` - Current directory\n- `$SHELL` - Current shell\n- `$TERM` - Terminal type\n\n## Setting Variables\n\n### Session Variables (temporary)\n\n```bash\n# Set a variable (no spaces around =)\nMY_VAR=\"Hello World\"\n\n# Use it\necho $MY_VAR\n\n# Variables with commands\nOUTPUT=$(ls -la)\necho $OUTPUT\n```\n\n**Important:** No spaces around the `=` sign!\n\n### Exporting Variables\n\nVariables are only available in the current shell unless exported:\n\n```bash\n# Not exported (child processes can't see it)\nMY_SECRET=\"password123\"\nbash -c 'echo $MY_SECRET'  # Prints nothing\n\n# Exported (available to child processes)\nexport MY_SECRET=\"password123\"\nbash -c 'echo $MY_SECRET'  # Prints: password123\n```\n\n## The PATH Variable\n\nPATH tells the shell where to look for executable commands.\n\n```bash\n# View PATH\necho $PATH\n# Output: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\n```\n\nWhen you type a command, the shell searches these directories in order.\n\n### Adding to PATH\n\n```bash\n# Add directory to PATH (temporary)\nexport PATH=\"/usr/local/bin:$PATH\"\n\n# Add to beginning (higher priority)\nexport PATH=\"/my/custom/path:$PATH\"\n\n# Add to end (lower priority)\nexport PATH=\"$PATH:/my/custom/path\"\n```\n\n## Persistent Configuration\n\n### Shell Configuration Files\n\nVariables set in these files persist across sessions:\n\n**Bash:**\n- `~/.bashrc` - Commands for interactive shells\n- `~/.bash_profile` - Login shells\n- `~/.profile` - General profile\n\n**Zsh:**\n- `~/.zshrc` - Main configuration\n- `~/.zprofile` - Login shells\n\n### Example Configuration\n\n```bash\n# Add to ~/.zshrc or ~/.bashrc\n\n# Custom PATH\nexport PATH=\"$HOME/bin:$PATH\"\n\n# Development shortcuts\nexport EDITOR=\"code\"\nexport BROWSER=\"firefox\"\n\n# Project-specific\nexport NODE_ENV=\"development\"\n\n# API keys (be careful with secrets!)\nexport API_KEY=\"sk-12345\"\n```\n\n**After editing, reload:**\n```bash\nsource ~/.zshrc\n# or\nsource ~/.bashrc\n```\n\n## Practical Examples\n\n### Temporary vs Persistent\n\n```bash\n# This is temporary (gone after closing terminal)\nexport TEMP_VAR=\"hello\"\n\n# To make it permanent, add to ~/.zshrc:\necho 'export PERM_VAR=\"world\"' >> ~/.zshrc\nsource ~/.zshrc\n```\n\n### Checking if Variable Exists\n\n```bash\n# Check if variable is set\nif [ -z \"$MY_VAR\" ]; then\n    echo \"MY_VAR is not set\"\nelse\n    echo \"MY_VAR is: $MY_VAR\"\nfi\n\n# Set default if not exists\nexport MY_VAR=\"${MY_VAR:-default_value}\"\n```\n\n### Variable Substitution\n\n```bash\nNAME=\"John\"\n\n# Basic usage\necho \"Hello, $NAME!\"  # Hello, John!\n\n# With braces (useful for concatenation)\necho \"Hello, ${NAME}!\"  # Hello, John!\necho \"${NAME}son\"      # Johnson\n\n# Command substitution\nDATE=$(date)\necho \"Today is $DATE\"\n\n# Math (in bash)\nRESULT=$((5 + 3))\necho $RESULT  # 8\n```\n\n## Quick Reference\n\n```bash\n# View variables\necho $VAR              # Show variable value\nenv                    # Show all variables\nenv | grep PATTERN     # Filter variables\n\n# Set variables\nVAR=value              # Set (current shell only)\nexport VAR=value       # Set (available to children)\nunset VAR              # Remove variable\n\n# PATH management\necho $PATH             # Show PATH\nexport PATH=\"/new/path:$PATH\"  # Add to PATH\n\n# Persistent config\n~/.bashrc              # Bash config\n~/.zshrc               # Zsh config\nsource ~/.zshrc        # Reload config\n```"
    },
    {
      "id": "cli-redirection",
      "moduleId": "terminal-cli",
      "title": "Input/Output & Pipes",
      "order": 7,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- > redirects output to file (overwrites)\n- >> appends to file\n- | pipes output to another command\n- Chain commands for powerful workflows\n\n---\n\n# Input/Output Redirection and Pipes\n\n## Understanding I/O Streams\n\nEvery process in Unix has three standard I/O streams:\n\n- **stdin (0)**: Standard input - where programs read from\n- **stdout (1)**: Standard output - where normal output goes\n- **stderr (2)**: Standard error - where errors go\n\nBy default:\n- stdin comes from your keyboard\n- stdout and stderr go to your terminal screen\n\n## Output Redirection\n\n### \u003e - Redirect stdout to File (Overwrite)\n\n```bash\n# Save command output to file\nls -la \u003e file-list.txt\n\n# Save command output (explicit stdout)\nls -la 1\u003e file-list.txt\n\n# Redirect stderr to file\nls nonexistent 2\u003e errors.txt\n\n# Redirect both stdout and stderr\ncommand \u003e output.txt 2\u003e errors.txt\n\n# Redirect stderr to stdout (both go to same place)\ncommand \u003e output.txt 2\u003e\u00261\n# Modern equivalent:\ncommand \u003e output.txt 2\u003e\u00261\n```\n\n**⚠️ Warning:** `\u003e` overwrites existing files!\n\n### \u003e\u003e - Append to File\n\n```bash\n# Add to end of file (doesn't overwrite)\necho \"New log entry\" \u003e\u003e app.log\n\n# Append command output\nls \u003e\u003e file-list.txt\n```\n\n## Input Redirection\n\n### \u003c - Read from File\n\n```bash\n# Feed file content as input\nsort \u003c unsorted.txt\n\n# Count lines in file\nwc -l \u003c file.txt\n\n# Here document (multi-line input)\ncat \u003c\u003c EOF\nThis is line 1\nThis is line 2\nThis is line 3\nEOF\n```\n\n## Pipes |\n\nPipes connect stdout of one command to stdin of another.\n\n```bash\n# Basic pipe\ncat file.txt | grep \"error\"\n\n# Multiple pipes\ncat log.txt | grep \"ERROR\" | sort | uniq | wc -l\n\n# Common patterns\nls -la | less           # Page through output\nps aux | grep \"node\"   # Find node processes\nhistory | grep \"git\"   # Search command history\n```\n\n## The tee Command\n\n`tee` displays output AND saves it to file (splits the stream):\n\n```bash\n# Show output AND save to file\nls -la | tee file-list.txt\n\n# Append instead of overwrite\necho \"new line\" | tee -a log.txt\n\n# Save to multiple files\ncommand | tee file1.txt file2.txt\n```\n\n## Combining Redirection\n\n### Suppressing Output\n\n```bash\n# Redirect stdout to /dev/null (discard)\ncommand \u003e /dev/null\n\n# Redirect stderr to /dev/null\ncommand 2\u003e /dev/null\n\n# Discard both stdout and stderr\ncommand \u003e /dev/null 2\u003e\u00261\n# or modern shortcut:\ncommand \u003e /dev/null 2\u003e\u00261\n```\n\n### Redirecting to Multiple Places\n\n```bash\n# Save stdout to file, show stderr on screen\ncommand \u003e output.txt\n\n# Save stderr to file, show stdout on screen\ncommand 2\u003e errors.txt\n\n# Save both to separate files\ncommand \u003e output.txt 2\u003e errors.txt\n\n# Save both to same file\ncommand \u003e all-output.txt 2\u003e\u00261\n```\n\n## Practical Examples\n\n### Log Analysis\n\n```bash\n# Extract errors and save to file\ngrep \"ERROR\" app.log \u003e errors-only.log\n\n# Count unique error types\ngrep \"ERROR\" app.log | cut -d' ' -f3 | sort | uniq -c | sort -nr\n\n# Watch log in real-time and filter\ntail -f app.log | grep \"exception\"\n```\n\n### Building Reports\n\n```bash\n# Create a report file\necho \"=== System Report ===\" \u003e report.txt\ndate \u003e\u003e report.txt\necho \"\" \u003e\u003e report.txt\necho \"Disk Usage:\" \u003e\u003e report.txt\ndf -h \u003e\u003e report.txt\necho \"\" \u003e\u003e report.txt\necho \"Memory Usage:\" \u003e\u003e report.txt\nfree -h \u003e\u003e report.txt\n```\n\n### Process Management\n\n```bash\n# Find and kill processes\nps aux | grep \"node\" | grep -v grep | awk '{print $2}' | xargs kill\n\n# Check if service is running\nps aux | grep nginx | grep -v grep \u003e /dev/null \u0026\u0026 echo \"Running\" || echo \"Not running\"\n```\n\n## Quick Reference\n\n```bash\n# Output redirection\ncmd \u003e file              # Redirect stdout (overwrite)\ncmd \u003e\u003e file             # Redirect stdout (append)\ncmd 2\u003e file             # Redirect stderr\ncmd \u003e file 2\u003e\u00261       # Redirect both to file\ncmd \u003e /dev/null         # Discard stdout\n\n# Input redirection\ncmd \u003c file              # Read stdin from file\n\n# Pipes\ncmd1 | cmd2             # Pipe stdout of cmd1 to stdin of cmd2\ncmd1 | cmd2 | cmd3      # Chain multiple commands\n\n# tee\ncmd | tee file          # Show output AND save\ncmd | tee -a file       # Append to file\n\n# /dev/null\n/dev/null               # Black hole (discard output)\n```"
    },
    {
      "id": "cli-scripts",
      "moduleId": "terminal-cli",
      "title": "Shell Scripts Basics",
      "order": 8,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- Scripts are files with shell commands\n- Start with #!/bin/bash (shebang)\n- Make executable with chmod +x\n- Variables, conditionals, loops\n\n---\n\n# Shell Scripts Basics\n\n## What is a Shell Script?\n\nA shell script is a text file containing multiple shell commands that can be executed together. Scripts are perfect for automating repetitive tasks, setting up environments, and creating custom utilities.\n\n## Creating Your First Script\n\n### Step 1: Create the File\n\n```bash\n# Create a new script file\ntouch myscript.sh\n\n# Open in your editor\nnano myscript.sh\n# or\ncode myscript.sh\n```\n\n### Step 2: Add the Shebang\n\nEvery script starts with a \"shebang\" line that tells the system which interpreter to use:\n\n```bash\n#!/bin/bash\n```\n\nOr for more modern systems:\n```bash\n#!/usr/bin/env bash\n```\n\n### Step 3: Write Commands\n\n```bash\n#!/bin/bash\n\n# This is a comment\necho \"Hello, World!\"\necho \"Current date: $(date)\"\necho \"Current user: $USER\"\n```\n\n### Step 4: Make It Executable\n\n```bash\nchmod +x myscript.sh\n```\n\n### Step 5: Run It\n\n```bash\n# Run in current directory\n./myscript.sh\n\n# Or with bash explicitly\nbash myscript.sh\n```\n\n## Variables in Scripts\n\n```bash\n#!/bin/bash\n\n# Define variables (no spaces around =)\nNAME=\"John\"\nAGE=30\n\n# Use variables with $\necho \"Name: $NAME\"\necho \"Age: $AGE\"\n\n# Command substitution\nCURRENT_DATE=$(date)\necho \"Today is: $CURRENT_DATE\"\n\n# Math\nRESULT=$((5 + 3))\necho \"5 + 3 = $RESULT\"\n```\n\n## User Input\n\n```bash\n#!/bin/bash\n\n# Prompt for input\necho -n \"Enter your name: \"\nread USERNAME\n\necho \"Hello, $USERNAME!\"\n\n# Read with prompt\nread -p \"Enter your age: \" AGE\necho \"You are $AGE years old\"\n\n# Silent input (for passwords)\nread -sp \"Enter password: \" PASSWORD\necho \"\"  # New line\necho \"Password length: ${#PASSWORD}\"\n```\n\n## Conditionals (if/else)\n\n```bash\n#!/bin/bash\n\n# Basic if statement\nif [ -f \"file.txt\" ]; then\n    echo \"File exists\"\nfi\n\n# If-else\nread -p \"Enter a number: \" NUM\n\nif [ $NUM -gt 10 ]; then\n    echo \"Greater than 10\"\nelif [ $NUM -eq 10 ]; then\n    echo \"Equal to 10\"\nelse\n    echo \"Less than 10\"\nfi\n\n# String comparison\nif [ \"$USER\" = \"john\" ]; then\n    echo \"Welcome, John!\"\nfi\n\n# Check if variable is empty\nif [ -z \"$VAR\" ]; then\n    echo \"VAR is not set\"\nfi\n```\n\n### Comparison Operators\n\n**Numbers:**\n- `-eq` : equal\n- `-ne` : not equal\n- `-lt` : less than\n- `-le` : less than or equal\n- `-gt` : greater than\n- `-ge` : greater than or equal\n\n**Strings:**\n- `=` or `==` : equal\n- `!=` : not equal\n- `-z` : is empty\n- `-n` : is not empty\n\n**Files:**\n- `-e` : exists\n- `-f` : is a file\n- `-d` : is a directory\n- `-r` : is readable\n- `-w` : is writable\n- `-x` : is executable\n\n## Loops\n\n### For Loops\n\n```bash\n#!/bin/bash\n\n# Loop through numbers\nfor i in 1 2 3 4 5; do\n    echo \"Number: $i\"\ndone\n\n# Range\nfor i in {1..5}; do\n    echo \"Count: $i\"\ndone\n\n# Loop through files\nfor file in *.txt; do\n    echo \"Processing: $file\"\ndone\n\n# Loop through array\nFRUITS=(\"apple\" \"banana\" \"cherry\")\nfor fruit in \"${FRUITS[@]}\"; do\n    echo \"I like $fruit\"\ndone\n```\n\n### While Loops\n\n```bash\n#!/bin/bash\n\n# Basic while loop\nCOUNT=0\nwhile [ $COUNT -lt 5 ]; do\n    echo \"Count: $COUNT\"\n    COUNT=$((COUNT + 1))\ndone\n\n# Read file line by line\nwhile read LINE; do\n    echo \"Line: $LINE\"\ndone < file.txt\n\n# Infinite loop with break\nwhile true; do\n    read -p \"Enter 'quit' to exit: \" INPUT\n    if [ \"$INPUT\" = \"quit\" ]; then\n        break\n    fi\n    echo \"You entered: $INPUT\"\ndone\n```\n\n## Functions\n\n```bash\n#!/bin/bash\n\n# Define a function\ngreet() {\n    echo \"Hello, $1!\"\n    echo \"You are $2 years old\"\n}\n\n# Call with arguments\ngreet \"Alice\" 30\n\n# Function with return value\nadd() {\n    return $(($1 + $2))\n}\n\nadd 5 3\nRESULT=$?  # Capture return value\necho \"Result: $RESULT\"\n\n# Better: use echo for output\nmultiply() {\n    echo $(($1 * $2))\n}\n\nRESULT=$(multiply 4 5)\necho \"4 x 5 = $RESULT\"\n```\n\n## Practical Script Examples\n\n### Backup Script\n\n```bash\n#!/bin/bash\n\n# Configuration\nSOURCE_DIR=\"$HOME/Documents\"\nBACKUP_DIR=\"$HOME/Backups\"\nDATE=$(date +%Y%m%d_%H%M%S)\nBACKUP_FILE=\"backup_$DATE.tar.gz\"\n\n# Create backup directory if it doesn't exist\nmkdir -p \"$BACKUP_DIR\"\n\n# Create backup\necho \"Creating backup...\"\ntar -czf \"$BACKUP_DIR/$BACKUP_FILE\" -C \"$SOURCE_DIR\" .\n\n# Check if backup was successful\nif [ $? -eq 0 ]; then\n    echo \"Backup created successfully: $BACKUP_FILE\"\n    echo \"Size: $(du -h \"$BACKUP_DIR/$BACKUP_FILE\" | cut -f1)\"\nelse\n    echo \"Backup failed!\"\n    exit 1\nfi\n```\n\n### Project Setup Script\n\n```bash\n#!/bin/bash\n\nPROJECT_NAME=$1\n\nif [ -z \"$PROJECT_NAME\" ]; then\n    echo \"Usage: $0 <project-name>\"\n    exit 1\nfi\n\n# Create project structure\nmkdir -p \"$PROJECT_NAME\"/{src,tests,docs}\ncd \"$PROJECT_NAME\"\n\n# Initialize git\ngit init\n\n# Create files\ncat > README.md << 'EOF'\n# Project Name\n\nDescription here.\nEOF\n\ncat > .gitignore << 'EOF'\nnode_modules/\n.env\n*.log\nEOF\n\necho \"Project '$PROJECT_NAME' created successfully!\"\necho \"Structure:\"\nfind . -type f -o -type d | sort\n```\n\n### Log Rotation Script\n\n```bash\n#!/bin/bash\n\nLOG_DIR=\"/var/log/myapp\"\nMAX_SIZE=\"100M\"\nMAX_AGE=7  # days\n\n# Check if log directory exists\nif [ ! -d \"$LOG_DIR\" ]; then\n    echo \"Log directory not found: $LOG_DIR\"\n    exit 1\nfi\n\n# Rotate large logs\nfind \"$LOG_DIR\" -name \"*.log\" -size +$MAX_SIZE | while read LOG_FILE; do\n    TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n    mv \"$LOG_FILE\" \"$LOG_FILE.$TIMESTAMP\"\n    gzip \"$LOG_FILE.$TIMESTAMP\"\n    touch \"$LOG_FILE\"\n    echo \"Rotated: $LOG_FILE\"\ndone\n\n# Delete old rotated logs\nfind \"$LOG_DIR\" -name \"*.gz\" -mtime +$MAX_AGE -delete\necho \"Removed logs older than $MAX_AGE days\"\n```\n\n## Quick Reference\n\n```bash\n# Script basics\n#!/bin/bash            # Shebang\nchmod +x script.sh     # Make executable\n./script.sh            # Run script\n\n# Variables\nVAR=value              # Set variable\necho $VAR              # Use variable\n$(command)             # Command substitution\n\n# Conditionals\nif [ condition ]; then\n    # commands\nelif [ condition ]; then\n    # commands\nelse\n    # commands\nfi\n\n# Loops\nfor item in list; do\n    # commands\ndone\n\nwhile [ condition ]; do\n    # commands\ndone\n\n# Functions\nfunction_name() {\n    echo $1  # First argument\n    return 0\n}\n\n# Special variables\n$0          # Script name\n$1, $2, ... # Arguments\n$#          # Number of arguments\n$@          # All arguments\n$?          # Exit status of last command\n$$          # Process ID\n```\n\n## Best Practices\n\n1. **Always use quotes** around variables: \"$VAR\" not $VAR\n2. **Check if commands succeed** using $?\n3. **Add error handling**: `set -e` exits on error\n4. **Use meaningful names** for variables and functions\n5. **Add comments** explaining complex logic\n6. **Test scripts** before running on production data"
    },
    {
      "id": "cli-productivity",
      "moduleId": "terminal-cli",
      "title": "Terminal Productivity",
      "order": 9,
      "difficulty": "intermediate",
      "content": "# Essential to know\n- history shows past commands\n- Ctrl+R for reverse search\n- aliases create shortcuts\n- Tab completion saves typing\n\n---\n\n# Terminal Productivity\n\n## Command History\n\n### Viewing History\n\n```bash\n# Show all previous commands\nhistory\n\n# Show last 20 commands\nhistory 20\n\n# Search history\nhistory | grep \"git\"\n```\n\n### History Shortcuts\n\n```bash\n!!           # Run last command again\n!n           # Run command number n from history\n!-n          # Run nth command from last\n!string      # Run last command starting with 'string'\n!?string     # Run last command containing 'string'\n^old^new     # Replace and run (only first occurrence)\n!!:s/old/new # Replace in last command\n```\n\nExamples:\n```bash\n$ echo hello\nhello\n$ !!\necho hello\nhello\n\n$ ls -la\n...\n$ !ls\nls -la\n...\n\n$ git status\n...\n$ ^status^log\ngit log\n```\n\n## Reverse Search (Ctrl+R)\n\nPress `Ctrl+R` to search backwards through your command history:\n\n```bash\n# Press Ctrl+R, then type part of a previous command\n(reverse-i-search)`git': git commit -m \"Update readme\"\n\n# Press Ctrl+R again to find earlier matches\n(reverse-i-search)`git': git add .\n\n# Press Enter to run the found command\n# Press Ctrl+C to cancel\n# Press Right arrow to edit the command\n```\n\n## Command Aliases\n\nAliases are shortcuts for frequently used commands.\n\n### Creating Aliases\n\n```bash\n# Temporary alias (current session only)\nalias ll='ls -lah'\nalias gs='git status'\nalias gp='git pull'\n\n# Use the alias\nll          # Runs: ls -lah\ngs          # Runs: git status\n```\n\n### Persistent Aliases\n\nAdd to your shell configuration file:\n\n```bash\n# For Zsh\nnano ~/.zshrc\n\n# For Bash\nnano ~/.bashrc\n```\n\nAdd your aliases:\n\n```bash\n# Navigation\nalias ..='cd ..'\nalias ...='cd ../..'\nalias ....='cd ../../..'\nalias ~='cd ~'\n\n# List files\nalias ls='ls --color=auto'\nalias ll='ls -lah'\nalias la='ls -A'\nalias l='ls -CF'\n\n# Git shortcuts\nalias g='git'\nalias gs='git status'\nalias ga='git add'\nalias gc='git commit'\nalias gp='git push'\nalias gl='git log --oneline'\n\n# Safety\nalias rm='rm -i'\nalias cp='cp -i'\nalias mv='mv -i'\n\n# Utilities\nalias c='clear'\nalias h='history'\nalias mkdir='mkdir -pv'\n```\n\nThen reload:\n```bash\nsource ~/.zshrc\n```\n\n## Tab Completion\n\nTab completion saves typing and prevents errors.\n\n```bash\n# Complete commands\ngit sta<TAB>    # Completes to: git status\n\n# Complete file/directory names\ncd Doc<TAB>     # Completes to: cd Documents/\n\n# Complete paths\ncat /etc/ngi<TAB>  # Completes to: cat /etc/nginx/\n\n# Show all options (press TAB twice)\ncd D<TAB><TAB>  # Shows: Desktop/ Documents/ Downloads/\n```\n\n## Keyboard Shortcuts\n\n### Navigation\n\n| Shortcut | Action |\n|----------|--------|\n| `Ctrl+A` | Move to start of line |\n| `Ctrl+E` | Move to end of line |\n| `Alt+F` / `Option+→` | Move forward one word |\n| `Alt+B` / `Option+←` | Move backward one word |\n| `Ctrl+XX` | Toggle between start and current position |\n\n### Editing\n\n| Shortcut | Action |\n|----------|--------|\n| `Ctrl+U` | Delete from cursor to start of line |\n| `Ctrl+K` | Delete from cursor to end of line |\n| `Ctrl+W` | Delete word before cursor |\n| `Alt+D` | Delete word after cursor |\n| `Ctrl+Y` | Paste (yank) deleted text |\n| `Ctrl+T` | Swap character under cursor with previous |\n| `Alt+T` | Swap word under cursor with previous |\n| `Ctrl+_` / `Ctrl+X+U` | Undo |\n\n### Process Control\n\n| Shortcut | Action |\n|----------|--------|\n| `Ctrl+C` | Interrupt (cancel) current command |\n| `Ctrl+Z` | Suspend current command (background) |\n| `Ctrl+D` | End of input / Exit shell |\n| `Ctrl+L` | Clear screen |\n| `Ctrl+S` | Stop output (pause) |\n| `Ctrl+Q` | Resume output |\n\n### History\n\n| Shortcut | Action |\n|----------|--------|\n| `Ctrl+P` / `↑` | Previous command |\n| `Ctrl+N` / `↓` | Next command |\n| `Ctrl+R` | Reverse search |\n| `Ctrl+G` | Cancel search |\n| `Alt+.` | Insert last argument |\n| `Alt+N+.` | Insert Nth last argument |\n\n## Customizing Your Prompt\n\n### Basic Prompt Customization\n\n```bash\n# Show current directory\nexport PS1=\"\\w $ \"\n\n# Show username and directory\nexport PS1=\"\\u@\\h:\\w $ \"\n\n# Add colors\nexport PS1=\"\\[\\e[32m\\]\\u@\\h\\[\\e[m\\]:\\[\\e[34m\\]\\w\\[\\e[m\\]\\$ \"\n```\n\n### Using Starship (Recommended)\n\n[Starship](https://starship.rs) is a fast, customizable prompt:\n\n```bash\n# Install\ncurl -sS https://starship.rs/install.sh | sh\n\n# Add to shell config\necho 'eval \"$(starship init bash)\"' >> ~/.bashrc\necho 'eval \"$(starship init zsh)\"' >> ~/.zshrc\n```\n\n## Useful Terminal Tools\n\n### File and Directory Viewers\n\n**tree** - Display directory structure\n```bash\n# Install: brew install tree / apt-get install tree\n\ntree                    # Show full tree\ntree -L 2              # Limit depth to 2 levels\ntree -I node_modules   # Ignore directories\ntree -a                # Show hidden files\n```\n\n**exa** (modern replacement for ls)\n```bash\n# Install: https://the.exa.website/\n\nexa -la                # Better ls\nexa -T                 # Tree view\nexa --icons            # With file icons\nexa --git              # Show git status\n```\n\n**bat** (better cat)\n```bash\n# Install: https://github.com/sharkdp/bat\n\nbat file.txt           # Syntax highlighting\nbat --plain file.txt   # Plain mode (like cat)\nbat --diff file.txt    # Show git diff\n```\n\n### System Monitoring\n\n**htop** (interactive process viewer)\n```bash\n# Install: brew install htop / apt-get install htop\n\nhtop                   # Interactive process list\n# F1: Help\n# F3: Search\n# F4: Filter\n# F5: Tree view\n# F6: Sort\n# F9: Kill process\n# F10: Quit\n```\n\n**btm** (modern system monitor)\n```bash\n# Install: https://github.com/ClementTsang/bottom\nbtm\n```\n\n**duf** (disk usage)\n```bash\n# Install: https://github.com/muesli/duf\nduf                    # Better df\nduf --only local       # Local filesystems only\n```\n\n**ncdu** (disk usage analyzer)\n```bash\n# Install: brew install ncdu / apt-get install ncdu\nncdu                   # Interactive disk usage\nncdu /path/to/dir      # Analyze specific directory\n```\n\n### File Search\n\n**fzf** (fuzzy finder)\n```bash\n# Install: https://github.com/junegunn/fzf\n\n# Interactive file finder\nfind . -type f | fzf\n\n# Interactive history search (Ctrl+R integration)\n# Add to .zshrc: source <(fzf --zsh)\n```\n\n**fd** (better find)\n```bash\n# Install: https://github.com/sharkdp/fd\n\nfd \"*.js\"              # Find JS files\nfd -t d node_modules     # Find directories\nfd -e js -e ts           # Multiple extensions\n```\n\n### Text Processing\n\n**ripgrep (rg)** (better grep)\n```bash\n# Install: https://github.com/BurntSushi/ripgrep\n\nrg \"TODO\"              # Fast recursive search\nrg -i \"todo\"           # Case insensitive\nrg -t js \"function\"    # Search JS files only\nrg \"pattern\" --files-with-matches\n```\n\n**delta** (better git diff)\n```bash\n# Install: https://github.com/dandavison/delta\n\n# Configure git to use delta\ngit config --global core.pager delta\ngit config --global delta.side-by-side true\n\n# Now git diff shows syntax highlighting\n```\n\n## Quick Reference\n\n```bash\n# History\nhistory                # Show command history\n!!                     # Run last command\n!n                     # Run command n\n!string                # Run last command starting with string\n^old^new               # Replace and run\n\n# Search\nCtrl+R                 # Reverse search\n\n# Aliases\nalias name='command'   # Create alias\nalias                  # List all aliases\nunalias name           # Remove alias\n\n# Keyboard shortcuts\nCtrl+A                 # Start of line\nCtrl+E                 # End of line\nCtrl+U                 # Delete to start\nCtrl+K                 # Delete to end\nCtrl+W                 # Delete word\nCtrl+Y                 # Paste deleted text\nCtrl+L                 # Clear screen\nCtrl+C                 # Cancel command\nAlt+.                  # Last argument\n\n# Useful tools\ntree                   # Directory structure\nhtop                   # Process viewer\nbat                    # Better cat\nexa                    # Better ls\nfd                     # Better find\nrg                     # Better grep\nfzf                    # Fuzzy finder\nncdu                   # Disk usage\n```\n\n## Practice Session\n\n```bash\n# 1. Try history shortcuts\necho hello\n!!\n\n# 2. Use reverse search\n# Press Ctrl+R and type 'echo'\n\n# 3. Create aliases\nalias hi='echo Hello, World!'\nhi\n\n# 4. Practice keyboard shortcuts\n# Type a long command, then use Ctrl+A, Ctrl+E, Ctrl+W\n\n# 5. Install some tools\n# brew install tree htop bat fd fzf ripgrep\n\n# 6. Try them out\ntree -L 2\nbat ~/.zshrc\nfd \".md\"\n```"
    }
  ],
  "exercises": []
}
